{
  sector0 = {},
  sector1 = {
    folders = {
      "rom",
      "rom/apis",
      "rom/apis/command",
      "rom/apis/pocket",
      "rom/apis/turtle",
      "rom/autorun",
      "rom/help",
      "rom/help/licenses",
      "rom/programs",
      "rom/programs/advanced",
      "rom/programs/command",
      "rom/programs/fun",
      "rom/programs/fun/advanced",
      "rom/programs/fun/advanced/levels",
      "rom/programs/http",
      "rom/programs/pocket",
      "rom/programs/rednet",
      "rom/programs/turtle",
    },
    files = {
      "KrapFile",
      "loadall",
      "rom/apis/colors",
      "rom/apis/colours",
      "rom/apis/command/commands",
      "rom/apis/disk",
      "rom/apis/gps",
      "rom/apis/help",
      "rom/apis/io",
      "rom/apis/keys",
      "rom/apis/paintutils",
      "rom/apis/parallel",
      "rom/apis/peripheral",
      "rom/apis/rednet",
      "rom/apis/settings",
      "rom/apis/term",
      "rom/apis/textutils",
      "rom/apis/turtle/turtle",
      "rom/apis/vector",
      "rom/apis/window",
      "rom/autorun/.ignoreme",
      "rom/help/adventure",
      "rom/help/alias",
      "rom/help/apis",
      "rom/help/bg",
      "rom/help/bit",
      "rom/help/bundled",
      "rom/help/cd",
      "rom/help/changelog",
      "rom/help/chat",
      "rom/help/clear",
      "rom/help/colors",
      "rom/help/colours",
      "rom/help/commands",
      "rom/help/commandsapi",
      "rom/help/copy",
      "rom/help/coroutine",
      "rom/help/craft",
      "rom/help/credits",
      "rom/help/dance",
      "rom/help/delete",
      "rom/help/disk",
      "rom/help/dj",
      "rom/help/drive",
      "rom/help/drives",
      "rom/help/earth",
      "rom/help/edit",
      "rom/help/eject",
      "rom/help/equip",
      "rom/help/events",
      "rom/help/excavate",
      "rom/help/exec",
      "rom/help/exit",
      "rom/help/falling",
      "rom/help/fg",
      "rom/help/fs",
      "rom/help/go",
      "rom/help/gps",
      "rom/help/gpsapi",
      "rom/help/hello",
      "rom/help/help",
      "rom/help/helpapi",
      "rom/help/http",
      "rom/help/id",
      "rom/help/intro",
      "rom/help/io",
      "rom/help/keys",
      "rom/help/label",
      "rom/help/licenses/luaj",
      "rom/help/list",
      "rom/help/lua",
      "rom/help/math",
      "rom/help/mkdir",
      "rom/help/modems",
      "rom/help/monitor",
      "rom/help/monitors",
      "rom/help/move",
      "rom/help/multishell",
      "rom/help/os",
      "rom/help/paint",
      "rom/help/paintutils",
      "rom/help/parallel",
      "rom/help/pastebin",
      "rom/help/peripheral",
      "rom/help/peripherals",
      "rom/help/printers",
      "rom/help/programming",
      "rom/help/programs",
      "rom/help/reboot",
      "rom/help/redirection",
      "rom/help/rednet",
      "rom/help/redstone",
      "rom/help/redstoneapi",
      "rom/help/refuel",
      "rom/help/rename",
      "rom/help/repeat",
      "rom/help/rs",
      "rom/help/set",
      "rom/help/settings",
      "rom/help/shell",
      "rom/help/shellapi",
      "rom/help/shutdown",
      "rom/help/sleep",
      "rom/help/string",
      "rom/help/table",
      "rom/help/term",
      "rom/help/textutils",
      "rom/help/time",
      "rom/help/tunnel",
      "rom/help/turn",
      "rom/help/turtle",
      "rom/help/type",
      "rom/help/unequip",
      "rom/help/vector",
      "rom/help/wget",
      "rom/help/whatsnew",
      "rom/help/window",
      "rom/help/workbench",
      "rom/help/worm",
      "rom/programs/advanced/bg",
      "rom/programs/advanced/fg",
      "rom/programs/advanced/multishell",
      "rom/programs/alias",
      "rom/programs/apis",
      "rom/programs/cd",
      "rom/programs/clear",
      "rom/programs/command/commands",
      "rom/programs/command/exec",
      "rom/programs/copy",
      "rom/programs/delete",
      "rom/programs/drive",
      "rom/programs/edit",
      "rom/programs/eject",
      "rom/programs/exit",
      "rom/programs/fun/advanced/levels/0",
      "rom/programs/fun/advanced/levels/1",
      "rom/programs/fun/advanced/levels/10",
      "rom/programs/fun/advanced/levels/11",
      "rom/programs/fun/advanced/levels/12",
      "rom/programs/fun/advanced/levels/2",
      "rom/programs/fun/advanced/levels/3",
      "rom/programs/fun/advanced/levels/4",
      "rom/programs/fun/advanced/levels/5",
      "rom/programs/fun/advanced/levels/6",
      "rom/programs/fun/advanced/levels/7",
      "rom/programs/fun/advanced/levels/8",
      "rom/programs/fun/advanced/levels/9",
      "rom/programs/fun/advanced/paint",
      "rom/programs/fun/advanced/redirection",
      "rom/programs/fun/adventure",
      "rom/programs/fun/dj",
      "rom/programs/fun/hello",
      "rom/programs/fun/worm",
      "rom/programs/gps",
      "rom/programs/help",
      "rom/programs/http/pastebin",
      "rom/programs/http/wget",
      "rom/programs/id",
      "rom/programs/label",
      "rom/programs/list",
      "rom/programs/lua",
      "rom/programs/mkdir",
      "rom/programs/monitor",
      "rom/programs/move",
      "rom/programs/peripherals",
      "rom/programs/pocket/falling",
      "rom/programs/programs",
      "rom/programs/reboot",
      "rom/programs/rednet/chat",
      "rom/programs/rednet/repeat",
      "rom/programs/redstone",
      "rom/programs/rename",
      "rom/programs/set",
      "rom/programs/shell",
      "rom/programs/shutdown",
      "rom/programs/time",
      "rom/programs/turtle/craft",
      "rom/programs/turtle/dance",
      "rom/programs/turtle/equip",
      "rom/programs/turtle/excavate",
      "rom/programs/turtle/go",
      "rom/programs/turtle/refuel",
      "rom/programs/turtle/tunnel",
      "rom/programs/turtle/turn",
      "rom/programs/turtle/unequip",
      "rom/programs/type",
      "rom/startup",
    },
    fileData = {
      "version = \"1.1\"\
----------------------------------------------------------\
--   ~\". _^_ \"~       --    KrapFile Version 1.1        --\
--   ~\" (____) \"~     --     Created by TehRockettek    --\
--   ~\"(______) \"~    --                                --\
--  \" (________) \"~   --    KrapFile is a simple file   --\
--  (____________) \"  --    managing program and is     --\
--  KRAP    SOFTWARE  --    a much more optimized       --\
-- \"Its like someone  --    version. This program will  --\
--  litteraly made    --    have much more features     --\
--  this whilst on    --    over time!                  --\
--  the toilet...  \"  --                                --\
----------------------------------------------------------\
\
-- I sometimes livestream to youtube!                            -- \
-- https://www.youtube.com/channel/UC_WsSgl1UL1USK4K0RplcnQ/live --\
\
-- Older versions of craftOS dont support the characters used in\
-- KrapFile, if this is so just run -o after the program\
\
term.clear()\
term.setCursorPos(1,1)\
\
if shell then\
    pgrm = \"/\" .. shell.getRunningProgram()\
else\
\009pgrm = \"/KrapFile.lua\"\
    printError(\"Hmm, cant find shell api.\")\
    os.pullEvent(\"key\")\
end\
\
args = { ... }\
\
if http then\
\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009if not pbl then\
\009\009printError(\"Could not connect to pastebin\")\
\009else\
\009\009latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
\009\009latestver = string.gsub(latestver,\"\\\"\",\"\")\
\009end\
end\
\
term.clear()\
terminal = term.current()\
resolution = {term.getSize()}\
dialoguevisible = false\
print(\"Debug use only\")\
if _CC_VERSION then\
    supportspecialchars = (tonumber(_CC_VERSION) >= 1.76)\
\009print(\"cc-ver: \" .. _CC_VERSION) \
end\
if _HOST then\
    supportspecialchars = (tonumber(string.sub(string.gsub(_HOST,\"ComputerCraft \",\"\"),1,string.find(string.gsub(_HOST,\"ComputerCraft \",\"\"),\" \"))) >= 1.76)\
\009print(\"host: \" .. _HOST)\
end\
if not supportspecialchars or args[1] == \"-o\" then\
    back = \"<\"\
    up = \"^\"\
\009print(\"ssc: false\")\
else\
    back = \"\017\"\
    up = \"\030\"\
\009print(\"ssc: true\")\
end\
print(\"kf-ver: \" .. version)\
print(\"pb-ver: \" .. latestver)\
print(\"rpgrm: \" .. pgrm)\
sleep(1)\
local function minBytes(bytes)\
    if bytes > 1000000 then\
        return string.sub(bytes/1000000,1,string.len(math.ceil(bytes/1000000))+2) .. \"M\"\
    elseif bytes > 1000 then\
        return string.sub(bytes/1000,1,string.len(math.ceil(bytes/1000))+2) .. \"K\"\
    else\
        return bytes .. \"B\"\
    end\
end\
\
if string.find(pgrm,\"pastebin\") then -- Detect if using pastebin run (show installer)\
\009term.clear()\
\009paintutils.drawFilledBox(1,1,resolution[1],resolution[2],colours.cyan)\
\009local pastebin = http.get(\"http://www.pastebin.com/raw/wscpHypE\")\
\009filesize = minBytes(string.len(pastebin.readAll()))\
\009term.setCursorPos(1,resolution[2])\
\009term.write(\"File size: \" ..\009filesize)\
\009term.setCursorPos((resolution[1]-9)/2,resolution[2]/2)\
\009term.write(\"Download!\")\
\009os.pullEvent(\"mouse_click\")\
\009term.clear()\
    paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
    paintutils.drawFilledBox(1,4,resolution[1],resolution[2],colours.white)\
\009term.setCursorPos(2,2)\
    term.setBackgroundColour(colours.cyan)\
    term.setTextColour(colours.white)\
    textutils.slowPrint(\"KrapFile installer\")\
    term.setTextColour(colours.cyan)\
    term.setBackgroundColour(colours.white)\
    term.setCursorPos(1,5)\
    term.write(\" Loading...\")\
    sleep(2)\
    local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
    if not pbl then\
        printError(\" Could not connect to pastebin!\")\
        print(\" Error during update!\\n Computer will now reboot...\")\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        os.reboot()\
    end\
    latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
    latestver = string.gsub(latestver,\"\\\"\",\"\")\
    pbl.close()\
    term.setCursorPos(1,5)\
    print(\" Latest version: \" .. latestver .. \"\\n Download? (Y/N)\")\
    term.setCursorPos(2,10)\
    local _,id = os.pullEvent(\"key\")\
    if id == 21 then\
        print(\"\\n Downloading...\")\
        term.setCursorPos(1,12)\
        term.write(\" Connecting to pastebin...\")\
        local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
        if pbl then\
            print(\" Success\")\
        else\
            printError(\" Failed\")\
            print(\" Error during update!\\n Computer will reboot...\")\
            textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
            os.reboot()\
        end\
        print(\" Saving to file...\")\
        if fs.exists(\"KrapFile\") then fs.delete(\"/KrapFile\") end\
        krapfile = fs.open(\"/KrapFile\",\"w\")\
        krapfile.write(pbl.readAll())\
        print(\" Finished! Downloaded \" .. latestver .. \"\\n\\n Computer will reboot...\")\
        term.setCursorPos(2,resolution[2])\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        os.reboot()\
    else\
        print(\"Returing to Shell...\")\
        term.setCursorPos(2,resolution[2])\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        term.clear()\
\009\009textutils.setTextColour(colours.white)\
\009\009textutils.setBackgroundColour(colours.black)\
        term.setCursorPos(1,1)\
        shell.run(\"shell\")\
    end\
end\
\
if resolution[1] < 26 or resolution[2] < 5 then\
\009printError(\"Sorry! Your computer must be atleast 26x5 to run this! (\" .. resolution[1] .. \"x\" .. resolution[2] .. \")\")\
\009return\
elseif not colors then\
\009printError(\"Sorry! Your computer doesn't seem to support colour. Monochrome support for KrapFile will be released shortly\")\
\009return\
end\
\
paintutils.drawFilledBox(1,1,resolution[1],resolution[2],colours.cyan)\
term.setCursorPos((resolution[1]-string.len(\"KrapFile\"))/2,(resolution[2]/5)*2)\
term.write(\"KrapFile\")\
term.setCursorPos(1,resolution[2])\
term.write(version)\
term.setCursorPos(resolution[1]-string.len(\"By TehRockettek\")+1,resolution[2])\
\
term.write(\"By TehRockettek\")\
local comments = {\"To continue, enter your SS Number:\",\"Piorjade liking pie is a conspiracy\",\"Enter your credit card details\",\"Free one-time payment of Â£499\",\"Now with more loading time!\",\"May include nuts\",\"Attempt to index nil\",\"Now in 1080p!\",\"I got molested by a toaster\",\"I am bender, insert girder\",\"May include bugs\",\"This litteraly took 12 hours to make\",\"Im not joking\",\"You pirated free software!\",\"Child Lock is enabled\",\"Have you tried a gun? I have\",\"Screw switchcraft,i want my plot back\",\"Sample comment\",\"Wow, thats so racist\",\"file.flushDownToilet()\",\"I cunt speel properply\",\"What's the wecommended amount of dedotated wam\",\"Subscribe to my YT: Teh Rockettek\",\"Try doing 5x26, It works!\",\"If stuff is showing as ?, run with -o\",\"I have a fetish for keemstar's beard\",\"I play pokemon go\",\"Redirection is a good game\",\"Dan200, more like err... dan smelly hundred\",\"*Air horns*\",\"~You hear the windows xp startup noise~\"}\
local fits = {}\
for i=1,#comments,1 do\
    if #comments[i] <= resolution[1] then\
        table.insert(fits,comments[i])\
    end\
end\
if resolution[2] < 10 then\
\009fits = {\"This is small!\"}\
end\
local num = math.random(1,#fits)\
term.setCursorPos((resolution[1]-string.len(fits[num]))/2,(resolution[2]/5)*4)\
term.write(fits[num])\
\
sleep(2)\
term.clear()\
\
local windows = {}\
windows.HUD = window.create(terminal,1,1,resolution[1],3)\
windows.FILES = window.create(terminal,1,4,resolution[1]-1,resolution[2]-4)\
windows.SCROLLBAR = window.create(terminal,resolution[1],4,resolution[1],resolution[2]-4)\
windows.BOTTOM = window.create(terminal,1,resolution[2],resolution[1],1)\
windows.EXTRA = window.create(terminal,1,1,1,1,false)\
\
path = \"/\"\
offset = 0\
\
local function cut(text,length)\
    if string.len(text) > length then\
        return string.sub(text,1,length)\
    else\
        return text\
    end\
end\
\
local function getSize(path)\
    local size = fs.getSize(path)\
    if fs.isDir(path) then\
        local l = fs.list(path)\
        for i = 1, #l do\
            size = size + getSize(fs.combine(path, l[i]))\
        end\
    end\
    return size\
end\
\
local function getName(path)\
    num = -1\
    while not string.find(path,\"/\",num) do\
        num = num - 1\
    end\
    return string.sub(path,string.find(path,\"/\",num)+1,#path)\
end\
\
local function loadHUD()\
    term.redirect(windows.HUD)\
    paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
    term.setBackgroundColour(colours.cyan)\
    if path == \"\" or not path then path = \"/\" end\
    term.setTextColour(colours.white)\
    term.setCursorPos(2,2)\
    term.write(back)\
    if offset < 0 then offset = 0 end\
    term.setTextColour(colours.white)\
    term.setCursorPos(5,2)\
    term.write(up)\
    term.setCursorPos(8,2)\
    term.setTextColour(colours.white)\
    term.write(cut(path,resolution[1]-8))\
    term.redirect(terminal)\
end\
\
local function loadDETAILS(path)\
    fileList = fs.list(path)\
    folderSize = 0\
    filesinfolder = 0\
    foldersinfolder = 0\
    for i=1,#fileList,1 do\
        local filePath = \"/\" .. fs.combine(path,fileList[i])\
        if fs.isDir(filePath) then foldersinfolder = foldersinfolder + 1 else filesinfolder = filesinfolder + 1 end\
        folderSize = folderSize + getSize(filePath)\
    end\
end\
\
\
local function loadFILES()\
    loadDETAILS(path)\
    term.redirect(windows.FILES)\
    paintutils.drawFilledBox(1,1,resolution[1]-1,resolution[2]-4,colours.white)\
    fileList = fs.list(path)\
    containerWidth,containerHeight = term.getSize()    \
    if #fileList-offset == containerHeight then\
        for i=1,containerHeight,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i+offset])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
            elseif (\"/\" .. fileList[i+offset] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
\009\009\009end\
            term.write(cut(fileList[i+offset],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i+offset],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    elseif #fileList < containerHeight then\
        for i=1,#fileList,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
\009\009\009elseif (\"/\" .. fileList[i] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
            end\
            term.write(cut(fileList[i],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    else\
        for i=1,containerHeight,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i+offset])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
            elseif (\"/\" .. fileList[i+offset] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
            end\
            term.write(cut(fileList[i+offset],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i+offset],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    end\
    term.redirect(terminal)\
end\
\
local function loadBAR()\
    term.redirect(windows.SCROLLBAR)\
    local _,containerHeightb = term.getSize()\
    if #fileList <= containerHeight then\
        paintutils.drawFilledBox(1,1,1,containerHeightb,colours.grey)\
    else\
        paintutils.drawFilledBox(1,1,1,containerHeightb,colours.lightGrey)\
    end\
    barryscott = (containerHeightb/100) * ((offset/(#fileList - containerHeight))*100)\
    if barryscott < 1 then \
        barryscott = 1\
    end\
\009if offset == 0 then\
\009\009barryscott = 1\
\009end\
    paintutils.drawFilledBox(1,barryscott,1,barryscott,colours.grey)\
    term.redirect(terminal)\
end\
\
local function loadBOTTOM()\
    if not dialoguevisible then\
        term.redirect(windows.BOTTOM)\
        term.setBackgroundColour(colours.lightGrey)\
        term.setTextColour(colours.grey)\
        term.clearLine()\
        term.setCursorPos(1,1)\
        local info = filesinfolder .. \" files \" .. foldersinfolder .. \" folders\"\
        local posstats = offset .. \"/\" .. #fileList\
        bottombar = info .. string.rep(\" \",resolution[1]-string.len(info)-string.len(posstats)) .. posstats\
        term.write(bottombar)\
        term.redirect(terminal)\
    end\
end\
\
local function loadALL()\
    dialoguevisible = false\
    loadHUD()\
    loadFILES()\
    loadBAR()\
    loadBOTTOM()\
end\
\
local function loadDIALOGUE(text)\
    term.redirect(windows.BOTTOM)\
    term.setBackgroundColour(colours.lightGrey)\
    term.setTextColour(colours.grey)\
    term.clearLine()\
    term.setCursorPos(1,1)\
    term.write(text)\
    term.redirect(terminal)\
end\
-- INIT\
\
loadALL()\
\
-- Hint: Pretty much screwing arround with anything below will pretty much completely break the gui part of it ;) \
--       But to be honest, you shouldnt be screwing arround with the entire program at all...\
\
-- key,id,false\
-- key_up,id\
-- mouse_click,left(1)/right(2),X,Y\
-- mouse_scroll,down(-1)/up(1),X,Y\
\
os.pullEvent = os.pullEventRaw -- Just so i can say thanks for using it ;)\
while true do\
    if not fs.exists(path) then\
        path = \"/\"\
    end\
    local a,b,c,d = os.pullEvent()\
    if a == \"mouse_up\" then\
        if b == 1 then -- left\
            if c < 4 and d < 4 then\
                if path ~= \"/\" then\
                    path = \"/\" .. fs.combine(path,\"..\")\
                    offset = 0\
                    loadALL()\
                end\
            elseif c > 3 and c < 7 and d < 4 then\
                if offset > 0 then\
                    offset = 0\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBAR()\
                    loadFILES()\
                    loadBOTTOM()\
                end\
            elseif dialoguevisible and d == resolution[2] then\
                if c >= 1 and c <= 7 then\
                    finished = false\
                    while finished == false do\
                        if selectedfileDir == pgrm then\
                            term.clear()\
                            paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
                            paintutils.drawFilledBox(1,4,resolution[1],resolution[2],colours.white)\
                            term.redirect(terminal)\
                            term.setCursorPos(2,2)\
                            term.setBackgroundColour(colours.cyan)\
                            term.setTextColour(colours.white)\
                            textutils.slowPrint(\"KrapFile updater\")\
                            term.setTextColour(colours.cyan)\
                            term.setBackgroundColour(colours.white)\
                            term.setCursorPos(1,5)\
                            term.write(\" Loading...\")\
    \009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009\009\009\009\009\009\009if not pbl then\
\009\009\009\009\009\009\009\009printError(\" Could not connect to pastebin!\")\
\009\009\009\009\009\009\009\009print(\" Error during update!\\n Computer will now reboot...\")\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
\009\009\009\009\009\009\009latestver = string.gsub(latestver,\"\\\"\",\"\")\
\009\009\009\009\009\009\009pbl.close()\
\009\009\009\009\009\009\009term.setCursorPos(1,5)\
\009\009\009\009\009\009\009print(\" My version: \" .. version)\
\009\009\009\009\009\009\009print(\" New version: \" .. latestver .. \"\\n Update? (Y/N)\")\
\009\009\009\009\009\009\009term.setCursorPos(2,10)\
\009\009\009\009\009\009\009_,id = os.pullEvent(\"key\")\
\009\009\009\009\009\009\009if id == 21 then\
\009\009\009\009\009\009\009\009if version == latestver then\
\009\009\009\009\009\009\009\009\009print(\"\\n Redownloading...\")\
\009\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009\009print(\"\\n Downloading...\")\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009sleep(3)\
                            \009term.setCursorPos(1,12)\
\009\009\009\009\009\009\009\009term.write(\" Connecting to pastebin...\")\
\009\009\009\009\009\009\009\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009\009\009\009\009\009\009\009if pbl then\
\009\009\009\009\009\009\009\009\009print(\" Success\")\
\009\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009\009printError(\" Failed\")\
\009\009\009\009\009\009\009\009\009print(\" Error during update!\\n Computer will reboot...\")\
\009\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009print(\" Saving to file...\")\
                            \009krapfile = fs.open(pgrm,\"w\")\
\009\009\009\009\009\009\009\009krapfile.write(pbl.readAll())\
\009\009\009\009\009\009\009\009print(\" Finished!\\n \" .. version .. \" => \" .. latestver .. \"\\n\\n Computer will reboot...\")\
                            \009term.setCursorPos(2,resolution[2])\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009print(\"Returing to KrapFile...\")\
\009\009\009\009\009\009\009\009term.setCursorPos(2,resolution[2])\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
                            end\
\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009editname = \"\"\
                        else\
\009\009\009\009\009\009\009loadDIALOGUE(\"Rename to: \")\
\009\009\009\009\009\009\009term.redirect(windows.BOTTOM)\
\009\009\009\009\009\009\009term.setCursorPos(12,1)\
\009\009\009\009\009\009\009editname = io.read()\
\009\009\009\009\009\009\009if fs.isReadOnly(selectedfileDir) then\
\009\009\009\009\009\009\009\009loadDIALOGUE(\"File is read-only!\")\
\009\009\009\009\009\009\009\009editname = \"\"\
\009\009\009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009elseif not fs.exists(fs.combine(selectedfileDir,\"..\")..\"/\"..editname) or editname == \"\" then\
\009\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009loadDIALOGUE(\"File already exists!\")\
\009\009\009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        if fs.move(selectedfileDir,fs.combine(selectedfileDir,\"..\")..\"/\"..editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 8 and c <= 14 then\
                    finished = false\
                    while finished == false do\
                        loadDIALOGUE(\"Copy to: \")\
                        term.redirect(windows.BOTTOM)\
                        term.setCursorPos(10,1)\
                        editname = io.read()\
                        if fs.isReadOnly(editname) then\
                            loadDIALOGUE(\"Directory is read-only!\")\
                            sleep(2)\
                        elseif not fs.exists(editname) or editname == \"\" then\
                            finished = true\
                        else\
                            loadDIALOGUE(\"File already exists!\")\
                            sleep(2)\
                        end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        fs.copy(selectedfileDir,editname)\
                        if not fs.exists(editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 15 and c <= 17 then\
                    finished = false\
                    while finished == false do\
                        loadDIALOGUE(\"Move to: \")\
                        term.redirect(windows.BOTTOM)\
                        term.setCursorPos(12,1)\
                        editname = io.read()\
                        if fs.isReadOnly(selectedfileDir) then\
                            loadDIALOGUE(\"File is read-only!\")\
                            editname = \"\"\
                            sleep(2)\
                            finished = true\
                        elseif fs.isReadOnly(editname) then\
                            loadDIALOGUE(\"Directory is read-only!\")\
                            sleep(2)\
                        elseif not fs.exists(editname) or editname == \"\" then\
                            finished = true\
                        else\
                            loadDIALOGUE(\"File already exists!\")\
                            sleep(2)\
                        end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        if fs.move(selectedfileDir,editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 18 and c <= 26 then\
                    if selectedfileDir == pgrm then\
                        loadDIALOGUE(\"Nope...\")\
                        sleep(2)\
                        finished = true\
                        key = 1\
                    end\
                    finished = false\
                    loadDIALOGUE(\"Are you sure? (Y/N)\")\
                    if fs.isReadOnly(selectedfileDir) then\
                        finished = true\
                        loadDIALOGUE(\"File is read-only!\")\
                        sleep(2)\
                    end\
                    while finished == false do\
                        _,id = os.pullEvent(\"key\")\
                        if id then\
                            finished = true\
                        end\
                    end\
                    if id == 21 and not fs.isReadOnly(selectedfileDir) then\
                        loadDIALOGUE(\"Working...\")\
                        fs.delete(selectedfileDir)\
                        if fs.exists(selectedfileDir) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBOTTOM()\
                    loadFILES()\
                end\
            elseif c < resolution[1] - 1 and d > 3 and d < resolution[2] then\
                if fileList[d - 3 + offset] then\
                    selectedfileDir = \"/\" .. fs.combine(path,fileList[d - 3 + offset])\
                    if fs.isDir(selectedfileDir) then\
                        path = selectedfileDir\
                        offset = 0\
                        loadALL()\
                    elseif selectedfileDir ~= selectedfileDir then\
                        dialoguevisible = false\
                        windows.FILES.redraw()\
                        loadBOTTOM()\
                    end\
                elseif dialoguevisible then\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBOTTOM()\
                end\
            end\
        elseif b == 2 then -- right\
            if c < resolution[1] - 1 and d > 3 and d < resolution[2] then\
                if fileList[d - 3 + offset] then\
                    windows.FILES.redraw()\
                    term.setBackgroundColour(colours.white)\
                    term.setCursorPos(3,d)\
                    term.setTextColour(colours.blue)\
                    term.write(fileList[d-3+offset])\
                    selectedfileDir = \"/\" .. fs.combine(path,fileList[d - 3 + offset])\
                    dialoguevisible = true\
                    local filepercentage = string.sub(tostring((getSize(selectedfileDir)/getSize(\"/\"))*100),1,string.len(math.ceil((getSize(selectedfileDir)/getSize(\"/\"))*100))+2)\
                    if selectedfileDir == pgrm then\
                        loadDIALOGUE(\"Update  Copy  Move  Delete\".. string.rep(\" \",resolution[1]-27-#filepercentage) .. filepercentage .. \"%\")\
                    else\
                        loadDIALOGUE(\"Rename  Copy  Move  Delete\".. string.rep(\" \",resolution[1]-27-#filepercentage) .. filepercentage .. \"%\")\
                    end\
                end\
            end\
        end\
    elseif a == \"mouse_scroll\" then\
        if b == -1 then -- down\
            if offset + containerHeight < #fileList then\
                offset = offset + 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        elseif b == 1 then -- up\
            if offset > 0 then\
                offset = offset - 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        end\
    elseif a == \"key\" then\
        if b == 208 then -- down\
            if offset + containerHeight < #fileList then\
                offset = offset + 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        elseif b == 200 then -- up\
            if offset > 0 then\
                offset = offset - 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        end\
    elseif a == \"terminate\" then\
        term.setCursorPos(1,1)\
        term.setTextColour(colours.white)\
        term.setBackgroundColour(colours.black)\
        term.clear()\
        print(\"Thank you for using KrapFile!\\n Please go onto the forums to post any bugs or issues that occured.\\nAnd thank you for supporting us!\")\
        return\
    end\
    loadBOTTOM()\
end",
      "for k, v in ipairs(fs.list(\"/rom/apis/\")) do\
\009if not fs.isDir(\"/rom/apis/\"..v) then\
\009\009print(\"loading: /rom/apis/\"..v)\
\009\009os.loadAPI(\"/rom/apis/\"..v)\
\009end\
end\
\
_G.colours = _G.colors",
      "-- Colors\
white = 1\
orange = 2\
magenta = 4\
lightBlue = 8\
yellow = 16\
lime = 32\
pink = 64\
gray = 128\
lightGray = 256\
cyan = 512\
purple = 1024\
blue = 2048\
brown = 4096\
green = 8192\
red = 16384\
black = 32768\
\
function combine( ... )\
    local r = 0\
    for n,c in ipairs( { ... } ) do\
        r = bit32.bor(r,c)\
    end\
    return r\
end\
\
function subtract( colors, ... )\
\009local r = colors\
\009for n,c in ipairs( { ... } ) do\
\009\009r = bit32.band(r, bit32.bnot(c))\
\009end\
\009return r\
end\
\
function test( colors, color )\
    return ((bit32.band(colors, color)) == color)\
end",
      "-- Colours (for lovers of british spelling)\
local colours = _ENV\
for k,v in pairs(colors) do\
\009colours[k] = v\
end\
\
colours.grey = colors.gray\
colours.gray = nil\
\
colours.lightGrey = colors.lightGray\
colours.lightGray = nil",
      "\
if not commands then\
\009error( \"Cannot load command API on normal computer\", 2 )\
end\
native = commands.native or commands\
\
local function collapseArgs( errorDepth, bJSONIsNBT, arg1, ... )\
    if arg1 ~= nil then\
        if type(arg1) == \"boolean\" or type(arg1) == \"number\" or type(arg1) == \"string\" then\
            return tostring(arg1) .. \" \" .. collapseArgs( errorDepth + 1, bJSONIsNBT, ... )\
        elseif type(arg1) == \"table\" then\
            return textutils.serialiseJSON( arg1, bJSONIsNBT ) .. \" \" .. collapseArgs( errorDepth + 1, bJSONIsNBT, ... )\
        else\
            error( \"Expected string, number, boolean or table\", errorDepth )\
        end\
    end\
    return \"\"\
end\
\
-- Put native functions into the environment\
local env = _ENV\
for k,v in pairs( native ) do\
    env[k] = v\
end\
\
-- Create wrapper functions for all the commands\
local tAsync = {}\
local tNonNBTJSONCommands = {\
    [ \"tellraw\" ] = true,\
    [ \"title\" ] = true\
}\
local tCommands = native.list()\
for n,sCommandName in ipairs(tCommands) do\
    if env[ sCommandName ] == nil then\
        local bJSONIsNBT = (tNonNBTJSONCommands[ sCommandName ] == nil)\
        env[ sCommandName ] = function( ... )\
            local sCommand = sCommandName .. \" \" .. collapseArgs( 3, bJSONIsNBT, ... )\
            return native.exec( sCommand )\
        end\
        tAsync[ sCommandName ] = function( ... )\
            local sCommand = sCommandName .. \" \" .. collapseArgs( 3, bJSONIsNBT, ... )\
            return native.execAsync( sCommand )\
        end\
    end\
end\
env.async = tAsync",
      "\
local function isDrive( name )\
\009return peripheral.getType( name ) == \"drive\"\
end\
\
function isPresent( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"isDiskPresent\" )\
\009end\
\009return false\
end\
\
function getLabel( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getDiskLabel\" )\
\009end\
\009return nil\
end\
\
function setLabel( name, label )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"setDiskLabel\", label )\
\009end\
end\
\
function hasData( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"hasData\" )\
\009end\
\009return false\
end\
\
function getMountPath( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getMountPath\" )\
\009end\
\009return nil\
end\
\
function hasAudio( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"hasAudio\" )\
\009end\
\009return false\
end\
\
function getAudioTitle( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getAudioTitle\" )\
\009end\
\009return nil\
end\
\
function playAudio( name )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"playAudio\" )\
\009end\
end\
\
function stopAudio( name )\
\009if not name then\
\009\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009\009stopAudio( sName )\
\009\009end\
\009else\
\009\009if isDrive( name ) then\
\009\009\009peripheral.call( name, \"stopAudio\" )\
\009\009end\
\009end\
end\
\
function eject( name )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"ejectDisk\" )\
\009end\
end\
\
function getID( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getDiskID\" )\
\009end\
\009return nil\
end",
      "\
CHANNEL_GPS = 65534\
\
local function trilaterate( A, B, C )\
\009local a2b = B.vPosition - A.vPosition\
\009local a2c = C.vPosition - A.vPosition\
\009\009\
\009if math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then\
\009\009return nil\
\009end\
\009\
\009local d = a2b:length()\
\009local ex = a2b:normalize( )\
\009local i = ex:dot( a2c )\
\009local ey = (a2c - (ex * i)):normalize()\
\009local j = ey:dot( a2c )\
\009local ez = ex:cross( ey )\
\
\009local r1 = A.nDistance\
\009local r2 = B.nDistance\
\009local r3 = C.nDistance\
\009\009\
\009local x = (r1*r1 - r2*r2 + d*d) / (2*d)\
\009local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)\
\009\009\
\009local result = A.vPosition + (ex * x) + (ey * y)\
\
\009local zSquared = r1*r1 - x*x - y*y\
\009if zSquared > 0 then\
\009\009local z = math.sqrt( zSquared )\
\009\009local result1 = result + (ez * z)\
\009\009local result2 = result - (ez * z)\
\009\009\
\009\009local rounded1, rounded2 = result1:round( 0.01 ), result2:round( 0.01 )\
\009\009if rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then\
\009\009\009return rounded1, rounded2\
\009\009else\
\009\009\009return rounded1\
\009\009end\
\009end\
\009return result:round( 0.01 )\
\009\
end\
\
local function narrow( p1, p2, fix )\
\009local dist1 = math.abs( (p1 - fix.vPosition):length() - fix.nDistance )\
\009local dist2 = math.abs( (p2 - fix.vPosition):length() - fix.nDistance )\
\009\
\009if math.abs(dist1 - dist2) < 0.01 then\
\009\009return p1, p2\
\009elseif dist1 < dist2 then\
\009\009return p1:round( 0.01 )\
\009else\
\009\009return p2:round( 0.01 )\
\009end\
end\
\
function locate( _nTimeout, _bDebug )\
    -- Let command computers use their magic fourth-wall-breaking special abilities\
    if commands then\
        return commands.getBlockPosition()\
    end\
\
\009-- Find a modem\
\009local sModemSide = nil\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\009\
\009\009\009sModemSide = sSide\
\009\009\009break\
\009\009end\
\009end\
\
\009if sModemSide == nil then\
\009\009if _bDebug then\
\009\009\009print( \"No wireless modem attached\" )\
\009\009end\
\009\009return nil\
\009end\
\009\
\009if _bDebug then\
\009\009print( \"Finding position...\" )\
\009end\
\009\
\009-- Open a channel\
\009local modem = peripheral.wrap( sModemSide )\
\009local bCloseChannel = false\
\009if not modem.isOpen( os.getComputerID() ) then\
\009\009modem.open( os.getComputerID() )\
\009\009bCloseChannel = true\
\009end\
\009\
\009-- Send a ping to listening GPS hosts\
\009modem.transmit( CHANNEL_GPS, os.getComputerID(), \"PING\" )\
\009\009\
\009-- Wait for the responses\
\009local tFixes = {}\
\009local pos1, pos2 = nil, nil\
\009local timeout = os.startTimer( _nTimeout or 2 )\
\009while true do\
\009\009local e, p1, p2, p3, p4, p5 = os.pullEvent()\
\009\009if e == \"modem_message\" then\
\009\009\009-- We received a reply from a modem\
\009\009\009local sSide, sChannel, sReplyChannel, tMessage, nDistance = p1, p2, p3, p4, p5\
\009\009\009if sSide == sModemSide and sChannel == os.getComputerID() and sReplyChannel == CHANNEL_GPS and nDistance then\
\009\009\009\009-- Received the correct message from the correct modem: use it to determine position\
\009\009\009\009if type(tMessage) == \"table\" and #tMessage == 3 then\
\009\009\009\009\009local tFix = { vPosition = vector.new( tMessage[1], tMessage[2], tMessage[3] ), nDistance = nDistance }\
\009\009\009\009\009if _bDebug then\
\009\009\009\009\009\009print( tFix.nDistance..\" metres from \"..tostring( tFix.vPosition ) )\
\009\009\009\009\009end\
\009\009\009\009\009if tFix.nDistance == 0 then\
\009\009\009\009\009    pos1, pos2 = tFix.vPosition, nil\
\009\009\009\009\009else\
                        table.insert( tFixes, tFix )\
                        if #tFixes >= 3 then\
                            if not pos1 then\
                                pos1, pos2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )\
                            else\
                                pos1, pos2 = narrow( pos1, pos2, tFixes[#tFixes] )\
                            end\
                        end\
                    end\
\009\009\009\009\009if pos1 and not pos2 then\
\009\009\009\009\009\009break\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009elseif e == \"timer\" then\
\009\009\009-- We received a timeout\
\009\009\009local timer = p1\
\009\009\009if timer == timeout then\
\009\009\009\009break\
\009\009\009end\
\009\009\
\009\009end \
\009end\
\009\
\009-- Close the channel, if we opened one\
\009if bCloseChannel then\
\009\009modem.close( os.getComputerID() )\
\009end\
\009\
\009-- Return the response\
\009if pos1 and pos2 then\
\009\009if _bDebug then\
\009\009\009print( \"Ambiguous position\" )\
\009\009\009print( \"Could be \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z..\" or \"..pos2.x..\",\"..pos2.y..\",\"..pos2.z )\
\009\009end\
\009\009return nil\
\009elseif pos1 then\
\009\009if _bDebug then\
\009\009\009print( \"Position is \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z )\
\009\009end\
\009\009return pos1.x, pos1.y, pos1.z\
\009else\
\009\009if _bDebug then\
\009\009\009print( \"Could not determine position\" )\
\009\009end\
\009\009return nil\
\009end\
end",
      "\
local sPath = \"/rom/help\"\
\
function path()\
\009return sPath\
end\
\
function setPath( _sPath )\
\009sPath = _sPath\
end\
\
function lookup( _sTopic )\
 \009-- Look on the path variable\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = fs.combine( sPath, _sTopic )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
    end\
\009\
\009-- Not found\
\009return nil\
end\
\
function topics()\
    -- Add index\
\009local tItems = {\
\009    [ \"index\" ] = true\
\009}\
\009\
\009-- Add topics from the path\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
\009\009if fs.isDir( sPath ) then\
\009\009\009local tList = fs.list( sPath )\
\009\009\009for n,sFile in pairs( tList ) do\
\009\009\009\009if string.sub( sFile, 1, 1 ) ~= \".\" then\
\009\009\009\009\009if not fs.isDir( fs.combine( sPath, sFile ) ) then\
\009\009\009\009\009\009tItems[ sFile ] = true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    end\009\
\
\009-- Sort and return\
\009local tItemList = {}\
\009for sItem, b in pairs( tItems ) do\
\009\009table.insert( tItemList, sItem )\
\009end\
\009table.sort( tItemList )\
\009return tItemList\
end\
\
function completeTopic( sText )\
    local tTopics = topics()\
    local tResults = {}\
    for n=1,#tTopics do\
        local sTopic = tTopics[n]\
        if #sTopic > #sText and string.sub( sTopic, 1, #sText ) == sText then\
            table.insert( tResults, string.sub( sTopic, #sText + 1 ) )\
        end\
    end\
\009return tResults\
end",
      "-- Definition for the IO API\
\
local g_defaultInput = {\
\009bFileHandle = true,\
\009bClosed = false,\
\009close = function( self )\
\009end,\
\009read = function( self, _sFormat )\
\009\009if _sFormat and _sFormat ~= \"*l\" then\
\009\009\009error( \"Unsupported format\" )\
\009\009end\
\009\009return _G.read()\
\009end,\
\009lines = function( self )\
\009\009return function()\
\009\009\009return _G.read()\
\009\009end\
\009end,\
}\
\
local g_defaultOutput = {\
\009bFileHandle = true,\
\009bClosed = false,\
\009close = function( self )\
\009end,\
\009write = function( self, _sText )\
\009\009_G.write( _sText )\
\009end,\
\009flush = function( self )\
\009end,\
}\
\
local g_currentInput = g_defaultInput\
local g_currentOutput = g_defaultOutput\
\
function close( _file )\
\009(_file or g_currentOutput):close()\
end\
\
function flush()\
\009g_currentOutput:flush()\
end\
\
function input( _arg )\
\009if _G.type( _arg ) == \"string\" then\
\009\009g_currentInput = open( _arg, \"r\" )\
\009elseif _G.type( _arg ) == \"table\" then\
\009\009g_currentInput = _arg\
\009elseif _G.type( _arg ) == \"nil\" then\
\009\009return g_currentInput\
\009else\
\009\009error( \"Expected file name or file handle\" )\
\009end\
end\
\
function lines( _sFileName )\
\009if _sFileName then\
\009\009return open( _sFileName, \"r\" ):lines()\
\009else\
\009\009return g_currentInput:lines()\
\009end\
end\
\
function open( _sPath, _sMode )\
\009local sMode = _sMode or \"r\"\
\009local file = fs.open( _sPath, sMode )\
\009if not file then\
\009\009return nil\
\009end\
\009\
\009if sMode == \"r\"then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009read = function( self, _sFormat )\
\009\009\009\009local sFormat = _sFormat or \"*l\"\
\009\009\009\009if sFormat == \"*l\" then\
\009\009\009\009\009return file.readLine()\
\009\009\009\009elseif sFormat == \"*a\" then\
\009\009\009\009\009return file.readAll()\
\009\009\009\009else\
\009\009\009\009\009error( \"Unsupported format\" )\
\009\009\009\009end\
\009\009\009\009return nil\
\009\009\009end,\
\009\009\009lines = function( self )\
\009\009\009\009return function()\
\009\009\009\009\009local sLine = file.readLine()\
\009\009\009\009\009if sLine == nil then\
\009\009\009\009\009\009file.close()\
\009\009\009\009\009\009self.bClosed = true\
\009\009\009\009\009end\
\009\009\009\009\009return sLine\
\009\009\009\009end\
\009\009\009end,\
\009\009}\
\009elseif sMode == \"w\" or sMode == \"a\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009write = function( self, _sText )\
\009\009\009\009file.write( _sText )\
\009\009\009end,\
\009\009\009flush = function( self )\
\009\009\009\009file.flush()\
\009\009\009end,\
\009\009}\
\009\
\009elseif sMode == \"rb\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009read = function( self )\
\009\009\009\009return file.read()\
\009\009\009end,\
\009\009}\
\009\009\
\009elseif sMode == \"wb\" or sMode == \"ab\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009write = function( self, _number )\
\009\009\009\009file.write( _number )\
\009\009\009end,\
\009\009\009flush = function( self )\
\009\009\009\009file.flush()\
\009\009\009end,\
\009\009}\
\009\
\009else\
\009\009file.close()\
\009\009error( \"Unsupported mode\" )\
\009\009\
\009end\
end\
\
function output( _arg )\
\009if _G.type( _arg ) == \"string\" then\
\009\009g_currentOutput = open( _arg, \"w\" )\
\009elseif _G.type( _arg ) == \"table\" then\
\009\009g_currentOutput = _arg\
\009elseif _G.type( _arg ) == \"nil\" then\
\009\009return g_currentOutput\
\009else\
\009\009error( \"Expected file name or file handle\" )\
\009end\
end\
\
function read( ... )\
\009return input():read( ... )\
end\
\
function type( _handle )\
\009if _G.type( _handle ) == \"table\" and _handle.bFileHandle == true then\
\009\009if _handle.bClosed then\
\009\009\009return \"closed file\"\
\009\009else\
\009\009\009return \"file\"\
\009\009end\
\009end\
\009return nil\
end\
\
function write( ... )\
\009return output():write( ... )\
end",
      "\
-- Minecraft key code bindings\
-- See http://www.minecraftwiki.net/wiki/Key_codes for more info\
\
local tKeys = {\
\009nil,\009 \009\"one\", \009\009\"two\", \009\009\"three\", \009\"four\",\009\009\009-- 1\
\009\"five\", \009\"six\", \009\009\"seven\", \009\"eight\", \009\"nine\",\009\009\009-- 6\
\009\"zero\", \009\"minus\", \009\"equals\", \009\"backspace\",\"tab\",\009\009\009-- 11\
\009\"q\", \009\009\"w\", \009\009\"e\", \009\009\"r\",\009\009\"t\",\009\009\009-- 16\
\009\"y\",\009\009\"u\",\009\009\"i\",\009\009\"o\",\009\009\"p\",\009\009\009-- 21\
\009\"leftBracket\",\"rightBracket\",\"enter\",\"leftCtrl\",\"a\",\009\009\009-- 26\
\009\"s\",\009\009\"d\",\009\009\"f\",\009\009\"g\",\009\009\"h\",\009\009\009-- 31\
\009\"j\",\009\009\"k\",\009\009\"l\",\009\009\"semiColon\",\"apostrophe\",\009-- 36\
\009\"grave\",\009\"leftShift\",\"backslash\",\"z\",\009\009\"x\",\009\009\009-- 41\
\009\"c\",\009\009\"v\",\009\009\"b\",\009\009\"n\",\009\009\"m\",\009\009\009-- 46\
\009\"comma\",\009\"period\",\009\"slash\",\009\"rightShift\",\"multiply\",\009-- 51\
\009\"leftAlt\",\009\"space\",\009\"capsLock\",\009\"f1\",\009\009\"f2\",\009\009\009-- 56\
\009\"f3\",\009\009\"f4\",\009\009\"f5\",\009\009\"f6\",\009\009\"f7\",\009\009\009-- 61\
\009\"f8\",\009\009\"f9\",\009\009\"f10\",\009\009\"numLock\",\009\"scollLock\",\009-- 66\009\
\009\"numPad7\",\009\"numPad8\",\009\"numPad9\",\009\"numPadSubtract\",\"numPad4\",\009-- 71\
\009\"numPad5\",\009\"numPad6\",\009\"numPadAdd\",\"numPad1\",\009\"numPad2\",\009\009-- 76\
\009\"numPad3\",\009\"numPad0\",\009\"numPadDecimal\",nil,\009nil,\009\009\009-- 81\
\009nil,\009 \009\"f11\",\009\009\"f12\",\009\009nil,\009\009nil,\009\009\009-- 86\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 91\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\"f13\",\009\009\009-- 96\
\009\"f14\",\009\009\"f15\",\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 101\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 106\
\009nil,\009\009\"kana\",\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 111\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 116\009\
\009\"convert\",\009nil,\009\009\"noconvert\",nil,\009\009\"yen\",\009\009\009-- 121\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 126\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 131\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 136\
\009\"numPadEquals\",nil,\009\009nil,\009\009\"cimcumflex\",\"at\",\009\009\009-- 141\
\009\"colon\",\009\"underscore\",\"kanji\",\009\"stop\",\009\009\"ax\",\009\009\009-- 146\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 151\
\009\"numPadEnter\",\"rightCtrl\",nil,      nil,\009\009nil,\009\009\009-- 156\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 161\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 166\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 171\
\009nil,\009\009nil,\009\009nil,\009\009\"numPadComma\",nil,\009\009\009-- 176\
\009\"numPadDivide\",nil,\009\009nil,\009\009\"rightAlt\",\009nil,\009\009\009-- 181\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 186\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 191\
\009nil,\009\009\"pause\",\009nil,\009\009\"home\",\009\009\"up\",\009\009\009-- 196\
\009\"pageUp\",\009nil,\009\009\"left\",\009\009nil,\009\009\"right\",\009\009-- 201\
\009nil,\009\009\"end\",\009\009\"down\",\009\009\"pageDown\",\009\"insert\",\009\009-- 206\
\009\"delete\"\009\009\009\009\009\009\009\009\009\009\009\009\009\009-- 211\
}\
\
local keys = _ENV\
for nKey, sKey in pairs( tKeys ) do\
\009keys[sKey] = nKey\
end\
keys[\"return\"] = keys.enter\
\
function getName( _nKey )\
\009return tKeys[ _nKey ]\
end",
      "\
local function drawPixelInternal( xPos, yPos )\
    term.setCursorPos( xPos, yPos )\
    term.write(\" \")\
end\
\
local tColourLookup = {}\
for n=1,16 do\
    tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\
end\
\
function loadImage( sPath )\
    if type( sPath ) ~= \"string\" then\
        error( \"Expected path\", 2 )\
    end\
\
    local tImage = {}\
    if fs.exists( sPath ) then\
        local file = io.open(sPath, \"r\" )\
        local sLine = file:read()\
        while sLine do\
            local tLine = {}\
            for x=1,sLine:len() do\
                tLine[x] = tColourLookup[ string.byte(sLine,x,x) ] or 0\
            end\
            table.insert( tImage, tLine )\
            sLine = file:read()\
        end\
        file:close()\
        return tImage\
    end\
    return nil\
end\
\
function drawPixel( xPos, yPos, nColour )\
    if type( xPos ) ~= \"number\" or type( yPos ) ~= \"number\" or (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected x, y, colour\", 2 )\
    end\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    drawPixelInternal( xPos, yPos )\
end\
\
function drawLine( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
    \
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
    \
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    -- TODO: clip to screen rectangle?\
        \
    local xDiff = maxX - minX\
    local yDiff = maxY - minY\
            \
    if xDiff > math.abs(yDiff) then\
        local y = minY\
        local dy = yDiff / xDiff\
        for x=minX,maxX do\
            drawPixelInternal( x, math.floor( y + 0.5 ) )\
            y = y + dy\
        end\
    else\
        local x = minX\
        local dx = xDiff / yDiff\
        if maxY >= minY then\
            for y=minY,maxY do\
                drawPixelInternal( math.floor( x + 0.5 ), y )\
                x = x + dx\
            end\
        else\
            for y=minY,maxY,-1 do\
                drawPixelInternal( math.floor( x + 0.5 ), y )\
                x = x - dx\
            end\
        end\
    end\
end\
\
function drawBox( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
\
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
\
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    for x=minX,maxX do\
        drawPixelInternal( x, minY )\
        drawPixelInternal( x, maxY )\
    end\
\
    if (maxY - minY) >= 2 then\
        for y=(minY+1),(maxY-1) do\
            drawPixelInternal( minX, y )\
            drawPixelInternal( maxX, y )\
        end\
    end\
end\
\
function drawFilledBox( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
\
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
\
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    for x=minX,maxX do\
        for y=minY,maxY do\
            drawPixelInternal( x, y )\
        end\
    end\
end\
\
function drawImage( tImage, xPos, yPos )\
    if type( tImage ) ~= \"table\" or type( xPos ) ~= \"number\" or type( yPos ) ~= \"number\" then\
        error( \"Expected image, x, y\", 2 )\
    end\
    for y=1,#tImage do\
        local tLine = tImage[y]\
        for x=1,#tLine do\
            if tLine[x] > 0 then\
                term.setBackgroundColor( tLine[x] )\
                drawPixelInternal( x + xPos - 1, y + yPos - 1 )\
            end\
        end\
    end\
end",
      "\
local function create( first, ... )\
\009if first ~= nil then\
\009    if type( first ) ~= \"function\" then\
    \009\009error( \"Expected function, got \"..type( first ), 3 )\
    \009end\
 \009\009return coroutine.create(first), create( ... )\
    end\
    return nil\
end\
\
local function runUntilLimit( _routines, _limit )\
    local count = #_routines\
    local living = count\
    \
    local tFilters = {}\
    local eventData = {}\
    while true do\
    \009for n=1,count do\
    \009\009local r = _routines[n]\
    \009\009if r then\
    \009\009\009if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == \"terminate\" then\
\009    \009\009\009local ok, param = coroutine.resume( r, table.unpack(eventData) )\
\009\009\009\009\009if not ok then\
\009\009\009\009\009\009error( param, 0 )\
\009\009\009\009\009else\
\009\009\009\009\009\009tFilters[r] = param\
\009\009\009\009\009end\
\009\009\009\009\009if coroutine.status( r ) == \"dead\" then\
\009\009\009\009\009\009_routines[n] = nil\
\009\009\009\009\009\009living = living - 1\
\009\009\009\009\009\009if living <= _limit then\
\009\009\009\009\009\009\009return n\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
    \009\009end\
    \009end\
\009\009for n=1,count do\
    \009\009local r = _routines[n]\
\009\009\009if r and coroutine.status( r ) == \"dead\" then\
\009\009\009\009_routines[n] = nil\
\009\009\009\009living = living - 1\
\009\009\009\009if living <= _limit then\
\009\009\009\009\009return n\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    \009eventData = { os.pullEventRaw() }\
    end\
end\
\
function waitForAny( ... )\
    local routines = { create( ... ) }\
    return runUntilLimit( routines, #routines - 1 )\
end\
\
function waitForAll( ... )\
    local routines = { create( ... ) }\
\009runUntilLimit( routines, 0 )\
end",
      "local native = peripheral\
\
function getNames()\
\009local tResults = {}\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.isPresent( sSide ) then\
\009\009\009table.insert( tResults, sSide )\
\009\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009\009local tRemote = native.call( sSide, \"getNamesRemote\" )\
\009\009\009\009for n,sName in ipairs( tRemote ) do\
\009\009\009\009\009table.insert( tResults, sName )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009return tResults\
end\
\
function isPresent( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return true\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return true\
\009\009\009end\
\009\009end\
\009end\
\009return false\
end\
\
function getType( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.getType( _sSide )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"getTypeRemote\", _sSide ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function getMethods( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.getMethods( _sSide )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"getMethodsRemote\", _sSide ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function call( _sSide, _sMethod, ... )\
    if type( _sSide ) ~= \"string\" or type( _sMethod ) ~= \"string\" then\
        error( \"Expected string, string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.call( _sSide, _sMethod, ... )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"callRemote\", _sSide, _sMethod, ... ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function wrap( _sSide )\
    if type( _sSide ) ~= \"string\"  then\
        error( \"Expected string\", 2 )\
    end\
\009if peripheral.isPresent( _sSide ) then\
\009\009local tMethods = peripheral.getMethods( _sSide )\
\009\009local tResult = {}\
\009\009for n,sMethod in ipairs( tMethods ) do\
\009\009\009tResult[sMethod] = function( ... )\
\009\009\009\009return peripheral.call( _sSide, sMethod, ... )\
\009\009\009end\
\009\009end\
\009\009return tResult\
\009end\
\009return nil\
end\
\
function find( sType, fnFilter )\
    if type( sType ) ~= \"string\" or (fnFilter ~= nil and type( fnFilter ) ~= \"function\") then\
        error( \"Expected string, [function]\", 2 )\
    end\
\009local tResults = {}\
\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009if peripheral.getType( sName ) == sType then\
\009\009\009local wrapped = peripheral.wrap( sName )\
\009\009\009if fnFilter == nil or fnFilter( sName, wrapped ) then\
\009\009\009\009table.insert( tResults, wrapped )\
\009\009\009end\
\009\009end\
\009end\
\009return table.unpack( tResults )\
end",
      "\
CHANNEL_BROADCAST = 65535\
CHANNEL_REPEAT = 65533\
\
local tReceivedMessages = {}\
local tReceivedMessageTimeouts = {}\
local tHostnames = {}\
\
function open( sModem )\
\009if type( sModem ) ~= \"string\" then\
\009\009error( \"expected string\", 2 )\
\009end\
\009if peripheral.getType( sModem ) ~= \"modem\" then\009\
\009\009error( \"No such modem: \"..sModem, 2 )\
\009end\
\009peripheral.call( sModem, \"open\", os.getComputerID() )\
\009peripheral.call( sModem, \"open\", CHANNEL_BROADCAST )\
end\
\
function close( sModem )\
    if sModem then\
        -- Close a specific modem\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) ~= \"modem\" then\
            error( \"No such modem: \"..sModem, 2 )\
        end\
        peripheral.call( sModem, \"close\", os.getComputerID() )\
        peripheral.call( sModem, \"close\", CHANNEL_BROADCAST )\
    else\
        -- Close all modems\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                close( sModem )\
            end\
        end\
    end\
end\
\
function isOpen( sModem )\
    if sModem then\
        -- Check if a specific modem is open\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) == \"modem\" then\
            return peripheral.call( sModem, \"isOpen\", os.getComputerID() ) and peripheral.call( sModem, \"isOpen\", CHANNEL_BROADCAST )\
        end\
    else\
        -- Check if any modem is open\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                return true\
            end\
        end\
    end\
\009return false\
end\
\
function send( nRecipient, message, sProtocol )\
    -- Generate a (probably) unique message ID\
    -- We could do other things to guarantee uniqueness, but we really don't need to\
    -- Store it to ensure we don't get our own messages back\
    local nMessageID = math.random( 1, 2147483647 )\
    tReceivedMessages[ nMessageID ] = true\
    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\
    -- Create the message\
    local nReplyChannel = os.getComputerID()\
    local tMessage = {\
        nMessageID = nMessageID,\
        nRecipient = nRecipient,\
        message = message,\
        sProtocol = sProtocol,\
    }\
\
    if nRecipient == os.getComputerID() then\
        -- Loopback to ourselves\
        os.queueEvent( \"rednet_message\", nReplyChannel, message, sProtocol )\
\
    else\
        -- Send on all open modems, to the target and to repeaters\
        local sent = false\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                peripheral.call( sModem, \"transmit\", nRecipient, nReplyChannel, tMessage );\
                peripheral.call( sModem, \"transmit\", CHANNEL_REPEAT, nReplyChannel, tMessage );\
                sent = true\
            end\
        end\
    end\
end\
\
function broadcast( message, sProtocol )\
\009send( CHANNEL_BROADCAST, message, sProtocol )\
end\
\
function receive( sProtocolFilter, nTimeout )\
    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility\
    if type(sProtocolFilter) == \"number\" and nTimeout == nil then\
        sProtocolFilter, nTimeout = nil, sProtocolFilter\
    end\
\
    -- Start the timer\
\009local timer = nil\
\009local sFilter = nil\
\009if nTimeout then\
\009\009timer = os.startTimer( nTimeout )\
\009\009sFilter = nil\
\009else\
\009\009sFilter = \"rednet_message\"\
\009end\
\
\009-- Wait for events\
\009while true do\
\009\009local sEvent, p1, p2, p3 = os.pullEvent( sFilter )\
\009\009if sEvent == \"rednet_message\" then\
\009\009    -- Return the first matching rednet_message\
\009\009\009local nSenderID, message, sProtocol = p1, p2, p3\
\009\009\009if sProtocolFilter == nil or sProtocol == sProtocolFilter then\
    \009\009\009return nSenderID, message, sProtocol\
    \009    end\
\009\009elseif sEvent == \"timer\" then\
\009\009    -- Return nil if we timeout\
\009\009    if p1 == timer then\
    \009\009\009return nil\
    \009\009end\
\009\009end\
\009end\
end\
\
function host( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" or type( sHostname ) ~= \"string\" then\
        error( \"expected string, string\", 2 )\
    end\
    if sHostname == \"localhost\" then\
        error( \"Reserved hostname\", 2 )\
    end\
    if tHostnames[ sProtocol ] ~= sHostname then\
        if lookup( sProtocol, sHostname ) ~= nil then\
            error( \"Hostname in use\", 2 )\
        end\
        tHostnames[ sProtocol ] = sHostname\
    end\
end\
\
function unhost( sProtocol )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
    tHostnames[ sProtocol ] = nil\
end\
\
function lookup( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
\
    -- Build list of host IDs\
    local tResults = nil\
    if sHostname == nil then\
        tResults = {}\
    end\
\
    -- Check localhost first\
    if tHostnames[ sProtocol ] then\
        if sHostname == nil then\
            table.insert( tResults, os.getComputerID() )\
        elseif sHostname == \"localhost\" or sHostname == tHostnames[ sProtocol ] then\
            return os.getComputerID()\
        end\
    end\
\
    if not isOpen() then\
        if tResults then\
            return table.unpack( tResults )\
        end\
        return nil\
    end\
\
    -- Broadcast a lookup packet\
    broadcast( {\
        sType = \"lookup\",\
        sProtocol = sProtocol,\
        sHostname = sHostname,\
    }, \"dns\" )\
\
    -- Start a timer\
    local timer = os.startTimer( 2 )\
\
    -- Wait for events\
    while true do\
        local event, p1, p2, p3 = os.pullEvent()\
        if event == \"rednet_message\" then\
            -- Got a rednet message, check if it's the response to our request\
            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3\
            if sMessageProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup response\" then\
                if tMessage.sProtocol == sProtocol then\
                    if sHostname == nil then\
                        table.insert( tResults, nSenderID )\
                    elseif tMessage.sHostname == sHostname then\
                        return nSenderID\
                    end\
                end\
            end\
        else\
            -- Got a timer event, check it's the end of our timeout\
            if p1 == timer then\
                break\
            end\
        end\
    end\
    if tResults then\
        return table.unpack( tResults )\
    end\
    return nil\
end\
\
local bRunning = false\
function run()\
\009if bRunning then\
\009\009error( \"rednet is already running\", 2 )\
\009end\
\009bRunning = true\
\009\
\009while bRunning do\
\009\009local sEvent, p1, p2, p3, p4 = os.pullEventRaw()\
\009\009if sEvent == \"modem_message\" then\
\009\009\009-- Got a modem message, process it and add it to the rednet event queue\
    \009\009local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4\
\009\009    if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then\
    \009\009\009if type( tMessage ) == \"table\" and tMessage.nMessageID then\
\009    \009\009\009if not tReceivedMessages[ tMessage.nMessageID ] then\
\009\009    \009\009\009tReceivedMessages[ tMessage.nMessageID ] = true\
                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\009\009\009    \009\009os.queueEvent( \"rednet_message\", nReplyChannel, tMessage.message, tMessage.sProtocol )\
\009\009\009\009    end\
\009\009\009    end\
\009\009\009end\
\
\009\009elseif sEvent == \"rednet_message\" then\
\009\009    -- Got a rednet message (queued from above), respond to dns lookup\
\009\009    local nSenderID, tMessage, sProtocol = p1, p2, p3\
\009\009    if sProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup\" then\
\009\009        local sHostname = tHostnames[ tMessage.sProtocol ]\
\009\009        if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then\
\009\009            rednet.send( nSenderID, {\
\009\009                sType = \"lookup response\",\
\009\009                sHostname = sHostname,\
\009\009                sProtocol = tMessage.sProtocol,\
\009\009            }, \"dns\" )\
\009\009        end\
\009\009    end\
\
\009\009elseif sEvent == \"timer\" then\
            -- Got a timer event, use it to clear the event queue\
            local nTimer = p1\
            local nMessage = tReceivedMessageTimeouts[ nTimer ]\
            if nMessage then\
                tReceivedMessageTimeouts[ nTimer ] = nil\
                tReceivedMessages[ nMessage ] = nil\
            end\
\009\009end\
\009end\
end",
      "\
local tSettings = {}\
\
function set( sName, value )\
    if type(sName) ~= \"string\" or\
       (type(value) ~= \"string\" and type(value) ~= \"number\" and type(value) ~= \"boolean\" and type(value) ~= \"table\") then\
        error( \"Expected string, value\", 2 )\
    end\
    if type(value) == \"table\" then\
        -- Ensure value is serializeable\
        value = textutils.unserialize( textutils.serialize(value) )\
    end\
    tSettings[ sName ] = value\
end\
\
local copy\
function copy( value )\
    if type(value) == \"table\" then\
        local result = {}\
        for k,v in pairs(value) do\
            result[k] = copy(v)\
        end\
        return result\
    else\
        return value\
    end\
end\
\
function get( sName, default )\
    if type(sName) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local result = tSettings[ sName ]\
    if result ~= nil then\
        return copy(result)\
    else\
        return default\
    end\
end\
\
function unset( sName )\
    if type(sName) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    tSettings[ sName ] = nil\
end\
\
function clear()\
    tSettings = {}\
end\
\
function getNames()\
    local result = {}\
    for k,v in pairs( tSettings ) do\
        result[ #result + 1 ] = k\
    end\
    return result\
end\
\
function load( sPath )\
    if type(sPath) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local file = fs.open( sPath, \"r\" )\
    if not file then\
        return false\
    end\
\
    local sText = file.readAll()\
    file.close()\
\
    local tFile = textutils.unserialize( sText )\
    if type(tFile) ~= \"table\" then\
        return false\
    end\
\
    for k,v in pairs(tFile) do\
        if type(k) == \"string\" and\
           (type(v) == \"string\" or type(v) == \"number\" or type(v) == \"boolean\" or type(v) == \"table\") then\
            set( k, v )\
        end\
    end\
\
    return true\
end\
\
function save( sPath )\
    if type(sPath) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local file = fs.open( sPath, \"w\" )\
    if not file then\
        return false\
    end\
\
    file.write( textutils.serialize( tSettings ) )\
    file.close()\
\
    return true\
end",
      "\
local native = (term.native and term.native()) or term\
local redirectTarget = native\
\
local function wrap( _sFunction )\
\009return function( ... )\
\009\009return redirectTarget[ _sFunction ]( ... )\
\009end\
end\
\
local term = {}\
\
term.redirect = function( target )\
\009if target == nil or type( target ) ~= \"table\" then\
\009\009error( \"Invalid redirect target\", 2 )\
\009end\
    if target == term then\
        error( \"term is not a recommended redirect target, try term.current() instead\", 2 )\
    end\
\009for k,v in pairs( native ) do\
\009\009if type( k ) == \"string\" and type( v ) == \"function\" then\
\009\009\009if type( target[k] ) ~= \"function\" then\
\009\009\009\009target[k] = function()\
\009\009\009\009\009error( \"Redirect object is missing method \"..k..\".\", 2 )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009local oldRedirectTarget = redirectTarget\
\009redirectTarget = target\
\009return oldRedirectTarget\
end\
\
term.current = function()\
    return redirectTarget\
end\
\
term.native = function()\
    -- NOTE: please don't use this function unless you have to.\
    -- If you're running in a redirected or multitasked enviorment, term.native() will NOT be\
    -- the current terminal when your program starts up. It is far better to use term.current()\
    return native\
end\
\
for k,v in pairs( native ) do\
\009if type( k ) == \"string\" and type( v ) == \"function\" then\
\009\009if term[k] == nil then\
\009\009\009term[k] = wrap( k )\
\009\009end\
\009end\
end\
\009\
local env = _ENV\
for k,v in pairs( term ) do\
\009env[k] = v\
end",
      "\
function slowWrite( sText, nRate )\
    nRate = nRate or 20\
    if nRate < 0 then\
        error( \"Rate must be positive\", 2 )\
    end\
    local nSleep = 1 / nRate\
        \
    sText = tostring( sText )\
    local x,y = term.getCursorPos(x,y)\
    local len = string.len( sText )\
    \
    for n=1,len do\
        term.setCursorPos( x, y )\
        sleep( nSleep )\
        local nLines = write( string.sub( sText, 1, n ) )\
        local newX, newY = term.getCursorPos()\
        y = newY - nLines\
    end\
end\
\
function slowPrint( sText, nRate )\
    slowWrite( sText, nRate)\
    print()\
end\
\
function formatTime( nTime, bTwentyFourHour )\
    local sTOD = nil\
    if not bTwentyFourHour then\
        if nTime >= 12 then\
            sTOD = \"PM\"\
        else\
            sTOD = \"AM\"\
        end\
        if nTime >= 13 then\
            nTime = nTime - 12\
        end\
    end\
\
    local nHour = math.floor(nTime)\
    local nMinute = math.floor((nTime - nHour)*60)\
    if sTOD then\
        return string.format( \"%d:%02d %s\", nHour, nMinute, sTOD )\
    else\
        return string.format( \"%d:%02d\", nHour, nMinute )\
    end\
end\
\
local function makePagedScroll( _term, _nFreeLines )\
    local nativeScroll = _term.scroll\
    local nFreeLines = _nFreeLines or 0\
    return function( _n )\
        for n=1,_n do\
            nativeScroll( 1 )\
            \
            if nFreeLines <= 0 then\
                local w,h = _term.getSize()\
                _term.setCursorPos( 1, h )\
                _term.write( \"Press any key to continue\" )\
                os.pullEvent( \"key\" )\
                _term.clearLine()\
                _term.setCursorPos( 1, h )\
            else\
                nFreeLines = nFreeLines - 1\
            end\
        end\
    end\
end\
\
function pagedPrint( _sText, _nFreeLines )\
    -- Setup a redirector\
    local oldTerm = term.current()\
    local newTerm = {}\
    for k,v in pairs( oldTerm ) do\
        newTerm[k] = v\
    end\
    newTerm.scroll = makePagedScroll( oldTerm, _nFreeLines )\
    term.redirect( newTerm )\
\
    -- Print the text\
    local result\
    local ok, err = pcall( function()\
        if _sText ~= nil then\
            result = print( _sText )\
        else\
            result = print()\
        end\
    end )\
\
    -- Removed the redirector\
    term.redirect( oldTerm )\
\
    -- Propogate errors\
    if not ok then\
        error( err, 0 )\
    end\
    return result\
end\
\
local function tabulateCommon( bPaged, ... )\
    local tAll = { ... }\
    \
    local w,h = term.getSize()\
    local nMaxLen = w / 8\
    for n, t in ipairs( tAll ) do\
        if type(t) == \"table\" then\
            for n, sItem in pairs(t) do\
                nMaxLen = math.max( string.len( sItem ) + 1, nMaxLen )\
            end\
        end\
    end\
    local nCols = math.floor( w / nMaxLen )\
    local nLines = 0\
    local function newLine()\
        if bPaged and nLines >= (h-3) then\
            pagedPrint()\
        else\
            print()\
        end\
        nLines = nLines + 1\
    end\
    \
    local function drawCols( _t )\
        local nCol = 1\
        for n, s in ipairs( _t ) do\
            if nCol > nCols then\
                nCol = 1\
                newLine()\
            end\
\
            local cx, cy = term.getCursorPos()\
            cx = 1 + ((nCol - 1) * nMaxLen)\
            term.setCursorPos( cx, cy )\
            term.write( s )\
\
            nCol = nCol + 1      \
        end\
        print()\
    end\
    for n, t in ipairs( tAll ) do\
        if type(t) == \"table\" then\
            if #t > 0 then\
                drawCols( t )\
            end\
        elseif type(t) == \"number\" then\
            term.setTextColor( t )\
        end\
    end    \
end\
\
function tabulate( ... )\
    tabulateCommon( false, ... )\
end\
\
function pagedTabulate( ... )\
    tabulateCommon( true, ... )\
end\
\
local g_tLuaKeywords = {\
    [ \"and\" ] = true,\
    [ \"break\" ] = true,\
    [ \"do\" ] = true,\
    [ \"else\" ] = true,\
    [ \"elseif\" ] = true,\
    [ \"end\" ] = true,\
    [ \"false\" ] = true,\
    [ \"for\" ] = true,\
    [ \"function\" ] = true,\
    [ \"if\" ] = true,\
    [ \"in\" ] = true,\
    [ \"local\" ] = true,\
    [ \"nil\" ] = true,\
    [ \"not\" ] = true,\
    [ \"or\" ] = true,\
    [ \"repeat\" ] = true,\
    [ \"return\" ] = true,\
    [ \"then\" ] = true,\
    [ \"true\" ] = true,\
    [ \"until\" ] = true,\
    [ \"while\" ] = true,\
}\
\
local function serializeImpl( t, tTracking, sIndent )\
    local sType = type(t)\
    if sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            -- Empty tables are simple\
            return \"{}\"\
        else\
            -- Other tables take more work\
            local sResult = \"{\\n\"\
            local sSubIndent = sIndent .. \"  \"\
            local tSeen = {}\
            for k,v in ipairs(t) do\
                tSeen[k] = true\
                sResult = sResult .. sSubIndent .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
            end\
            for k,v in pairs(t) do\
                if not tSeen[k] then\
                    local sEntry\
                    if type(k) == \"string\" and not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        sEntry = k .. \" = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
                    else\
                        sEntry = \"[ \" .. serializeImpl( k, tTracking, sSubIndent ) .. \" ] = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
                    end\
                    sResult = sResult .. sSubIndent .. sEntry\
                end\
            end\
            sResult = sResult .. sIndent .. \"}\"\
            return sResult\
        end\
        \
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
    \
    elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\
        return tostring(t)\
        \
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
        \
    end\
end\
\
empty_json_array = {}\
\
local function serializeJSONImpl( t, tTracking, bNBTStyle )\
    local sType = type(t)\
    if t == empty_json_array then\
        return \"[]\"\
\
    elseif sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            -- Empty tables are simple\
            return \"{}\"\
        else\
            -- Other tables take more work\
            local sObjectResult = \"{\"\
            local sArrayResult = \"[\"\
            local nObjectSize = 0\
            local nArraySize = 0\
            for k,v in pairs(t) do\
                if type(k) == \"string\" then\
                    local sEntry\
                    if bNBTStyle then\
                        sEntry = tostring(k) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\
                    else\
                        sEntry = string.format( \"%q\", k ) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\
                    end\
                    if nObjectSize == 0 then\
                        sObjectResult = sObjectResult .. sEntry\
                    else\
                        sObjectResult = sObjectResult .. \",\" .. sEntry\
                    end\
                    nObjectSize = nObjectSize + 1\
                end\
            end\
            for n,v in ipairs(t) do\
                local sEntry = serializeJSONImpl( v, tTracking, bNBTStyle )\
                if nArraySize == 0 then\
                    sArrayResult = sArrayResult .. sEntry\
                else\
                    sArrayResult = sArrayResult .. \",\" .. sEntry\
                end\
                nArraySize = nArraySize + 1\
            end\
            sObjectResult = sObjectResult .. \"}\"\
            sArrayResult = sArrayResult .. \"]\"\
            if nObjectSize > 0 or nArraySize == 0 then\
                return sObjectResult\
            else\
                return sArrayResult\
            end\
        end\
\
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
\
    elseif sType == \"number\" or sType == \"boolean\" then\
        return tostring(t)\
\
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
\
    end\
end\
\
function serialize( t )\
    local tTracking = {}\
    return serializeImpl( t, tTracking, \"\" )\
end\
\
function unserialize( s )\
    local func = load( \"return \"..s, \"unserialize\", \"t\", {} )\
    if func then\
        local ok, result = pcall( func )\
        if ok then\
            return result\
        end\
    end\
    return nil\
end\
\
function serializeJSON( t, bNBTStyle )\
    local tTracking = {}\
    return serializeJSONImpl( t, tTracking, bNBTStyle or false )\
end\
\
function urlEncode( str )\
    if str then\
        str = string.gsub(str, \"\\n\", \"\\r\\n\")\
        str = string.gsub(str, \"([^A-Za-z0-9 %-%_%.])\", function(c)\
            local n = string.byte(c)\
            if n < 128 then\
                -- ASCII\
                return string.format(\"%%%02X\", n)\
            else\
                -- Non-ASCII (encode as UTF-8)\
                return\
                    string.format(\"%%%02X\", 192 + bit32.band( bit32.arshift(n,6), 31 ) ) ..\
                    string.format(\"%%%02X\", 128 + bit32.band( n, 63 ) )\
            end\
        end )\
        str = string.gsub(str, \" \", \"+\")\
    end\
    return str    \
end\
\
local tEmpty = {}\
function complete( sSearchText, tSearchTable )\
    local nStart = 1\
    local nDot = string.find( sSearchText, \".\", nStart, true )\
    local tTable = tSearchTable or _ENV\
    while nDot do\
        local sPart = string.sub( sSearchText, nStart, nDot - 1 )\
        local value = tTable[ sPart ]\
        if type( value ) == \"table\" then\
            tTable = value\
            nStart = nDot + 1\
            nDot = string.find( sSearchText, \".\", nStart, true )\
        else\
            return tEmpty\
        end\
    end\
\
    local sPart = string.sub( sSearchText, nStart, nDot )\
    local nPartLength = string.len( sPart )\
\
    local tResults = {}\
    local tSeen = {}\
    while tTable do\
        for k,v in pairs( tTable ) do\
            if not tSeen[k] and type(k) == \"string\" then\
                if string.find( k, sPart, 1, true ) == 1 then\
                    if not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        local sResult = string.sub( k, nPartLength + 1 )\
                        if type(v) == \"function\" then\
                            sResult = sResult .. \"(\"\
                        elseif type(v) == \"table\" and next(v) ~= nil then\
                            sResult = sResult .. \".\"\
                        end\
                        table.insert( tResults, sResult )\
                    end\
                end\
            end\
            tSeen[k] = true\
        end\
        local tMetatable = getmetatable( tTable )\
        if tMetatable and type( tMetatable.__index ) == \"table\" then\
            tTable = tMetatable.__index\
        else\
            tTable = nil\
        end\
    end\
\
    table.sort( tResults )\
    return tResults\
end\
\
-- GB versions\
serialise = serialize\
unserialise = unserialize\
serialiseJSON = serializeJSON",
      "\
if not turtle then\
\009error( \"Cannot load turtle API on computer\", 2 )\
end\
native = turtle.native or turtle\
\
local function addCraftMethod( object )\
    if peripheral.getType( \"left\" ) == \"workbench\" then\
        object.craft = function( ... )\
            return peripheral.call( \"left\", \"craft\", ... )\
        end\
    elseif peripheral.getType( \"right\" ) == \"workbench\" then\
        object.craft = function( ... )\
            return peripheral.call( \"right\", \"craft\", ... )\
        end\
    else\
        object.craft = nil\
    end\
end\
\
-- Put commands into environment table\
local env = _ENV\
for k,v in pairs( native ) do\
    if k == \"equipLeft\" or k == \"equipRight\" then\
        env[k] = function( ... )\
            local result, err = v( ... )\
            addCraftMethod( turtle )\
            return result, err\
        end\
    else\
    \009env[k] = v\
    end\
end\
addCraftMethod( env )",
      "\
local vector = {\
\009add = function( self, o )\
\009\009return vector.new(\
\009\009\009self.x + o.x,\
\009\009\009self.y + o.y,\
\009\009\009self.z + o.z\
\009\009)\
\009end,\
\009sub = function( self, o )\
\009\009return vector.new(\
\009\009\009self.x - o.x,\
\009\009\009self.y - o.y,\
\009\009\009self.z - o.z\
\009\009)\
\009end,\
\009mul = function( self, m )\
\009\009return vector.new(\
\009\009\009self.x * m,\
\009\009\009self.y * m,\
\009\009\009self.z * m\
\009\009)\
\009end,\
\009div = function( self, m )\
\009\009return vector.new(\
\009\009\009self.x / m,\
\009\009\009self.y / m,\
\009\009\009self.z / m\
\009\009)\
\009end,\
\009unm = function( self )\
\009\009return vector.new(\
\009\009\009-self.x,\
\009\009\009-self.y,\
\009\009\009-self.z\
\009\009)\
\009end,\
\009dot = function( self, o )\
\009\009return self.x*o.x + self.y*o.y + self.z*o.z\
\009end,\
\009cross = function( self, o )\
\009\009return vector.new(\
\009\009\009self.y*o.z - self.z*o.y,\
\009\009\009self.z*o.x - self.x*o.z,\
\009\009\009self.x*o.y - self.y*o.x\
\009\009)\
\009end,\
\009length = function( self )\
\009\009return math.sqrt( self.x*self.x + self.y*self.y + self.z*self.z )\
\009end,\
\009normalize = function( self )\
\009\009return self:mul( 1 / self:length() )\
\009end,\
\009round = function( self, nTolerance )\
\009    nTolerance = nTolerance or 1.0\
\009\009return vector.new(\
\009\009\009math.floor( (self.x + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\
\009\009\009math.floor( (self.y + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\
\009\009\009math.floor( (self.z + (nTolerance * 0.5)) / nTolerance ) * nTolerance\
\009\009)\
\009end,\
\009tostring = function( self )\
\009\009return self.x..\",\"..self.y..\",\"..self.z\
\009end,\
}\
\
local vmetatable = {\
\009__index = vector,\
\009__add = vector.add,\
\009__sub = vector.sub,\
\009__mul = vector.mul,\
\009__div = vector.div,\
\009__unm = vector.unm,\
\009__tostring = vector.tostring,\
}\
\
function new( x, y, z )\
\009local v = {\
\009\009x = x or 0,\
\009\009y = y or 0,\
\009\009z = z or 0\
\009}\
\009setmetatable( v, vmetatable )\
\009return v\
end",
      "\
local tHex = {\
    [ colors.white ] = \"0\",\
    [ colors.orange ] = \"1\",\
    [ colors.magenta ] = \"2\",\
    [ colors.lightBlue ] = \"3\",\
    [ colors.yellow ] = \"4\",\
    [ colors.lime ] = \"5\",\
    [ colors.pink ] = \"6\",\
    [ colors.gray ] = \"7\",\
    [ colors.lightGray ] = \"8\",\
    [ colors.cyan ] = \"9\",\
    [ colors.purple ] = \"a\",\
    [ colors.blue ] = \"b\",\
    [ colors.brown ] = \"c\",\
    [ colors.green ] = \"d\",\
    [ colors.red ] = \"e\",\
    [ colors.black ] = \"f\",\
}\
\
local string_rep = string.rep\
local string_sub = string.sub\
\
function create( parent, nX, nY, nWidth, nHeight, bStartVisible )\
\
    if type( parent ) ~= \"table\" or\
       type( nX ) ~= \"number\" or\
       type( nY ) ~= \"number\" or\
       type( nWidth ) ~= \"number\" or\
       type( nHeight ) ~= \"number\" or\
       (bStartVisible ~= nil and type( bStartVisible ) ~= \"boolean\") then\
        error( \"Expected object, number, number, number, number, [boolean]\", 2 )\
    end\
\
    if parent == term then\
        error( \"term is not a recommended window parent, try term.current() instead\", 2 )\
    end\
\
    local sEmptySpaceLine\
    local tEmptyColorLines = {}\
    local function createEmptyLines( nWidth )\
        sEmptySpaceLine = string_rep( \" \", nWidth )\
        for n=0,15 do\
            local nColor = 2^n\
            local sHex = tHex[nColor]\
            tEmptyColorLines[nColor] = string_rep( sHex, nWidth )\
        end\
    end\
\
    createEmptyLines( nWidth )\
\
    -- Setup\
    local bVisible = (bStartVisible ~= false)\
    local nCursorX = 1\
    local nCursorY = 1\
    local bCursorBlink = false\
    local nTextColor = colors.white\
    local nBackgroundColor = colors.black\
    local tLines = {}\
    do\
        local sEmptyText = sEmptySpaceLine\
        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
        for y=1,nHeight do\
            tLines[y] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
        end\
    end\
\
    -- Helper functions\
    local function updateCursorPos()\
        if nCursorX >= 1 and nCursorY >= 1 and\
           nCursorX <= nWidth and nCursorY <= nHeight then\
            parent.setCursorPos( nX + nCursorX - 1, nY + nCursorY - 1 )\
        else\
            parent.setCursorPos( 0, 0 )\
        end\
    end\
    \
    local function updateCursorBlink()\
        parent.setCursorBlink( bCursorBlink )\
    end\
    \
    local function updateCursorColor()\
        parent.setTextColor( nTextColor )\
    end\
    \
    local function redrawLine( n )\
        local tLine = tLines[ n ]\
        parent.setCursorPos( nX, nY + n - 1 )\
        parent.blit( tLine.text, tLine.textColor, tLine.backgroundColor )\
    end\
\
    local function redraw()\
        for n=1,nHeight do\
            redrawLine( n )\
        end\
    end\
\
    local function internalBlit( sText, sTextColor, sBackgroundColor )\
        local nStart = nCursorX\
        local nEnd = nStart + #sText - 1\
        if nCursorY >= 1 and nCursorY <= nHeight then\
            if nStart <= nWidth and nEnd >= 1 then\
                -- Modify line\
                local tLine = tLines[ nCursorY ]\
                if nStart == 1 and nEnd == nWidth then\
                    tLine.text = sText\
                    tLine.textColor = sTextColor\
                    tLine.backgroundColor = sBackgroundColor\
                else\
                    local sClippedText, sClippedTextColor, sClippedBackgroundColor\
                    if nStart < 1 then\
                        local nClipStart = 1 - nStart + 1\
                        local nClipEnd = nWidth - nStart + 1\
                        sClippedText = string_sub( sText, nClipStart, nClipEnd )\
                        sClippedTextColor = string_sub( sTextColor, nClipStart, nClipEnd )\
                        sClippedBackgroundColor = string_sub( sBackgroundColor, nClipStart, nClipEnd )\
                    elseif nEnd > nWidth then\
                        local nClipEnd = nWidth - nStart + 1\
                        sClippedText = string_sub( sText, 1, nClipEnd )\
                        sClippedTextColor = string_sub( sTextColor, 1, nClipEnd )\
                        sClippedBackgroundColor = string_sub( sBackgroundColor, 1, nClipEnd )\
                    else\
                        sClippedText = sText\
                        sClippedTextColor = sTextColor\
                        sClippedBackgroundColor = sBackgroundColor\
                    end\
\
                    local sOldText = tLine.text\
                    local sOldTextColor = tLine.textColor\
                    local sOldBackgroundColor = tLine.backgroundColor\
                    local sNewText, sNewTextColor, sNewBackgroundColor\
                    if nStart > 1 then\
                        local nOldEnd = nStart - 1\
                        sNewText = string_sub( sOldText, 1, nOldEnd ) .. sClippedText\
                        sNewTextColor = string_sub( sOldTextColor, 1, nOldEnd ) .. sClippedTextColor\
                        sNewBackgroundColor = string_sub( sOldBackgroundColor, 1, nOldEnd ) .. sClippedBackgroundColor\
                    else\
                        sNewText = sClippedText\
                        sNewTextColor = sClippedTextColor\
                        sNewBackgroundColor = sClippedBackgroundColor\
                    end\
                    if nEnd < nWidth then\
                        local nOldStart = nEnd + 1\
                        sNewText = sNewText .. string_sub( sOldText, nOldStart, nWidth )\
                        sNewTextColor = sNewTextColor .. string_sub( sOldTextColor, nOldStart, nWidth )\
                        sNewBackgroundColor = sNewBackgroundColor .. string_sub( sOldBackgroundColor, nOldStart, nWidth )\
                    end\
\
                    tLine.text = sNewText\
                    tLine.textColor = sNewTextColor\
                    tLine.backgroundColor = sNewBackgroundColor\
                end\
\
                -- Redraw line\
                if bVisible then\
                    redrawLine( nCursorY )\
                end\
            end\
        end\
\
        -- Move and redraw cursor\
        nCursorX = nEnd + 1\
        if bVisible then\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    -- Terminal implementation\
    local window = {}\
\
    function window.write( sText )\
        sText = tostring( sText )\
        internalBlit( sText, string_rep( tHex[ nTextColor ], #sText ), string_rep( tHex[ nBackgroundColor ], #sText ) )\
    end\
\
    function window.blit( sText, sTextColor, sBackgroundColor )\
        if type(sText) ~= \"string\" or type(sTextColor) ~= \"string\" or type(sBackgroundColor) ~= \"string\" then\
            error( \"Expected string, string, string\", 2 )\
        end\
        if #sTextColor ~= #sText or #sBackgroundColor ~= #sText then\
            error( \"Arguments must be the same length\", 2 )\
        end\
        internalBlit( sText, sTextColor, sBackgroundColor )\
    end\
\
    function window.clear()\
        local sEmptyText = sEmptySpaceLine\
        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
        for y=1,nHeight do\
            tLines[y] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
        end\
        if bVisible then\
            redraw()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.clearLine()\
        if nCursorY >= 1 and nCursorY <= nHeight then\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            tLines[ nCursorY ] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
            if bVisible then\
                redrawLine( nCursorY )\
                updateCursorColor()\
                updateCursorPos()\
            end\
        end\
    end\
\
    function window.getCursorPos()\
        return nCursorX, nCursorY\
    end\
\
    function window.setCursorPos( x, y )\
        nCursorX = math.floor( x )\
        nCursorY = math.floor( y )\
        if bVisible then\
            updateCursorPos()\
        end\
    end\
\
    function window.setCursorBlink( blink )\
        bCursorBlink = blink\
        if bVisible then\
            updateCursorBlink()\
        end\
    end\
\
    local function isColor()\
        return parent.isColor()\
    end\
\
    function window.isColor()\
        return isColor()\
    end\
\
    function window.isColour()\
        return isColor()\
    end\
\
    local function setTextColor( color )\
        if not parent.isColor() then\
            if color ~= colors.white and color ~= colors.black and color ~= colors.gray and color ~= colors.lightGray then\
                error( \"Color not supported\", 3 )\
            end\
        end\
        nTextColor = color\
        if bVisible then\
            updateCursorColor()\
        end\
    end\
\
    function window.setTextColor( color )\
        setTextColor( color )\
    end\
\
    function window.setTextColour( color )\
        setTextColor( color )\
    end\
\
    local function setBackgroundColor( color )\
        if not parent.isColor() then\
            if color ~= colors.white and color ~= colors.black and color ~= colors.gray and color ~= colors.lightGray then\
                error( \"Color not supported\", 3 )\
            end\
        end\
        nBackgroundColor = color\
    end\
\
    function window.setBackgroundColor( color )\
        setBackgroundColor( color )\
    end\
\
    function window.setBackgroundColour( color )\
        setBackgroundColor( color )\
    end\
\
    function window.getSize()\
        return nWidth, nHeight\
    end\
\
    function window.scroll( n )\
        if n ~= 0 then\
            local tNewLines = {}\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            for newY=1,nHeight do\
                local y = newY + n\
                if y >= 1 and y <= nHeight then\
                    tNewLines[newY] = tLines[y]\
                else\
                    tNewLines[newY] = {\
                        text = sEmptyText,\
                        textColor = sEmptyTextColor,\
                        backgroundColor = sEmptyBackgroundColor,\
                    }\
                end\
            end\
            tLines = tNewLines\
            if bVisible then\
                redraw()\
                updateCursorColor()\
                updateCursorPos()\
            end\
        end\
    end\
\
    function window.getTextColor()\
        return nTextColor\
    end\
\
    function window.getTextColour()\
        return nTextColor\
    end\
\
    function window.getBackgroundColor()\
        return nBackgroundColor\
    end\
\
    function window.getBackgroundColour()\
        return nBackgroundColor\
    end\
\
    -- Other functions\
    function window.setVisible( bVis )\
        if bVisible ~= bVis then\
            bVisible = bVis\
            if bVisible then\
                window.redraw()\
            end\
        end\
    end\
\
    function window.redraw()\
        if bVisible then\
            redraw()\
            updateCursorBlink()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.restoreCursor()\
        if bVisible then\
            updateCursorBlink()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.getPosition()\
        return nX, nY\
    end\
\
    function window.reposition( nNewX, nNewY, nNewWidth, nNewHeight )\
        nX = nNewX\
        nY = nNewY\
        if nNewWidth and nNewHeight then\
            local tNewLines = {}\
            createEmptyLines( nNewWidth )\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            for y=1,nNewHeight do\
                if y > nHeight then\
                    tNewLines[y] = {\
                        text = sEmptyText,\
                        textColor = sEmptyTextColor,\
                        backgroundColor = sEmptyBackgroundColor\
                    }\
                else\
                    local tOldLine = tLines[y]\
                    if nNewWidth == nWidth then\
                        tNewLines[y] = tOldLine\
                    elseif nNewWidth < nWidth then\
                        tNewLines[y] = {\
                            text = string_sub( tOldLine.text, 1, nNewWidth ),\
                            textColor = string_sub( tOldLine.textColor, 1, nNewWidth ),\
                            backgroundColor = string_sub( tOldLine.backgroundColor, 1, nNewWidth ),\
                        }\
                    else\
                        tNewLines[y] = {\
                            text = tOldLine.text .. string_sub( sEmptyText, nWidth + 1, nNewWidth ),\
                            textColor = tOldLine.textColor .. string_sub( sEmptyTextColor, nWidth + 1, nNewWidth ),\
                            backgroundColor = tOldLine.backgroundColor .. string_sub( sEmptyBackgroundColor, nWidth + 1, nNewWidth ),\
                        }\
                    end\
                end\
            end\
            nWidth = nNewWidth\
            nHeight = nNewHeight\
            tLines = tNewLines\
        end\
        if bVisible then\
            window.redraw()\
        end\
    end\
\
    if bVisible then\
        window.redraw()\
    end\
    return window\
end",
      "--[[\
Alright then, don't ignore me. This file is to ensure the existance of the \"autorun\" folder, files placed in this folder\
using resource packs will always run when computers startup.\
]]",
      "adventure is a text adventure game for CraftOS. To navigate around the world of adventure, type simple instructions to the interpreter, for example: \"go north\", \"punch tree\", \"craft planks\", \"mine coal with pickaxe\", \"hit creeper with sword\"",
      "alias assigns shell commands to run other programs.\
\
ex:\
\"alias dir ls\" will make the \"dir\" command run the \"ls\" program\
\"alias dir\" will remove the alias set on \"dir\"\
\"alias\" will list all current aliases.",
      "apis lists the currently loaded APIs available to programs in CraftOS.\
\
Type \"help <api>\" to see help for a specific api.\
Call os.loadAPI( path ) to load extra apis.",
      "bg is a program for Advanced Computers which opens a new tab in the background.\
\
ex:\
\"bg\" will open a background tab running the shell\
\"bg worm\" will open a background tab running the \"worm\" program",
      "Functions in the bit manipulation API (NOTE: This API will be removed in a future version. Use bit32 instead):\
bit.bnot(n)          -- bitwise not (~n)\
bit.band(m, n)       -- bitwise and (m & n)\
bit.bor(m, n)        -- bitwise or (m | n)\
bit.bxor(m, n)       -- bitwise xor (m ^ n)\
bit.brshift(n, bits) -- right shift (n >> bits)\
bit.blshift(n, bits) -- left shift (n << bits)",
      "To set bundled outputs:\
c = colors.combine( colors.red, colors.blue )\
rs.setBundledOutput( \"left\", c )\
\
c = colors.combine( c, colors.green )\
rs.setBundledOutput( \"left\", c )\
\
c = colors.subtract( c, colors.blue )\
rs.setBundledOutput( \"left\", c )\
\
To get bundled inputs:\
c = rs.getBundledInput( \"right\" )\
red = colors.test( c, colors.red )\
\
Type \"help colors\" for the list of wire colors.",
      "cd changes the the directory you're in.\
\
ex:\
\"cd rom\" will move to \"rom\" folder.\
\"cd ..\" will move up one folder.\
\"cd /\" will move to the root.",
      "New Features in ComputerCraft 1.79:\
\
* Ported ComputerCraftEdu to Minecraft 1.8.9\
* Fixed a handful of bugs in ComputerCraft\
\
New Features in ComputerCraft 1.77:\
\
* Ported to Minecraft 1.8.9\
* Added \"settings\" API\
* Added \"set\" and \"wget\" programs\
* Added settings to disable multishell, startup scripts, and tab completion on a per-computer basis. The default values for these settings can be customised in ComputerCraft.cfg\
* All Computer and Turtle items except Command Computers can now be mounted in Disk Drives\
\
New Features in ComputerCraft 1.76:\
\
* Ported to Minecraft 1.8\
* Added Ender Modems for cross-dimensional communication\
* Fixed handling of 8-bit characters. All the characters in the ISO 8859-1 codepage can now be displayed\
* Added some extra graphical characters in the unused character positions, including a suite of characters for Teletext style drawing\
* Added support for the new commands in Minecraft 1.8 to the Command Computer\
* The return values of turtle.inspect() and commands.getBlockInfo() now include blockstate information\
* Added commands.getBlockInfos() function for Command Computers\
* Added new \"peripherals\" program\
* Replaced the \"_CC_VERSION\" and \"_MC_VERSION\" constants with a new \"_HOST\" constant\
* Shortened the length of time that \"Ctrl+T\", \"Ctrl+S\" and \"Ctrl+R\" must be held down for to terminate, shutdown and reboot the computer\
* textutils.serialiseJSON() now takes an optional parameter allowing it to produce JSON text with unquoted object keys. This is used by all autogenerated methods in the \"commands\" api except for \"title\" and \"tellraw\"\
* Fixed many bugs\
\
New Features in ComputerCraft 1.75:\
\
* Fixed monitors sometimes rendering without part of their text.\
* Fixed a regression in the \"bit\" API.\
\
New Features in ComputerCraft 1.74:\
\
* Added tab completion to \"edit\", \"lua\" and the shell.\
* Added textutils.complete(), fs.complete(), shell.complete(), shell.setCompletionFunction() and help.complete().\
* Added tab completion options to read().\
* Added \"key_up\" and \"mouse_up\" events.\
* Non-advanced terminals now accept both grey colours.\
* Added term.getTextColour(), term.getBackgroundColour() and term.blit().\
* Improved the performance of text rendering on Advanced Computers.\
* Added a \"Run\" button to the edit program on Advanced Computers.\
* Turtles can now push players and entities (configurable).\
* Turtles now respect server spawn protection (configurable).\
* Added a turtle permissions API for mod authors.\
* Implemented a subset of the Lua 5.2 API so programs can be written against it now, ahead of a future Lua version upgrade.\
* Added a config option to disable parts of the Lua 5.1 API which will be removed when a future Lua version upgrade happens.\
* Command Computers can no longer be broken by survival players.\
* Fixed the \"pick block\" key not working on ComputerCraft items in creative mode.\
* Fixed the \"edit\" program being hard to use on certain European keyboards.\
* Added \"_CC_VERSION\" and \"_MC_VERSION\" constants.\
\
New Features in ComputerCraft 1.73:\
\
* The \"exec\" program, commands.exec() and all related Command Computer functions now return the console output of the command.\
* Fixed two multiplayer crash bugs.\
\
New Features in ComputerCraft 1.7:\
\
* Added Command Computers\
* Added new API: commands\
* Added new programs: commands, exec\
* Added textutils.serializeJSON()\
* Added ILuaContext.executeMainThreadTask() for peripheral developers\
* Disk Drives and Printers can now be renamed with Anvils\
* Fixed various bugs, crashes and exploits\
* Fixed problems with HD texture packs\
* Documented the new features in the in-game help\
\
New Features in ComputerCraft 1.65:\
\
* Fixed a multiplayer-only crash with turtle.place()\
* Fixed some problems with http.post()\
* Fixed fs.getDrive() returning incorrect results on remote peripherals\
\
New Features in ComputerCraft 1.64:\
\
* Ported to Minecraft 1.7.10\
* New turtle functions: turtle.inspect(), turtle.inspectUp(), turtle.inspectDown(), turtle.getItemDetail()\
* Lots of bug and crash fixes, a huge stability improvement over previous versions\
\
New Features in ComputerCraft 1.63:\
\
* Turtles can now be painted with dyes, and cleaned with water buckets\
* Added a new game: Redirection - ComputerCraft Edition\
* Turtle label nameplates now only show when the Turtle is moused-over\
* The HTTP API is now enabled by default, and can be configured with a whitelist of permitted domains\
* http.get() and http.post() now accept parameters to control the request headers\
* New fs function: fs.getDir( path )\
* Fixed some bugs\
\
New Features in ComputerCraft 1.62:\
\
* Added IRC-style commands to the \"chat\" program\
* Fixed some bugs and crashes\
\
New Features in ComputerCraft 1.6:\
\
* Added Pocket Computers\
* Added a multi-tasking system for Advanced Computers and Turtles\
* Turtles can now swap out their tools and peripherals at runtime\
* Turtles can now carry two tools or peripherals at once in any combination\
* Turtles and Computers can now be labelled using Name Tags and Anvils\
* Added a configurable fuel limit for Turtles\
* Added hostnames, protocols and long distance routing to the rednet API\
* Added a peer-to-peer chat program to demonstrate new rednet capabilities\
* Added a new game, only on Pocket Computers: \"falling\" by GopherATL\
* File system commands in the shell now accept wildcard arguments\
* The shell now accepts long arguments in quotes\
* Terminal redirection now no longer uses a stack-based system. Instead: term.current() gets the current terminal object and term.redirect() replaces it. term.restore() has been removed.\
* Added a new Windowing API for addressing sub-areas of the terminal\
* New programs: fg, bg, multishell, chat, repeat, redstone, equip, unequip\
* Improved programs: copy, move, delete, rename, paint, shell\
* Removed programs: redset, redprobe, redpulse\
* New APIs: window, multishell\
* New turtle functions: turtle.equipLeft() and turtle.equipRight()\
* New peripheral functions: peripheral.find( [type] )\
* New rednet functions: rednet.host( protocol, hostname ), rednet.unhost( protocol ), rednet.locate( protocol, [hostname] )\
* New fs function: fs.find( wildcard )\
* New shell functions: shell.openTab(), shell.switchTab( [number] )\
* New event \"term_resize\" fired when the size of a terminal changes\
* Improved rednet functions: rednet.send(), rednet.broadcast() and rednet.receive() now take optional protocol parameters\
* turtle.craft(0) and turtle.refuel(0) now return true if there is a valid recipe or fuel item, but do not craft of refuel anything\
* turtle.suck( [limit] ) can now be used to limit the number of items picked up\
* Users of turtle.dig() and turtle.attack() can now specify which side of the turtle to look for a tool to use (by default, both will be considered)\
* textutils.serialise( text ) now produces human-readable output\
* Refactored most of the codebase and fixed many old bugs and instabilities, turtles should never ever lose their content now\
* Fixed the \"turtle_inventory\" event firing when it shouldn't have\
* Added error messages to many more turtle functions after they return false\
* Documented all new programs and API changes in the \"help\" system\
\
New Features in ComputerCraft 1.58:\
\
* Fixed a long standing bug where turtles could lose their identify if they travel too far away\
* Fixed use of deprecated code, ensuring mod compatibility with the latest versions of Minecraft Forge, and world compatibility with future versions of Minecraft\
\
New Features in ComputerCraft 1.57:\
\
* Ported to Minecraft 1.6.4\
* Added two new Treasure Disks: Conway's Game of Life by vilsol and Protector by fredthead\
* Fixed a very nasty item duplication bug\
\
New Features in ComputerCraft 1.56:\
\
* Added Treasure Disks: Floppy Disks in dungeons which contain interesting community made programs. Find them all!\
* All turtle functions now return additional error messages when they fail.\
* Resource Packs with Lua Programs can now be edited when extracted to a folder, for easier editing.\
\
New Features in ComputerCraft 1.55:\
\
* Ported to Minecraft 1.6.2\
* Added Advanced Turtles\
* Added \"turtle_inventory\" event. Fires when any change is made to the inventory of a turtle\
* Added missing functions io.close, io.flush, io.input, io.lines, io.output\
* Tweaked the screen colours used by Advanced Computers, Monitors and Turtles\
* Added new features for Peripheral authors\
* Lua programs can now be included in Resource Packs\
\
New Features in ComputerCraft 1.52:\
\
* Ported to Minecraft 1.5.1\
\
New Features in ComputerCraft 1.51:\
\
* Ported to Minecraft 1.5\
* Added Wired Modems\
* Added Networking Cables\
* Made Wireless Modems more expensive to craft\
* New redstone API functions: getAnalogInput(), setAnalogOutput(), getAnalogOutput()\
* Peripherals can now be controlled remotely over wired networks. New peripheral API function: getNames()\
* New event: \"monitor_resize\" when the size of a monitor changes\
* Except for labelled computers and turtles, ComputerCraft blocks no longer drop items in creative mode\
* The pick block function works in creative mode now works for all ComputerCraft blocks\
* All blocks and items now use the IDs numbers assigned by FTB by default\
* Fixed turtles sometimes placing blocks with incorrect orientations\
* Fixed Wireless modems being able to send messages to themselves\
* Fixed turtle.attack() having a very short range\
* Various bugfixes\
\
New Features in ComputerCraft 1.5:\
\
* Redesigned Wireless Modems; they can now send and receive on multiple channels, independent of the computer ID. To use these features, interface with modem peripherals directly. The rednet API still functions as before\
* Floppy Disks can now be dyed with multiple dyes, just like armour\
* The \"excavate\" program now retains fuel in it's inventory, so can run unattended\
* turtle.place() now tries all possible block orientations before failing\
* turtle.refuel(0) returns true if a fuel item is selected\
* turtle.craft(0) returns true if the inventory is a valid recipe\
* The in-game help system now has documentation for all the peripherals and their methods, including the new modem functionality\
* A romantic surprise\
\
New Features in ComputerCraft 1.48:\
\
* Ported to Minecraft 1.4.6\
* Advanced Monitors now emit a \"monitor_touch\" event when right clicked\
* Advanced Monitors are now cheaper to craft\
* Turtles now get slightly less fuel from items\
* Computers can now interact with Command Blocks (if enabled in ComputerCraft.cfg)\
* New API function: os.day()\
* A christmas surprise\
\
New Features in ComputerCraft 1.45:\
\
* Added Advanced Computers\
* Added Advanced Monitors\
* New program: paint by nitrogenfingers\
* New API: paintutils\
* New term functions: term.setBackgroundColor, term.setTextColor, term.isColor\
* New turtle function: turtle.transferTo\
\
New Features in ComputerCraft 1.43:\
\
* Added Printed Pages\
* Added Printed Books\
* Fixed incompatibility with Forge 275 and above\
* Labelled Turtles now keep their fuel when broken\
\
New Features in ComputerCraft 1.42:\
\
* Ported to Minecraft 1.3.2\
* Added Printers\
* Floppy Disks can be dyed different colours\
* Wireless Crafty Turtles can now be crafted\
* New textures\
* New forge config file\
* Bug fixes\
\
New Features in ComputerCraft 1.4:\
\
* Ported to Forge Mod Loader. ComputerCraft can now be ran directly from the .zip without extraction\
* Added Farming Turtles\
* Added Felling Turtles\
* Added Digging Turtles\
* Added Melee Turtles\
* Added Crafty Turtles\
* Added 14 new Turtle Combinations accessible by combining the turtle upgrades above\
* Labelled computers and turtles can now be crafted into turtles or other turtle types without losing their ID, label and data\
* Added a \"Turtle Upgrade API\" for mod developers to create their own tools and peripherals for turtles\
* Turtles can now attack entities with turtle.attack(), and collect their dropped items\
* Turtles can now use turtle.place() with any item the player can, and can interact with entities\
* Turtles can now craft items with turtle.craft()\
* Turtles can now place items into inventories with turtle.drop()\
* Changed the behaviour of turtle.place() and turtle.drop() to only consider the currently selected slot\
* Turtles can now pick up items from the ground, or from inventories, with turtle.suck()\
* Turtles can now compare items in their inventories\
* Turtles can place signs with text on them with turtle.place( [signText] )\
* Turtles now optionally require fuel items to move, and can refuel themselves\
* The size of the the turtle inventory has been increased to 16\
* The size of the turtle screen has been increased\
* New turtle functions: turtle.compareTo( [slotNum] ), turtle.craft(), turtle.attack(), turtle.attackUp(), turtle.attackDown(), turtle.dropUp(), turtle.dropDown(), turtle.getFuelLevel(), turtle.refuel()\
* New disk function: disk.getID()\
* New turtle programs: craft, refuel\
* \"excavate\" program now much smarter: Will return items to a chest when full, attack mobs, and refuel itself automatically\
* New API: keys\
* Added optional Floppy Disk and Hard Drive space limits for computers and turtles\
* New fs function: fs.getFreeSpace( path ), also fs.getDrive() works again\
* The send and receive range of wireless modems now increases with altitude, allowing long range networking from high-altitude computers (great for GPS networks)\
* http.request() now supports https:// URLs\
* Right clicking a Disk Drive with a Floppy Disk or a Record when sneaking will insert the item into the Disk Drive automatically\
* The default size of the computer screen has been increased\
* Several stability and security fixes. LuaJ can now no longer leave dangling threads when a computer is unloaded, turtles can no longer be destroyed by tree leaves or walking off the edge of the loaded map. Computers no longer crash when used with RedPower frames.\
\
New Features in ComputerCraft 1.31:\
\
* Ported to Minecraft 1.2.3\
* Added Monitors (thanks to Cloudy)\
* Updated LuaJ to a newer, less memory hungry version\
* rednet_message event now has a third parameter, \"distance\", to support position triangulation.\
* New programs: gps, monitor, pastebin.\
* Added a secret program. Use with large monitors!\
* New apis: gps, vector\
* New turtle functions: turtle.compare(), turtle.compareUp(), turtle.compareDown(), turtle.drop( quantity )\
* New http functions: http.post().\
* New term functions: term.redirect(), term.restore()\
* New textutils functions: textutils.urlEncode()\
* New rednet functions: rednet.isOpen()\
* New config options: modem_range, modem_rangeDuringStorm\
* Bug fixes, program tweaks, and help updates\
\
New Features in ComputerCraft 1.3:\
\
* Ported to Minecraft Forge\
* Added Turtles\
* Added Wireless Modems\
* Added Mining Turtles\
* Added Wireless Turtles\
* Added Wireless Mining Turtles\
* Computers and Disk Drives no longer get destroyed by water.\
* Computers and Turtles can now be labelled with the label program, and labelled devices keep their state when destroyed.\
* Computers/Turtles can connect to adjacent devices, and turn them on and off\
* User programs now give line numbers in their error messages\
* New APIs: turtle, peripheral\
* New programs for turtles: tunnel, excavate, go, turn, dance\
* New os functions: os.getComputerLabel(), os.setComputerLabel()\
* Added \"filter\" parameter to os.pullEvent()\
* New shell function: shell.getCurrentProgram()\
* New textutils functions: textutils.serialize(), textutils.unserialize(), textutils.tabulate(), textutils.pagedTabulate(), textutils.slowWrite()\
* New io file function: file:lines()\
* New fs function: fs.getSize()\
* Disk Drives can now play records from other mods\
* Bug fixes, program tweaks, and help updates\
\
New Features in ComputerCraft 1.2:\
\
* Added Disk Drives and Floppy Disks\
* Added Ctrl+T shortcut to terminate the current program (hold)\
* Added Ctrl+S shortcut to shutdown the computer (hold)\
* Added Ctrl+R shortcut to reboot the computer (hold)\
* New Programs: alias, apis, copy, delete, dj, drive, eject, id, label, list, move, reboot, redset, rename, time, worm.\
* New APIs: bit, colours, disk, help, rednet, parallel, textutils.\
* New color functions: colors.combine(), colors.subtract(), colors.test()\
* New fs functions: fs.getName(), new modes for fs.open()\
* New os functions: os.loadAPI(), os.unloadAPI(),\
os.clock(), os.time(), os.setAlarm(),\
os.reboot(), os.queueEvent()\
* New redstone function: redstone.getSides()\
* New shell functions: shell.setPath(), shell.programs(), shell.resolveProgram(), shell.setAlias()\
* Lots of updates to the help pages\
* Bug fixes\
\
New Features in ComputerCraft 1.1:\
\
* Added Multiplayer support throughout.\
* Added connectivity with RedPower bundled cables\
* Added HTTP api, enabled via the mod config, to allow computers to access the real world internet\
* Added command history to the shell.\
* Programs which spin in an infinite loop without yielding will no longer freeze minecraft\
* Help updates and bug fixes\
\
New Features in ComputerCraft 1.0:\
\
* First Release!",
      "Surf the rednet superhighway with \"chat\", the networked chat program for CraftOS! Host chatrooms and invite your friends! Requires a Wired or Wireless Modem on each computer. When running chat, type \"/help\" to see a list of available commands.\
\
ex:\
\"chat host forgecraft\" will create a chatroom with the name \"forgecraft\"\
\"chat join forgecraft direwolf20\" will connect to the chatroom with the name \"forgecraft\", using the nickname \"direwolf20\"",
      "clear clears the screen.",
      "Functions in the colors api\
(used for redstone.setBundledOutput):\
colors.combine( color1, color2, color3, ... )\
colors.subtract( colors, color1, color2, ... )\
colors.test( colors, color )\
\
Color constants in the colors api, in ascending bit order:\
colors.white, colors.orange, colors.magenta, colors.lightBlue, colors.yellow, colors.lime, colors.pink, colors.gray, colors.lightGray, colors.cyan, colors.purple, colors.blue, colors.brown, colors.green, colors.red, colors.black.",
      "Functions in the colours api\
(used for redstone.setBundledOutput):\
colours.combine( colour1, colour2, colour3, ...)\
colours.subtract( colours, colour1, colour2, ...)\
colours.test( colours, colour )\
\
Colour constants in the colours api, in ascending bit order:\
colours.white, colours.orange, colours.magenta, colours.lightBlue, colours.yellow, colours.lime, colours.pink, colours.grey, colours.lightGrey, colours.cyan, colours.purple, colours.blue, colours.brown, colours.green, colours.red, colours.black.",
      "On a Command Computer, \"commands\" will list all the commands available for use. Use \"exec\" to execute them.\
Type \"help commandsapi\" for help using commands in lua programs.",
      "Functions in the commands API:\
commands.exec( command )\
commands.execAsync( command )\
commands.list()\
commands.getBlockPosition()\
commands.getBlockInfo( x, y, z )\
commands.getBlockInfos( minx, miny, minz, maxx, maxy, maxz )\
\
The commands API can also be used to invoke commands directly, like so:\
commands.say( \"Hello World\" )\
commands.give( \"dan200\", \"minecraft:diamond\", 64 )\
This works with any command. Use \"commands.async\" instead of \"commands\" to execute asynchronously.\
\
The commands API is only available on Command Computers.\
Visit http://minecraft.gamepedia.com/Commands for documentation on all commands.",
      "cp copies a file or directory from one location to another.\
\
ex:\
\"cp rom myrom\" copies \"rom\" to \"myrom\".\
\"cp rom mystuff/rom\" copies \"rom\" to \"mystuff/rom\".\
\"cp disk/* disk2\" copies the contents of one disk to another",
      "coroutine is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "craft is a program for Crafty Turtles. Craft will craft a stack of items using the current inventory.\
\
ex:\
\"craft\" will craft as many items as possible\
\"craft 5\" will craft at most 5 times",
      "ComputerCraft was created by Daniel \"dan200\" Ratcliffe, with additional code by Aaron \"Cloudy\" Mills.\
Thanks to nitrogenfingers, GopherATL and RamiLego for program contributions.\
Thanks to Mojang, the Forge team, and the MCP team.\
Uses LuaJ from http://luaj.sourceforge.net/\
\
The ComputerCraft 1.76 update was sponsored by MinecraftU and Deep Space.\
Visit http://www.minecraftu.org and http://www.deepspace.me/space-cadets to find out more.\
\
Join the ComputerCraft community online at http://www.computercraft.info\
Follow @DanTwoHundred on Twitter!",
      "dance is a program for Turtles. Turtles love to get funky.",
      "rm deletes a file or a directory and its contents.\
\
ex:\
\"rm foo\" will delete the file foo.\
\"rm disk/*\" will delete the contents of a disk.",
      "Functions in the disk API. These functions are for interacting with disk drives:\
disk.isPresent( drive )\
disk.setLabel( drive, label )\
disk.getLabel( drive )\
disk.hasData( drive )\
disk.getMountPath( drive )\
disk.hasAudio( drive )\
disk.getAudioTitle( drive )\
disk.playAudio( drive )\
disk.stopAudio( )\
disk.eject( drive )\
disk.getID( drive )\
\
Events fired by the disk API:\
\"disk\" when a disk or other item is inserted into a disk drive. Argument is the name of the drive\
\"disk_eject\" when a disk is removed from a disk drive. Argument is the name of the drive\
Type \"help events\" to learn about the event system.",
      "dj plays Music Discs from disk drives attached to the computer.\
\
ex:\
\"dj\" or \"dj play\" plays a random disc.\
\"dj play left\" plays the disc in the drive on the left of the computer.\
\"dj stop\" stops the current disc.",
      "drive tells you which disk drive the current or specified directory is located in.\
\
ex:\
\"drive\" tell you the disk drive of the current directory.\
\"drive foo\" tells you the disk drive of the subdirectory \"foo\"",
      "The Disk Drive is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Disk Drive is connected, peripheral.getType() will return \"drive\".\
\
Methods exposed by the Disk Drive:\
isDiskPresent()\
getDiskLabel()\
setDiskLabel( label )\
hasData()\
getMountPath()\
hasAudio()\
getAudioTitle()\
playAudio()\
stopAudio()\
ejectDisk()\
getDiskID()\
\
Events fired by the Disk Drive:\
\"disk\" when a disk or other item is inserted into the drive. Argument is the name of the drive.\
\"disk_eject\" when a disk is removed from a  drive. Argument is the name of the drive.\
Type \"help events\" to learn about the event system.",
      "Mostly harmless.",
      "edit is a text editor for creating or modifying programs or text files. After creating a program with edit, type its filename in the shell to run it. You can open any of the builtin programs with edit to learn how to program.\
\
ex:\
\"edit hello\" opens a file called \"hello\" for editing.",
      "eject ejects the contents of an attached disk drive.\
\
ex:\
\"eject left\" ejects the contents of the disk drive to the left of the computer.",
      "equip is a program for Turtles. equip will equip an item from the Turtle's inventory for use as a tool of peripheral.\
\
ex:\
\"equip 5 left\" will equip the item from slot 5 of the turtle onto the left side of the turtle",
      "The function os.pullEvent() will yield the program until a system event occurs. The first return value is the event name, followed by any arguments.\
\
Some events which can occur are:\
\"char\" when text is typed on the keyboard. Argument is the character typed.\
\"key\" when a key is pressed on the keyboard. Arguments are the keycode and whether the key is a repeat. Compare the keycode to the values in keys API to see which key was pressed.\
\"key_up\" when a key is released on the keyboard. Argument is the numerical keycode. Compare to the values in keys API to see which key was released.\
\"paste\" when text is pasted from the users keyboard. Argument is the line of text pasted.\
\
Events only on advanced computers:\
\"mouse_click\" when a user clicks the mouse. Arguments are button, xPos, yPos.\
\"mouse_drag\" when a user moves the mouse when held. Arguments are button, xPos, yPos.\
\"mouse_up\" when a user releases the mouse button. Arguments are button, xPos, yPos.\
\"mouse_scroll\" when a user uses the scrollwheel on the mouse. Arguments are direction, xPos, yPos.\
\
Other APIs and peripherals will emit their own events. See their respective help pages for details.",
      "excavate is a program for Mining Turtles. When excavate is run, the turtle will mine a rectangular shaft into the ground, collecting blocks as it goes, and return to the surface once bedrock is hit.\
\
ex:\
\"excavate 3\" will mine a 3x3 shaft.",
      "On a Command Computer, \"exec\" will execute a command as if entered on a command block. Use \"commands\" to list all the available commands.\
\
ex:\
\"exec say Hello World\"\
\"exec setblock ~0 ~1 ~0 minecraft:dirt\"\
\
Type \"help commandsapi\" for help using commands in lua programs.",
      "exit will exit the current shell.",
      "\"From Russia with Fun\" comes a fun, new, suspiciously-familiar falling block game for CraftOS. Only on Pocket Computers!",
      "fg is a program for Advanced Computers which opens a new tab in the foreground.\
\
ex:\
\"fg\" will open a foreground tab running the shell\
\"fg worm\" will open a foreground tab running the \"worm\" program",
      "Functions in the Filesystem API:\
fs.list( path )\
fs.find( wildcard )\
fs.exists( path )\
fs.isDir( path )\
fs.isReadOnly( path )\
fs.getDir( path )\
fs.getName( path )\
fs.getSize( path )\
fs.getDrive( path )\
fs.getFreeSpace( path )\
fs.makeDir( path )\
fs.move( path, path )\
fs.copy( path, path )\
fs.delete( path )\
fs.combine( path, localpath )\
fs.open( path, mode )\
fs.complete( path, location )\
Available fs.open() modes are \"r\", \"w\", \"a\", \"rb\", \"wb\" and \"ab\".\
\
Functions on files opened with mode \"r\":\
readLine()\
readAll()\
close()\
\
Functions on files opened with mode \"w\" or \"a\":\
write( string )\
writeLine( string )\
flush()\
close()\
\
Functions on files opened with mode \"rb\":\
read()\
close()\
\
Functions on files opened with mode \"wb\" or \"ab\":\
write( byte )\
flush()\
close()",
      "go is a program for Turtles, used to control the turtle without programming. It accepts one or more commands as a direction followed by a distance.\
\
ex:\
\"go forward\" moves the turtle 1 space forward.\
\"go forward 3\" moves the turtle 3 spaces forward.\
\"go forward 3 up left 2\" moves the turtle 3 spaces forward, 1 spaces up, then left 180 degrees.",
      "gps can be used to host a GPS server, or to determine a position using trilateration.\
Type \"help gpsapi\" for help using GPS functions in lua programs.\
\
ex:\
\"gps locate\" will connect to nearby GPS servers, and try to determine the position of the computer or turtle.\
\"gps host\" will try to determine the position, and host a GPS server if successful.\
\"gps host 10 20 30\" will host a GPS server, using the manually entered position 10,20,30. \
\
Take care when manually entering host positions. If the positions entered into multiple GPS hosts\
are not consistent, the results of locate calls will be incorrect.",
      "Functions in the GPS API:\
gps.locate( timeout )\
\
The locate function will send a signal to nearby gps servers, and wait for responses before the timeout. If it receives enough responses to determine this computers position then x, y and z co-ordinates will be returned, otherwise it will return nil. If GPS hosts do not have their positions configured correctly, results will be inaccurate.",
      "hello prints the text \"Hello World!\" to the screen.",
      "help is the help tool you're currently using.\
Type \"help index\" to see all help topics.\
Type \"help\" to see the help intro.\
Type \"help helpapi\" for information on the help Lua API.",
      "Functions in the help API:\
help.setPath( path )\
help.lookup( topic )\
help.topics()\
help.completeTopic( topic )",
      "Functions in the HTTP API:\
http.checkURL( url )\
http.request( url, [postData], [headers] )\
http.get( url, [headers] )\
http.post( url, postData, [headers] )\
\
The HTTP API may be disabled in ComputerCraft.cfg\
A period of time after a http.request() call is made, a \"http_success\" or \"http_failure\" event will be raised. Arguments are the url and a file handle if successful. http.get() and http.post() block until this event fires instead.",
      "id prints the unique identifier of this computer, or a Disk in an attached Disk Drive.\
\
ex:\
\"id\" will print this Computers ID and label\
\"id left\" will print the ID and label of the disk in the Disk Drive on the left",
      "Welcome to CraftOS!\
Type \"programs\" to see the programs you can run.\
Type \"help <program>\" to see help for a specific program.\
Type \"help programming\" to learn about programming.\
Type \"help whatsnew\" to find out about new features.\
Type \"help credits\" to learn who made all this.\
Type \"help index\" to see all help topics.",
      "io is a standard Lua5.1 API, reimplemented for CraftOS. Not all the features are availiable.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "The keys API contains constants for all the key codes that can be returned by the \"key\" event:\
\
Example usage:\
local sEvent, nKey = os.pullEvent()\
if sEvent == \"key\" and nKey == keys.enter then\
   -- Do something  \
end\
\
See http://www.minecraftwiki.net/wiki/Key_codes, or the source code, for a complete reference.",
      "label gets or sets the label of the Computer, or of Floppy Disks in attached disk drives.\
\
ex:\
\"label get\" prints the label of the computer.\
\"label get left\" prints the label of the disk in the left drive.\
\"label set \"My Computer\"\" set the label of the computer to \"My Computer\".\
\"label set left \"My Programs\"\" - sets the label of the disk in the left drive to \"My Programs\".\
\"label clear\" clears the label of the computer.\
\"label clear left\" clears the label of the disk in the left drive.",
      "Copyright (c) 2007 LuaJ. All rights reserved.\
\
Permission is hereby granted, free of charge, to any person obtaining a copy\
of this software and associated documentation files (the \"Software\"), to deal\
in the Software without restriction, including without limitation the rights\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\
copies of the Software, and to permit persons to whom the Software is\
furnished to do so, subject to the following conditions:\
\
The above copyright notice and this permission notice shall be included in\
all copies or substantial portions of the Software.\
\
THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\
THE SOFTWARE.",
      "ls will list all the directories and files in the current location. Use \"type\" to find out if an item is a file or a directory.",
      "lua is an interactive prompt for the lua programming language. It's a useful tool for learning the language.",
      "math is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "mkdir creates a directory in the current location.\
\
ex:\
\"mkdir foo\" creates a directory named \"foo\".\
\"mkdir ../foo\" creates a directory named \"foo\" in the directory above the current directory.",
      "Wired and Wireless Modems are peripheral devices available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Modem is connected, peripheral.getType() will return \"modem\".\
\
Methods exposed by Modems:\
open( channel )\
isOpen( channel )\
close( channel )\
closeAll()\
transmit( channel, replyChannel, message )\
isWireless()\
\
Events fired by Modems:\
\"modem_message\" when a message is received on an open channel. Arguments are name, channel, replyChannel, message, distance",
      "monitor will connect to an attached Monitor peripheral, and run a program on its display.\
Type \"help monitors\" for help using monitors as peripherals in lua programs.\
\
ex:\
\"monitor left hello\" will run the \"hello\" program on the monitor to the left of the computer.\
\"monitor top edit foo\" will run the edit program on the top monitor, editing the file \"foo\".",
      "The Monitor is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Monitor is connected, peripheral.getType() will return \"monitor\". A wrapped monitor can be used with term.redirect() to send all terminal output to the monitor.\
\
Methods exposed by the Monitor:\
write( text )\
blit( text, textColor, backgroundColor )\
clear()\
clearLine()\
getCursorPos()\
setCursorPos( x, y )\
setCursorBlink( blink )\
isColor()\
setTextColor( color )\
setBackgroundColor( color )\
getTextColor()\
getBackgroundColor()\
getSize()\
scroll( n )\
\
Events fired by the Monitor:\
\"monitor_touch\" when an Advanced Monitor is touched by the player. Arguments are name, x, y\
\"monitor_resize\" when the size of a Monitor changes. Argument is the name of the monitor.",
      "mv moves a file or directory from one location to another.\
\
ex:\
\"mv foo bar\" renames the file \"foo\" to \"bar\".\
\"mv foo bar/foo\" moves the file \"foo\" to a folder called \"bar\".\
\"mv disk/* disk2\" moves the contents of one disk to another",
      "multishell is the toplevel program on Advanced Computers which manages background tabs.\
Type \"help shellapi\" for information about the shell lua api.",
      "Functions in the os (Operating System) API:\
os.version()\
os.getComputerID()\
os.getComputerLabel()\
os.setComputerLabel()\
os.run( environment, programpath, arguments )\
os.loadAPI( path )\
os.unloadAPI( name )\
os.pullEvent( [filter] )\
os.queueEvent( event, arguments )\
os.clock()\
os.startTimer( timeout )\
os.cancelTimer( token )\
os.sleep( timeout )\
os.time()\
os.day()\
os.setAlarm( time )\
os.cancelAlarm( token )\
os.shutdown()\
os.reboot()\
\
Events emitted by the os API:\
\"timer\" when a timeout started by os.startTimer() completes. Argument is the token returned by os.startTimer().\
\"alarm\" when a time passed to os.setAlarm() is reached. Argument is the token returned by os.setAlarm().\
Type \"help events\" to learn about the event system.",
      "paint is a program for creating images on Advanced Computers. Select colors from the color pallette on the right, and click on the canvas to draw. Press Ctrl to access the menu and save your pictures.\
\
ex:\
\"edit mario\" opens an image called \"mario\" for editing.",
      "Functions in the Paint Utilities API:\
paintutils.drawPixel( x, y, colour )\
paintutils.drawLine( startX, startY, endX, endY, colour )\
paintutils.drawBox( startX, startY, endX, endY, colour )\
paintutils.drawFilledBox( startX, startY, endX, endY, colour )\
paintutils.loadImage( path )\
paintutils.drawImage( image, x, y )",
      "Functions in the Parallel API:\
parallel.waitForAny( function1, function2, ... )\
parallel.waitForAll( function1, function2, ... )\
These methods provide an easy way to run multiple lua functions simultaneously.",
      "pastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.\
The HTTP API must be enabled in ComputerCraft.cfg to use this program.\
\
ex:\
\"pastebin put foo\" will upload the file \"foo\" to pastebin.com, and print the URL.\
\"pastebin get xq5gc7LB foo\" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as \"foo\".\
\"pastebin run CxaWmPrX\" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.",
      "The peripheral API is for interacting with external peripheral devices. Type \"help peripherals\" to learn about the peripherals available.\
\
Functions in the peripheral API:\
peripheral.getNames()\
peripheral.isPresent( name )\
peripheral.getType( name )\
peripheral.getMethods( name )\
peripheral.call( name, methodName, param1, param2, etc )\
peripheral.wrap( name )\
peripheral.find( type, [fnFilter] )\
\
Events fired by the peripheral API:\
\"peripheral\" when a new peripheral is attached. Argument is the name.\
\"peripheral_detach\" when a peripheral is removed. Argument is the name.\
Type \"help events\" to learn about the event system.",
      "The \"peripherals\" program will list all of the peripheral devices accessible from this computer.\
Peripherals are external devices which CraftOS Computers and Turtles can interact with using the peripheral API.\
Type \"help peripheral\" to learn about using the peripheral API.\
Type \"help drives\" to learn about using Disk Drives.\
Type \"help modems\" to learn about using Modems.\
Type \"help monitors\" to learn about using Monitors.\
Type \"help printers\" to learn about using Printers.",
      "The Printer is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Printer is connected, peripheral.getType() will return \"printer\".\
\
Methods exposed by the Printer:\
getInkLevel()\
getPaperLevel()\
newPage()\
setPageTitle( title )\
getPageSize()\
setCursorPos( x, y )\
getCursorPos()\
write( text )\
endPage()",
      "To learn the lua programming language, visit http://lua-users.org/wiki/TutorialDirectory.\
\
To experiment with lua in CraftOS, run the \"lua\" program and start typing code.\
To create programs, use \"edit\" to create files, then type their names in the shell to run them. If you name a program \"startup\" and place it in the root or on a disk drive, it will run automatically when the computer starts.\
\
To terminate a program stuck in a loop, hold Ctrl+T for 1 second.\
To quickly shutdown a computer, hold Ctrl+S for 1 second.\
To quickly reboot a computer, hold Ctrl+R for 1 second.\
\
To learn about the programming APIs availiable, type \"apis\" or \"help apis\".\
If you get stuck, visit the forums at http://www.computercraft.info/ for advice and tutorials.",
      "programs lists all the programs on the rom of the computer.",
      "reboot will turn the computer off and on again.\
You can also hold Ctrl+R at any time to quickly reboot.",
      "Redirection ComputerCraft Edition is the CraftOS version of a fun new puzzle game by Dan200, the author of ComputerCraft.\
Play it on any Advanced Computer, then visit http://www.redirectiongame.com to play the full game!",
      "The rednet API provides a simple computer networking model using modems.\
\
Functions in the rednet API:\
rednet.open( side )\
rednet.close( [side] )\
rednet.isOpen( [side] )\
rednet.send( receiverID, message, [protocol] ) -- Send to a specific computer\
rednet.broadcast( message, [protocol] ) -- Send to all computers\
rednet.receive( [protocol], [timeout] ) -- Returns: senderID, message, protocol\
rednet.host( protocol, hostname )\
rednet.unhost( protocol )\
rednet.lookup( protocol, [hostname] ) -- Returns: ID\
\
Events fired by the rednet API:\
\"rednet_message\" when a message is received. Arguments are senderID, message, protocol\
Type \"help events\" to learn about the event system.\
\
Rednet is not the only way to use modems for networking. Interfacing with the modem directly using the peripheral API and listening for the \"modem_message\" event allows for lower level control, at the expense of powerful high level networking features.",
      "The redstone program can be used to get, set or pulse redstone inputs and outputs from the computer.\
\
ex:\
\"redstone probe\" will list all the redstone inputs to the computer\
\"redstone set left true\" turns on the left redstone output.\
\"redstone set right blue false\" turns off the blue wire in the bundled cable on the right redstone output.\
\"redstone pulse front 10 1\" emits 10 one second redstone pulses on the front redstone output.\
\
Type \"help redstoneapi\" or \"help rs\" for information on the redstone Lua API.",
      "Functions in the Redstone API:\
redstone.getSides( )\
redstone.getInput( side )\
redstone.setOutput( side, boolean )\
redstone.getOutput( side )\
redstone.getAnalogInput( side )\
redstone.setAnalogOutput( side, number )\
redstone.getAnalogOutput( side )\
\
Functions in the Redstone API for working with bundled cables:\
redstone.getBundledInput( side )\
redstone.testBundledInput( side, color )\
redstone.setBundledOutput( side, colors )\
redstone.getBundledOutput( side )\
Type \"help bundled\" for usage examples.\
\
Events emitted by the redstone API:\
\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\
Type \"help events\" to learn about the event system.",
      "refuel is a program for Turtles. Refuel will consume items from the inventory as fuel for turtle.\
\
ex:\
\"refuel\" will refuel with at most one fuel item\
\"refuel 10\" will refuel with at most 10 fuel items\
\"refuel all\" will refuel with as many fuel items as possible",
      "rename renames a file or directory.\
\
ex:\
\"rename foo bar\" renames the file \"foo\" to \"bar\".",
      "repeat is a program for repeating rednet messages across long distances. To use, connect 2 or more modems to a computer and run the \"repeat\" program; from then on, any rednet message sent from any computer in wireless range or connected by networking cable to either of the modems will be repeated to those on the other side.",
      "Functions in the Redstone API:\
rs.getSides( )\
rs.getInput( side )\
rs.setOutput( side, boolean )\
rs.getOutput( side )\
rs.getAnalogInput( side )\
rs.setAnalogOutput( side, number )\
rs.getAnalogOutput( side )\
\
Functions in the Redstone API for working with RedPower bundled cables:\
rs.getBundledInput( side )\
rs.testBundledInput( side, color )\
rs.setBundledOutput( side, colors )\
rs.getBundledOutput( side )\
Type \"help bundled\" for usage examples.\
\
Events emitted by the redstone API:\
\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\
Type \"help events\" to learn about the event system.",
      "The set program can be used to inspect and change system settings.\
\
Usage:\
\"set\" will print all the system settings and their values\
\"set foo\" will print the value of the system setting \"foo\"\
\"set foo bar\" will set the value of the system setting \"foo\" to \"bar\"",
      "Functions in the Settings API:\
settings.get( name, [default] )\
settings.set( name, value )\
settings.unset( name )\
settings.load( path )\
settings.save( path )\
settings.clear()\
settings.getNames()",
      "shell is the toplevel program which interprets commands and runs program.\
Type \"help shellapi\" for information about the shell lua api.",
      "Functions in the Shell API:\
shell.exit()\
shell.dir()\
shell.setDir( path )\
shell.path()\
shell.setPath( path )\
shell.resolve( localpath )\
shell.resolveProgram( name )\
shell.aliases()\
shell.setAlias( alias, command )\
shell.clearAlias( alias )\
shell.programs()\
shell.run( program, arguments )\
shell.getRunningProgram()\
shell.complete( line )\
shell.completeProgram( program )\
shell.setCompletionFunction( program, fnComplete )\
shell.openTab( program, arguments ) (Advanced Computer required)\
shell.switchTab( n ) (Advanced Computer required)",
      "shutdown will turn off the computer.",
      "sleep makes the computer idle for a specific number of seconds.\
\
ex:\
\"sleep 10\" puts the computer to sleep for 10 seconds",
      "string is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "table is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "Functions in the Terminal API:\
term.write( text )\
term.blit( text, textColor, backgroundColor )\
term.clear()\
term.clearLine()\
term.getCursorPos()\
term.setCursorPos( x, y )\
term.setCursorBlink( blink )\
term.isColor()\
term.setTextColor( color )\
term.setBackgroundColor( color )\
term.getTextColor()\
term.getBackgroundColor()\
term.getSize()\
term.scroll( n )\
term.redirect( object )\
term.current()\
\
Events emitted by the terminals:\
\"term_resize\", when the size of a terminal changes. This can happen in multitasking environments, or when the terminal out is being redirected by the \"monitor\" program.",
      "Functions in the Text Utilities API:\
textutils.slowPrint( text )\
textutils.tabulate( table, table2, ... )\
textutils.pagedTabulate( table, table2, ... )\
textutils.formatTime( time, bTwentyFourHour )\
textutils.serialize( table )\
textutils.unserialize( string )\
textutils.serializeJSON( table, [useNBTStyle] )\
textutils.urlEncode( string )\
textutils.complete( string, table )",
      "time prints the current time of day.",
      "tunnel is a program for Mining Turtles. Tunnel will mine a 3x2 tunnel of the depth specified.\
\
ex:\
\"tunnel 20\" will tunnel a tunnel 20 blocks long.",
      "turn is a program for Turtles, used to turn the turtle around without programming. It accepts one or more commands as a direction and a number of turns. The \"go\" program can also be used for turning.\
\
ex:\
\"turn left\" turns the turtle 90 degrees left.\
\"turn right 2\" turns the turtle 180 degrees right.\
\"turn left 2 right\" turns left 180 degrees, then right 90 degrees.",
      "turtle is an api availiable on Turtles, which controls their movement.\
Functions in the Turtle API:\
turtle.forward()\
turtle.back()\
turtle.up()\
turtle.down()\
turtle.turnLeft()\
turtle.turnRight()\
turtle.select( slotNum )\
turtle.getSelectedSlot()\
turtle.getItemCount( [slotNum] )\
turtle.getItemSpace( [slotNum] )\
turtle.getItemDetail( [slotNum] )\
turtle.equipLeft()\
turtle.equipRight()\
turtle.dig( [toolSide] )\
turtle.digUp( [toolSide] )\
turtle.digDown( [toolSide] )\
turtle.place()\
turtle.placeUp()\
turtle.placeDown()\
turtle.attack( [toolSide] )\
turtle.attackUp( [toolSide] )\
turtle.attackDown( [toolSide] )\
turtle.detect()\
turtle.detectUp()\
turtle.detectDown()\
turtle.compare()\
turtle.compareUp()\
turtle.compareDown()\
turtle.inspect()\
turtle.inspectUp()\
turtle.inspectDown()\
turtle.inspectSlot( [slotNum] )\
turtle.compareTo( slotNum )\
turtle.transferTo( slotNum, [quantity] )\
turtle.drop( [quantity] )\
turtle.dropUp( [quantity] )\
turtle.dropDown( [quantity] )\
turtle.suck( [quantity] )\
turtle.suckUp( [quantity] )\
turtle.suckDown( [quantity] )\
turtle.getFuelLevel()\
turtle.getFuelLimit()\
turtle.refuel( [quantity] )\
turtle.craft( [quantity] ) (requires Crafty Turtle)\
\
Events fired by the Turtle API:\
\"turtle_inventory\" when any of the items in the inventory are changed. Use comparison operations to inspect the changes.",
      "type determines the type of a file or directory. Prints \"file\", \"directory\" or \"does not exist\".",
      "unequip is a program for Turtles. unequip will remove tools of peripherals from the specified side of the turtle.\
\
ex:\
\"unequip left\" will remove the item on the left side of the turtle",
      "Functions in the 3D Vector Math API:\
vector.new( x,y,z )\
\
Vectors returned by vector.new() have the following fields and methods:\
vector.x\
vector.y\
vector.z\
vector:add( vector )\
vector:sub( vector )\
vector:mul( number )\
vector:dot( vector )\
vector:cross( vector )\
vector:length()\
vector:normalize()\
vector:round()\
vector:tostring()\
The +, - and * operators can also be used on vectors.",
      "wget is a program for downloading files from the internet. This is useful for downloading programs created by other players.\
The HTTP API must be enabled in ComputerCraft.cfg to use this program.\
\
ex:\
\"wget http://pastebin.com/raw/CxaWmPrX test\" will download the file from the URL http://pastebin.com/raw/CxaWmPrX, and save it as \"test\".",
      "New Features in ComputerCraft 1.79:\
\
* Ported ComputerCraftEdu to Minecraft 1.8.9\
* Fixed a handful of bugs in ComputerCraft\
\
Type \"help changelog\" to see the full version history.",
      "Functions in the window API:\
window.create( parent, x, y, width, height, visible )\
\
Windows created with the window API have the following methods:\
write( text )\
blit( text, textColor, backgroundColor )\
clear()\
clearLine()\
getCursorPos()\
setCursorPos( x, y )\
setCursorBlink( blink )\
isColor()\
setTextColor( color )\
setBackgroundColor( color )\
getTextColor()\
getBackgroundColor()\
getSize()\
scroll( n )\
setVisible( bVisible )\
redraw()\
restoreCursor()\
getPosition()\
reposition( x, y, width, height )",
      "Workbenches are peripheral devices found on Crafty Turtles running CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a workbench is attached to a turtle, peripheral.getType() will return \"workbench\".\
\
Methods exposed by Workbenches:\
craft( channel )",
      "You've played it in the arcades, now experience the high-octane thrills of the hit game \"WORM!\" on your home computer! Only on CraftOS!",
      "\
if not shell.openTab then\
\009printError( \"Requires multishell\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    shell.openTab( table.unpack( tArgs ) )\
else\
    shell.openTab( \"shell\" )\
end",
      "\
if not shell.openTab then\
\009printError( \"Requires multishell\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    local nTask = shell.openTab( table.unpack( tArgs ) )\
    if nTask then\
        shell.switchTab( nTask )\
    end\
else\
    local nTask = shell.openTab( \"shell\" )\
    if nTask then\
        shell.switchTab( nTask )\
    end\
end",
      "\
-- Setup process switching\
local parentTerm = term.current()\
local w,h = parentTerm.getSize()\
\
local tProcesses = {}\
local nCurrentProcess = nil\
local nRunningProcess = nil\
local bShowMenu = false\
local bWindowsResized = false\
\
local function selectProcess( n )\
    if nCurrentProcess ~= n then\
        if nCurrentProcess then\
            local tOldProcess = tProcesses[ nCurrentProcess ]\
            tOldProcess.window.setVisible( false )\
        end\
        nCurrentProcess = n\
        if nCurrentProcess then\
            local tNewProcess = tProcesses[ nCurrentProcess ]\
            tNewProcess.window.setVisible( true )\
            tNewProcess.bInteracted = true\
        end\
    end\
end\
\
local function setProcessTitle( n, sTitle )\
    tProcesses[ n ].sTitle = sTitle\
end\
\
local function resumeProcess( nProcess, sEvent, ... )\
    local tProcess = tProcesses[ nProcess ]\
    local sFilter = tProcess.sFilter\
    if sFilter == nil or sFilter == sEvent or sEvent == \"terminate\" then\
        local nPreviousProcess = nRunningProcess\
        nRunningProcess = nProcess\
        term.redirect( tProcess.terminal )\
        local ok, result = coroutine.resume( tProcess.co, sEvent, ... )\
        tProcess.terminal = term.current()\
        if ok then\
            tProcess.sFilter = result\
        else\
            printError( result )\
        end\
        nRunningProcess = nPreviousProcess\
    end\
end\
\
local function launchProcess( tProgramEnv, sProgramPath, ... )\
    local tProgramArgs = { ... }\
    local nProcess = #tProcesses + 1\
    local tProcess = {}\
    tProcess.sTitle = fs.getName( sProgramPath )\
    if bShowMenu then\
        tProcess.window = window.create( parentTerm, 1, 2, w, h-1, false )\
    else\
        tProcess.window = window.create( parentTerm, 1, 1, w, h, false )\
    end\
    tProcess.co = coroutine.create( function()\
        os.run( tProgramEnv, sProgramPath, table.unpack( tProgramArgs ) )\
        if not tProcess.bInteracted then\
            term.setCursorBlink( false )\
            print( \"Press any key to continue\" )\
            os.pullEvent( \"char\" )\
        end\
    end )\
    tProcess.sFilter = nil\
    tProcess.terminal = tProcess.window\
    tProcess.bInteracted = false\
    tProcesses[ nProcess ] = tProcess\
    resumeProcess( nProcess )\
    return nProcess\
end\
\
local function cullProcess( nProcess )\
    local tProcess = tProcesses[ nProcess ]\
    if coroutine.status( tProcess.co ) == \"dead\" then\
        if nCurrentProcess == nProcess then\
            selectProcess( nil )\
        end\
        table.remove( tProcesses, nProcess )\
        if nCurrentProcess == nil then\
            if nProcess > 1 then\
                selectProcess( nProcess - 1 )\
            elseif #tProcesses > 0 then\
                selectProcess( 1 )\
            end\
        end\
        return true\
    end\
    return false\
end\
\
local function cullProcesses()\
    local culled = false\
    for n=#tProcesses,1,-1 do\
        culled = culled or cullProcess( n )\
    end\
    return culled\
end\
\
-- Setup the main menu\
local menuMainTextColor, menuMainBgColor, menuOtherTextColor, menuOtherBgColor\
if parentTerm.isColor() then\
    menuMainTextColor, menuMainBgColor = colors.yellow, colors.black\
    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\
else\
    menuMainTextColor, menuMainBgColor = colors.white, colors.black\
    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\
end\
\
local function redrawMenu()\
    if bShowMenu then\
        -- Draw menu\
        parentTerm.setCursorPos( 1, 1 )\
        parentTerm.setBackgroundColor( menuOtherBgColor )\
        parentTerm.clearLine()\
        for n=1,#tProcesses do\
            if n == nCurrentProcess then\
                parentTerm.setTextColor( menuMainTextColor )\
                parentTerm.setBackgroundColor( menuMainBgColor )\
            else\
                parentTerm.setTextColor( menuOtherTextColor )\
                parentTerm.setBackgroundColor( menuOtherBgColor )\
            end\
            parentTerm.write( \" \" .. tProcesses[n].sTitle .. \" \" )\
        end\
\
        -- Put the cursor back where it should be\
        local tProcess = tProcesses[ nCurrentProcess ]\
        if tProcess then\
            tProcess.window.restoreCursor()\
        end\
    end\
end\
\
local function resizeWindows()\
    local windowY, windowHeight\
    if bShowMenu then\
        windowY = 2\
        windowHeight = h-1\
    else\
        windowY = 1\
        windowHeight = h\
    end\
    for n=1,#tProcesses do\
        local tProcess = tProcesses[n]\
        local window = tProcess.window\
        local x,y = tProcess.window.getCursorPos()\
        if y > windowHeight then\
            tProcess.window.scroll( y - windowHeight )\
            tProcess.window.setCursorPos( x, windowHeight )\
        end\
        tProcess.window.reposition( 1, windowY, w, windowHeight )\
    end\
    bWindowsResized = true\
end\
\
local function setMenuVisible( bVis )\
    if bShowMenu ~= bVis then\
        bShowMenu = bVis\
        resizeWindows()\
        redrawMenu()\
    end\
end\
\
local multishell = {}\
\
function multishell.getFocus()\
    return nCurrentProcess\
end\
\
function multishell.setFocus( n )\
    if n >= 1 and n <= #tProcesses then\
        selectProcess( n )\
        redrawMenu()\
        return true\
    end\
    return false\
end\
\
function multishell.getTitle( n )\
    if n >= 1 and n <= #tProcesses then\
        return tProcesses[n].sTitle\
    end\
    return nil\
end\
\
function multishell.setTitle( n, sTitle )\
    if n >= 1 and n <= #tProcesses then\
        setProcessTitle( n, sTitle )\
        redrawMenu()\
    end\
end\
\
function multishell.getCurrent()\
    return nRunningProcess\
end\
\
function multishell.launch( tProgramEnv, sProgramPath, ... )\
    local previousTerm = term.current()\
    setMenuVisible( (#tProcesses + 1) >= 2 )\
    local nResult = launchProcess( tProgramEnv, sProgramPath, ... )\
    redrawMenu()\
    term.redirect( previousTerm )\
    return nResult\
end\
\
function multishell.getCount()\
    return #tProcesses\
end\
\
-- Begin\
parentTerm.clear()\
setMenuVisible( false )\
selectProcess( launchProcess( {\
    [\"shell\"] = shell,\
    [\"multishell\"] = multishell,\
}, \"/rom/programs/shell\" ) )\
redrawMenu()\
\
-- Run processes\
while #tProcesses > 0 do\
    -- Get the event\
    local tEventData = { os.pullEventRaw() }\
    local sEvent = tEventData[1]\
    if sEvent == \"term_resize\" then\
        -- Resize event\
        w,h = parentTerm.getSize()\
        resizeWindows()\
        redrawMenu()\
\
    elseif sEvent == \"char\" or sEvent == \"key\" or sEvent == \"key_up\" or sEvent == \"paste\" or sEvent == \"terminate\" then\
        -- Keyboard event\
        -- Passthrough to current process\
        resumeProcess( nCurrentProcess, table.unpack( tEventData ) )\
        if cullProcess( nCurrentProcess ) then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
\
    elseif sEvent == \"mouse_click\" then\
        -- Click event\
        local button, x, y = tEventData[2], tEventData[3], tEventData[4]\
        if bShowMenu and y == 1 then\
            -- Switch process\
            local tabStart = 1\
            for n=1,#tProcesses do\
                tabEnd = tabStart + string.len( tProcesses[n].sTitle ) + 1\
                if x >= tabStart and x <= tabEnd then\
                    selectProcess( n )\
                    redrawMenu()\
                    break\
                end\
                tabStart = tabEnd + 1\
            end\
        else\
            -- Passthrough to current process\
            resumeProcess( nCurrentProcess, sEvent, button, x, (bShowMenu and y-1) or y )\
            if cullProcess( nCurrentProcess ) then\
                setMenuVisible( #tProcesses >= 2 )\
                redrawMenu()\
            end\
        end\
\
    elseif sEvent == \"mouse_drag\" or sEvent == \"mouse_up\" or sEvent == \"mouse_scroll\" then\
        -- Other mouse event\
        local p1, x, y = tEventData[2], tEventData[3], tEventData[4]\
        if not (bShowMenu and y == 1) then\
            -- Passthrough to current process\
            resumeProcess( nCurrentProcess, sEvent, p1, x, (bShowMenu and y-1) or y )\
            if cullProcess( nCurrentProcess ) then\
                setMenuVisible( #tProcesses >= 2 )\
                redrawMenu()\
            end\
        end\
\
    else\
        -- Other event\
        -- Passthrough to all processes\
        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\
        for n=1,nLimit do\
            resumeProcess( n, table.unpack( tEventData ) )\
        end\
        if cullProcesses() then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
    end\
\
    if bWindowsResized then\
        -- Pass term_resize to all processes\
        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\
        for n=1,nLimit do\
            resumeProcess( n, \"term_resize\" )\
        end\
        bWindowsResized = false\
        if cullProcesses() then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
    end\
end\
\
-- Shutdown\
term.redirect( parentTerm )",
      "\
local tArgs = { ... }\
if #tArgs > 2 then\
\009print( \"Usage: alias <alias> <program>\" )\
\009return\
end\
\
local sAlias = tArgs[1]\
local sProgram = tArgs[2]\
\
if sAlias and sProgram then\
\009-- Set alias\
\009shell.setAlias( sAlias, sProgram )\
elseif sAlias then\
\009-- Clear alias\
\009shell.clearAlias( sAlias )\
else\
\009-- List aliases\
\009local tAliases = shell.aliases()\
\009local tList = {}\
\009for sAlias, sCommand in pairs( tAliases ) do\
\009\009table.insert( tList, sAlias )\
\009end\
\009table.sort( tList )\
\009textutils.pagedTabulate( tList )\
end\
\009",
      "\
local tApis = {}\
for k,v in pairs( _G ) do\
\009if type(k) == \"string\" and type(v) == \"table\" and k ~= \"_G\" then\
\009\009table.insert( tApis, k )\
\009end\
end\
table.insert( tApis, \"shell\" )\
table.sort( tApis )\
\
textutils.pagedTabulate( tApis )",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: cd <path>\" )\
\009return\
end\
\
local sNewDir = shell.resolve( tArgs[1] )\
if fs.isDir( sNewDir ) then\
\009shell.setDir( sNewDir )\
else\
  \009print( \"Not a directory\" )\
  \009return\
end",
      "term.clear()\
term.setCursorPos( 1, 1 )",
      "\
if not commands then\
    printError( \"Requires a Command Computer.\" )\
    return\
end\
\
local tCommands = commands.list()\
table.sort( tCommands )\
\
if term.isColor() then\
    term.setTextColor( colors.green )\
end\
print( \"Available commands:\" )\
term.setTextColor( colors.white )\
\
textutils.pagedTabulate( tCommands )",
      "\
local tArgs = { ... }\
if not commands then\
    printError( \"Requires a Command Computer.\" )\
    return\
end\
if #tArgs == 0 then\
    printError( \"Usage: exec <command>\" )\
    return\
end\
\
local function printSuccess( text )\
    if term.isColor() then\
        term.setTextColor( colors.green )\
    end\
    print( text )\
    term.setTextColor( colors.white )\
end\
\
local sCommand = string.lower( tArgs[1] )\
for n=2,#tArgs do\
    sCommand = sCommand .. \" \" .. tArgs[n]\
end\
\
local bResult, tOutput = commands.exec( sCommand )\
if bResult then\
    printSuccess( \"Success\" )\
    if #tOutput > 0 then\
        for n=1,#tOutput do\
            print( tOutput[n] )\
        end\
    end\
else\
    printError( \"Failed\" )\
    if #tOutput > 0 then\
        for n=1,#tOutput do\
            print( tOutput[n] )\
        end\
    end\
end",
      "\
local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: cp <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
local tFiles = fs.find( sSource )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        if fs.isDir( sDest ) then\
            fs.copy( sFile, fs.combine( sDest, fs.getName(sFile) ) )\
        elseif #tFiles == 1 then\
            fs.copy( sFile, sDest )\
        else\
            printError( \"Cannot overwrite file multiple times\" )\
            return\
        end\
    end\
else\
    printError( \"No matching files\" )\
end",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: rm <path>\" )\
\009return\
end\
\
local sPath = shell.resolve( tArgs[1] )\
local tFiles = fs.find( sPath )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        fs.delete( sFile )\
    end\
else\
    printError( \"No matching files\" )\
end",
      "local tArgs = { ... }\
\
-- Get where a directory is mounted\
local sPath = shell.dir()\
if tArgs[1] ~= nil then\
\009sPath = shell.resolve( tArgs[1] )\
end\
\
if fs.exists( sPath ) then\
\009write( fs.getDrive( sPath ) .. \" (\" )\
\009local nSpace = fs.getFreeSpace( sPath )\
\009if nSpace >= 1000 * 1000 then\
\009\009print( (math.floor( nSpace / (100 * 1000) ) / 10) .. \"MB remaining)\" )\
\009elseif nSpace >= 1000 then\
\009\009print( (math.floor( nSpace / 100 ) / 10) .. \"KB remaining)\" )\
\009else\
\009\009print( nSpace .. \"B remaining)\" )\
\009end\
else\
\009print( \"No such path\" )\
end",
      "-- Get file to edit\
local tArgs = { ... }\
if #tArgs == 0 then\
\009print( \"Usage: edit <path>\" )\
\009return\
end\
\
-- Error checking\
local sPath = shell.resolve( tArgs[1] )\
local bReadOnly = fs.isReadOnly( sPath )\
if fs.exists( sPath ) and fs.isDir( sPath ) then\
\009print( \"Cannot edit a directory.\" )\
\009return\
end\
\
local x,y = 1,1\
local w,h = term.getSize()\
local scrollX, scrollY = 0,0\
\
local tLines = {}\
local bRunning = true\
\
-- Colours\
local highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour\
if term.isColour() then\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.yellow\
\009keywordColour = colours.yellow\
\009commentColour = colours.green\
\009stringColour = colours.red\
else\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.white\
\009keywordColour = colours.white\
\009commentColour = colours.white\
\009stringColour = colours.white\
end\
\
-- Menus\
local bMenu = false\
local nMenuItem = 1\
local tMenuItems = {}\
if not bReadOnly then\
    table.insert( tMenuItems, \"Save\" )\
end\
if shell.openTab then\
    table.insert( tMenuItems, \"Run\" )\
end\
if peripheral.find( \"printer\" ) then\
    table.insert( tMenuItems, \"Print\" )\
end\
table.insert( tMenuItems, \"Exit\" )\
\
local sStatus = \"Press Ctrl to access menu\"\
if string.len( sStatus ) > w - 5 then\
    sStatus = \"Press Ctrl for menu\"\
end\
\
local function load( _sPath )\
\009tLines = {}\
\009if fs.exists( _sPath ) then\
\009\009local file = io.open( _sPath, \"r\" )\
\009\009local sLine = file:read()\
\009\009while sLine do\
\009\009\009table.insert( tLines, sLine )\
\009\009\009sLine = file:read()\
\009\009end\
\009\009file:close()\
\009end\
\009\
\009if #tLines == 0 then\
\009\009table.insert( tLines, \"\" )\
\009end\
end\
\
local function save( _sPath )\
\009-- Create intervening folder\
\009local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len() )\
\009if not fs.exists( sDir ) then\
\009\009fs.makeDir( sDir )\
\009end\
\
\009-- Save\
\009local file = nil\
\009local function innerSave()\
\009\009file = fs.open( _sPath, \"w\" )\
\009\009if file then\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009file.write( sLine .. \"\\n\" )\
\009\009\009end\
\009\009else\
\009\009\009error( \"Failed to open \".._sPath )\
\009\009end\
\009end\
\009\
\009local ok, err = pcall( innerSave )\
\009if file then \
\009\009file.close()\
\009end\
\009return ok, err\
end\
\
local tKeywords = {\
\009[\"and\"] = true,\
\009[\"break\"] = true,\
\009[\"do\"] = true,\
\009[\"else\"] = true,\
\009[\"elseif\"] = true,\
\009[\"end\"] = true,\
\009[\"false\"] = true,\
\009[\"for\"] = true,\
\009[\"function\"] = true,\
\009[\"if\"] = true,\
\009[\"in\"] = true,\
\009[\"local\"] = true,\
\009[\"nil\"] = true,\
\009[\"not\"] = true,\
\009[\"or\"] = true,\
\009[\"repeat\"] = true,\
\009[\"return\"] = true,\
\009[\"then\"] = true,\
\009[\"true\"] = true,\
\009[\"until\"]= true,\
\009[\"while\"] = true,\
}\
\
local function tryWrite( sLine, regex, colour )\
\009local match = string.match( sLine, regex )\
\009if match then\
\009\009if type(colour) == \"number\" then\
\009\009\009term.setTextColour( colour )\
\009\009else\
\009\009\009term.setTextColour( colour(match) )\
\009\009end\
\009\009term.write( match )\
\009\009term.setTextColour( textColour )\
\009\009return string.sub( sLine, string.len(match) + 1 )\
\009end\
\009return nil\
end\
\
local function writeHighlighted( sLine )\
\009while string.len(sLine) > 0 do\009\
\009\009sLine = \
\009\009\009tryWrite( sLine, \"^%-%-%[%[.-%]%]\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^%-%-.*\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^\\\"\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\\".-[^\\\\]\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'.-[^\\\\]\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^%[%[.-%]%]\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^[%w_]+\", function( match )\
\009\009\009\009if tKeywords[ match ] then\
\009\009\009\009\009return keywordColour\
\009\009\009\009end\
\009\009\009\009return textColour\
\009\009\009end ) or\
\009\009\009tryWrite( sLine, \"^[^%w_]\", textColour )\
\009end\
end\
\
local tCompletions\
local nCompletion\
\
local tCompleteEnv = _ENV\
local function complete( sLine )\
\009if settings.get( \"edit.autocomplete\" ) then\
\009    local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.]+$\" )\
\009    if nStartPos then\
\009        sLine = string.sub( sLine, nStartPos )\
\009    end\
\009    if #sLine > 0 then\
\009        return textutils.complete( sLine, tCompleteEnv )\
\009    end\
\009end\
    return nil\
end\
\
local function recomplete()\
    local sLine = tLines[y]\
    if not bMenu and not bReadOnly and x == string.len(sLine) + 1 then\
        tCompletions = complete( sLine )\
        if tCompletions and #tCompletions > 0 then\
            nCompletion = 1\
        else\
            nCompletion = nil\
        end\
    else\
        tCompletions = nil\
        nCompletion = nil\
    end\
end\
\
local function writeCompletion( sLine )\
    if nCompletion then\
        local sCompletion = tCompletions[ nCompletion ]\
        term.setTextColor( colours.white )\
        term.setBackgroundColor( colours.grey )\
        term.write( sCompletion )\
        term.setTextColor( textColour )\
        term.setBackgroundColor( bgColour )\
    end\
end\
\
local function redrawText()\
    local cursorX, cursorY = x, y\
\009for y=1,h-1 do\
\009\009term.setCursorPos( 1 - scrollX, y )\
\009\009term.clearLine()\
\
\009\009local sLine = tLines[ y + scrollY ]\
\009\009if sLine ~= nil then\
\009\009\009writeHighlighted( sLine )\
            if cursorY == y and cursorX == #sLine + 1 then\
                writeCompletion()\
            end\
\009\009end\
\009end\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local function redrawLine(_nY)\
\009local sLine = tLines[_nY]\
\009if sLine then\
        term.setCursorPos( 1 - scrollX, _nY - scrollY )\
        term.clearLine()\
        writeHighlighted( sLine )\
        if _nY == y and x == #sLine + 1 then\
            writeCompletion()\
        end\
        term.setCursorPos( x - scrollX, _nY - scrollY )\
    end\
end\
\
local function redrawMenu()\
    -- Clear line\
    term.setCursorPos( 1, h )\
\009term.clearLine()\
\
    -- Draw line numbers\
    term.setCursorPos( w - string.len( \"Ln \"..y ) + 1, h )\
    term.setTextColour( highlightColour )\
    term.write( \"Ln \" )\
    term.setTextColour( textColour )\
    term.write( y )\
\
    term.setCursorPos( 1, h )\
\009if bMenu then\
        -- Draw menu\
\009\009term.setTextColour( textColour )\
\009\009for nItem,sItem in pairs( tMenuItems ) do\
\009\009\009if nItem == nMenuItem then\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"[\" )\
\009\009\009\009term.setTextColour( textColour )\
\009\009\009\009term.write( sItem )\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"]\" )\
        \009\009term.setTextColour( textColour )\
\009\009\009else\
\009\009\009\009term.write( \" \"..sItem..\" \" )\
\009\009\009end\
\009\009end\
    else\
        -- Draw status\
        term.setTextColour( highlightColour )\
        term.write( sStatus )\
        term.setTextColour( textColour )\
    end\
\
\009-- Reset cursor\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local tMenuFuncs = { \
\009Save = function()\
\009\009if bReadOnly then\
\009\009\009sStatus = \"Access denied\"\
\009\009else\
\009\009\009local ok, err = save( sPath )\
\009\009\009if ok then\
\009\009\009\009sStatus=\"Saved to \"..sPath\
\009\009\009else\
\009\009\009\009sStatus=\"Error saving to \"..sPath\
\009\009\009end\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Print = function()\
\009\009local printer = peripheral.find( \"printer\" )\
\009\009if not printer then\
\009\009\009sStatus = \"No printer attached\"\
\009\009\009return\
\009\009end\
\
\009\009local nPage = 0\
\009\009local sName = fs.getName( sPath )\
\009\009if printer.getInkLevel() < 1 then\
\009\009\009sStatus = \"Printer out of ink\"\
\009\009\009return\
\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009sStatus = \"Printer out of paper\"\
\009\009\009return\
\009\009end\
\
\009\009local screenTerminal = term.current()\
\009\009local printerTerminal = {\
\009\009\009getCursorPos = printer.getCursorPos,\
\009\009\009setCursorPos = printer.setCursorPos,\
\009\009\009getSize = printer.getPageSize,\
\009\009\009write = printer.write,\
\009\009}\
\009\009printerTerminal.scroll = function()\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\009\009\009\
\009\009\009end\
\009\009\009\
\009\009\009while not printer.newPage()\009do\
\009\009\009\009if printer.getInkLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of ink, please refill\"\
\009\009\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of paper, please refill\"\
\009\009\009\009else\
\009\009\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009\009end\
\009\
\009\009\009\009term.redirect( screenTerminal )\
\009\009\009\009redrawMenu()\
\009\009\009\009term.redirect( printerTerminal )\
\009\009\009\009\
\009\009\009\009local timer = os.startTimer(0.5)\
\009\009\009\009sleep(0.5)\
\009\009\009end\
\
\009\009\009nPage = nPage + 1\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName )\
\009\009\009else\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\
\009\009\009end\
\009\009end\
\009\009\
\009\009bMenu = false\
\009\009term.redirect( printerTerminal )\
\009\009local ok, error = pcall( function()\
\009\009\009term.scroll()\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009print( sLine )\
\009\009\009end\
\009\009end )\
        term.redirect( screenTerminal )\
\009\009if not ok then\
\009\009\009print( error )\
\009\009end\
\009\009\
\009\009while not printer.endPage() do\
\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009redrawMenu()\
\009\009\009sleep( 0.5 )\
\009\009end\
\009\009bMenu = true\
\009\009\009\
\009\009if nPage > 1 then\
\009\009\009sStatus = \"Printed \"..nPage..\" Pages\"\
\009\009else\
\009\009\009sStatus = \"Printed 1 Page\"\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Exit = function()\
\009\009bRunning = false\
\009end,\
\009Run = function()\
\009    local sTempPath = \"/.temp\"\
        local ok, err = save( sTempPath )\
        if ok then\
            local nTask = shell.openTab( sTempPath )\
            if nTask then\
                shell.switchTab( nTask )\
            else\
                sStatus=\"Error starting Task\"\
            end\
            fs.delete( sTempPath )\
        else\
            sStatus=\"Error saving to \"..sTempPath\
        end\
\009\009redrawMenu()\
    end\
}\
\
local function doMenuItem( _n )\
\009tMenuFuncs[tMenuItems[_n]]()\
\009if bMenu then\
\009\009bMenu = false\
\009\009term.setCursorBlink( true )\
\009end\
\009redrawMenu()\
end\
\
local function setCursor( newX, newY )\
    local oldX, oldY = x, y\
    x, y = newX, newY\
\009local screenX = x - scrollX\
\009local screenY = y - scrollY\
\009\
\009local bRedraw = false\
\009if screenX < 1 then\
\009\009scrollX = x - 1\
\009\009screenX = 1\
\009\009bRedraw = true\
\009elseif screenX > w then\
\009\009scrollX = x - w\
\009\009screenX = w\
\009\009bRedraw = true\
\009end\
\009\
\009if screenY < 1 then\
\009\009scrollY = y - 1\
\009\009screenY = 1\
\009\009bRedraw = true\
\009elseif screenY > h-1 then\
\009\009scrollY = y - (h-1)\
\009\009screenY = h-1\
\009\009bRedraw = true\
\009end\
\
\009recomplete()\
\009if bRedraw then\
\009\009redrawText()\
\009elseif y ~= oldY then\
\009    redrawLine( oldY )\
\009    redrawLine( y )\
\009else\
\009    redrawLine( y )\
\009end\
\009term.setCursorPos( screenX, screenY )\
\
\009redrawMenu()\
end\
\
-- Actual program functionality begins\
load(sPath)\
\
term.setBackgroundColour( bgColour )\
term.clear()\
term.setCursorPos(x,y)\
term.setCursorBlink( true )\
\
recomplete()\
redrawText()\
redrawMenu()\
\
local function acceptCompletion()\
    if nCompletion then\
        -- Append the completion\
        local sCompletion = tCompletions[ nCompletion ]\
        tLines[y] = tLines[y] .. sCompletion\
        setCursor( x + string.len( sCompletion ), y )\
    end\
end\
\
-- Handle input\
while bRunning do\
\009local sEvent, param, param2, param3 = os.pullEvent()\
\009if sEvent == \"key\" then\
\009    local oldX, oldY = x, y\
\009\009if param == keys.up then\
\009\009\009-- Up\
\009\009\009if not bMenu then\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion - 1\
                    if nCompletion < 1 then\
                        nCompletion = #tCompletions\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009setCursor(\
\009\009\009\009\009    math.min( x, string.len( tLines[y - 1] ) + 1 ),\
\009\009\009\009\009    y - 1\
\009\009\009\009\009)\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.down then\
\009\009\009-- Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor down\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion + 1\
                    if nCompletion > #tCompletions then\
                        nCompletion = 1\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y < #tLines then\
\009\009\009\009    -- Move cursor down\
\009\009\009\009\009setCursor(\
                        math.min( x, string.len( tLines[y + 1] ) + 1 ),\
                        y + 1\
                    )\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.tab then\
\009\009\009-- Tab\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    if nCompletion and x == string.len(tLines[y]) + 1 then\
\009\009\009        -- Accept autocomplete\
                    acceptCompletion()\
                else\
                    -- Indent line\
                    local sLine = tLines[y]\
                    tLines[y] = string.sub(sLine,1,x-1) .. \"  \" .. string.sub(sLine,x)\
                    setCursor( x + 2, y )\
                end\
\009\009\009end\
\
\009\009elseif param == keys.pageUp then\
\009\009\009-- Page Up\
\009\009\009if not bMenu then\
\009\009\009\009-- Move up a page\
\009\009\009\009local newY\
\009\009\009\009if y - (h - 1) >= 1 then\
\009\009\009\009\009newY = y - (h - 1)\
\009\009\009\009else\
\009\009\009\009    newY = 1\
\009\009\009\009end\
                setCursor(\
\009\009\009\009    math.min( x, string.len( tLines[newY] ) + 1 ),\
\009\009\009\009    newY\
\009\009\009\009)\
\009\009\009end\
\
\009\009elseif param == keys.pageDown then\
\009\009\009-- Page Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move down a page\
\009\009\009\009local newY\
\009\009\009\009if y + (h - 1) <= #tLines then\
\009\009\009\009\009newY = y + (h - 1)\
\009\009\009\009else\
\009\009\009\009\009newY = #tLines\
\009\009\009\009end\
\009\009\009\009local newX = math.min( x, string.len( tLines[newY] ) + 1 )\
\009\009\009\009setCursor( newX, newY )\
\009\009\009end\
\
\009\009elseif param == keys.home then\
\009\009\009-- Home\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the beginning\
\009\009\009\009if x > 1 then\
                    setCursor(1,y)\
                end\
\009\009\009end\
\
\009\009elseif param == keys[\"end\"] then\
\009\009\009-- End\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the end\
\009\009\009\009local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
    \009\009\009\009setCursor( nLimit, y )\
    \009\009    end\
\009\009\009end\
\
\009\009elseif param == keys.left then\
\009\009\009-- Left\
\009\009\009if not bMenu then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Move cursor left\
    \009\009\009\009setCursor( x - 1, y )\
\009\009\009\009elseif x==1 and y>1 then\
    \009\009\009\009setCursor( string.len( tLines[y-1] ) + 1, y - 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu left\
\009\009\009\009nMenuItem = nMenuItem - 1\
\009\009\009\009if nMenuItem < 1 then\
\009\009\009\009\009nMenuItem = #tMenuItems\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.right then\
\009\009\009-- Right\
\009\009\009if not bMenu then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009-- Move cursor right\
\009\009\009\009\009setCursor( x + 1, y )\
\009\009\009    elseif nCompletion and x == string.len(tLines[y]) + 1 then\
                    -- Accept autocomplete\
                    acceptCompletion()\
\009\009\009\009elseif x==nLimit and y<#tLines then\
\009\009\009\009    -- Go to next line\
\009\009\009\009    setCursor( 1, y + 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu right\
\009\009\009\009nMenuItem = nMenuItem + 1\
\009\009\009\009if nMenuItem > #tMenuItems then\
\009\009\009\009\009nMenuItem = 1\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.delete then\
\009\009\009-- Delete\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawLine(y)\
\009\009\009\009elseif y<#tLines then\
\009\009\009\009\009tLines[y] = tLines[y] .. tLines[y+1]\
\009\009\009\009\009table.remove( tLines, y+1 )\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.backspace then\
\009\009\009-- Backspace\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Remove character\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)\
\009\009\009        setCursor( x - 1, y )\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Remove newline\
\009\009\009\009\009local sPrevLen = string.len( tLines[y-1] )\
\009\009\009\009\009tLines[y-1] = tLines[y-1] .. tLines[y]\
\009\009\009\009\009table.remove( tLines, y )\
\009\009\009\009\009setCursor( sPrevLen + 1, y - 1 )\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.enter then\
\009\009\009-- Enter\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009-- Newline\
\009\009\009\009local sLine = tLines[y]\
\009\009\009\009local _,spaces=string.find(sLine,\"^[ ]+\")\
\009\009\009\009if not spaces then\
\009\009\009\009\009spaces=0\
\009\009\009\009end\
\009\009\009\009tLines[y] = string.sub(sLine,1,x-1)\
\009\009\009\009table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )\
\009\009\009\009setCursor( spaces + 1, y + 1 )\
\009\009\009\009redrawText()\
\
\009\009\009elseif bMenu then\
\009\009\009\009-- Menu selection\
\009\009\009\009doMenuItem( nMenuItem )\
\
\009\009\009end\
\
\009\009elseif param == keys.leftCtrl or param == keys.rightCtrl or param == keys.rightAlt then\
\009\009\009-- Menu toggle\
\009\009\009bMenu = not bMenu\
\009\009\009if bMenu then\
\009\009\009\009term.setCursorBlink( false )\
\009\009\009else\
\009\009\009\009term.setCursorBlink( true )\
\009\009\009end\
\009\009\009redrawMenu()\
\
\009\009end\
\009\009\
\009elseif sEvent == \"char\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + 1, y )\
\
\009\009elseif bMenu then\
\009\009\009-- Select menu items\
\009\009\009for n,sMenuItem in ipairs( tMenuItems ) do\
\009\009\009\009if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then\
\009\009\009\009\009doMenuItem( n )\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"paste\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + string.len( param ), y )\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_click\" then\
\009\009if not bMenu then\
\009\009\009if param == 1 then\
\009\009\009\009-- Left click\
\009\009\009\009local cx,cy = param2, param3\
\009\009\009\009if cy < h then\
\009\009\009\009\009local newY = math.min( math.max( scrollY + cy, 1 ), #tLines )\
\009\009\009\009\009local newX = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[newY] ) + 1 )\
\009\009\009\009\009setCursor( newX, newY )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_scroll\" then\
\009\009if not bMenu then\
\009\009\009if param == -1 then\
\009\009\009\009-- Scroll up\
\009\009\009\009if scrollY > 0 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009scrollY = scrollY - 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\
\009\009\009elseif param == 1 then\
\009\009\009\009-- Scroll down\
\009\009\009\009local nMaxScroll = #tLines - (h-1)\
\009\009\009\009if scrollY < nMaxScroll then\
\009\009\009\009\009-- Move cursor down\
\009\009\009\009\009scrollY = scrollY + 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\009\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"term_resize\" then\
\009    w,h = term.getSize()\
        setCursor( x, y )\
        redrawMenu()\
        redrawText()\
\
\009end\
end\
\
-- Cleanup\
term.clear()\
term.setCursorBlink( false )\
term.setCursorPos( 1, 1 )",
      "\
-- Get arguments\
local tArgs = { ... }\
if #tArgs == 0 then\
\009print( \"Usage: eject <drive>\" )\
\009return\
end\
\
local sDrive = tArgs[1]\
\
-- Check the disk exists\
local bPresent = disk.isPresent( sDrive )\
if not bPresent then\
\009print( \"Nothing in \"..sDrive..\" drive\" )\
\009return\
end\
\
disk.eject( sDrive )",
      "shell.exit()",
      "0\
77     77\
718888887\
 8     8\
 8     8\
 8     8\
788888897\
77     77",
      "1\
     777\
     7b7\
     787\
7777778777\
7188888887\
7777777777",
      "5\
 777    77777\
 727777778837\
 788888878787\
 787777888887\
77877778777777\
7e8b7888b888e7\
7787787b777877\
 777887887887\
   7487807487\
   7777777777",
      "4\
   777777777\
   727872787\
   787878787\
777787878787777\
7be888888888be7\
777787878787777\
   787878787\
   787478747\
   777777777",
      "6\
77  777  77\
72888888897\
 8   8   8\
 8 8b888 8\
78 e8888 87\
78888788887\
78 8888e 87\
 8 888b8 8\
 8   8   8\
75888888807\
77  777  77",
      "1\
777777777\
7888888b7\
787778887\
787 78777\
7877787\
7888887\
7777787\
    707\
    777",
      "2\
  77777777\
777888188777\
7b78777787b7\
78787  78787\
78787  78787\
78887  78887\
777877778777\
  78838887\
  77777777",
      "2\
    77777777\
777778888887\
788888777787\
7b77787  787\
787 787  787\
7b77787  787\
7888887  787\
7777707  707\
    777  777",
      "3\
777777777\
788888887\
787787787\
787787787\
788888887\
787787787\
787787787\
78e748887\
777777777",
      "4\
7777777777\
7288888837\
78      87\
788888b 87\
788888b 87\
788888b 87\
788888b 87\
78      87\
7188888807\
7777777777",
      "3\
728777778b7\
78888888887\
78777877787\
787 787 787\
787 7877788\
787 7888889\
88777877777\
e888887\
7777887",
      "4\
777777 7777\
7287b7 7867\
788787 7887\
77878777877\
 7888eb8887\
 77877787877\
 7887 787887\
 7487 7e7807\
 7777 777777",
      "2\
    777  777\
  777877778777\
  788838888887\
7778bbbbbbbb8777\
7888b888888b8897\
7878be8888eb8787\
7588b888888b8887\
7778bbbbbbbb8777\
  788888818887\
  777877778777\
    777  777",
      "-- Paint created by nitrogenfingers (edited by dan200)\
-- http://www.youtube.com/user/NitrogenFingers\
\
------------\
-- Fields --\
------------\
\
-- The width and height of the terminal\
local w,h = term.getSize()\
\
-- The selected colours on the left and right mouse button, and the colour of the canvas\
local leftColour, rightColour = colours.white, nil\
local canvasColour = colours.black\
\
-- The values stored in the canvas\
local canvas = {}\
\
-- The menu options\
local mChoices = { \"Save\",\"Exit\" }\
\
-- The message displayed in the footer bar\
local fMessage = \"Press Ctrl to access menu\"\
\
-------------------------\
-- Initialisation --\
-------------------------\
\
-- Determine if we can even run this\
if not term.isColour() then\
\009print(\"Requires an Advanced Computer\")\
\009return\
end\
\
-- Determines if the file exists, and can be edited on this computer\
local tArgs = {...}\
if #tArgs == 0 then\
\009print(\"Usage: paint <path>\")\
\009return\
end\
local sPath = shell.resolve(tArgs[1])\
local bReadOnly = fs.isReadOnly(sPath)\
if fs.exists(sPath) and fs.isDir(sPath) then\
\009print(\"Cannot edit a directory.\")\
\009return\
end\
\
---------------\
-- Functions --\
---------------\
\
local function getCanvasPixel( x, y )\
    if canvas[y] then\
        return canvas[y][x]\
    end\
    return nil\
end\
\
--[[\
\009Converts a colour value to a text character\
\009params: colour = the number to convert to a hex value\
\009returns: a string representing the chosen colour\
]]\
local function getCharOf( colour )\
\009-- Incorrect values always convert to nil\
\009if type(colour) == \"number\" then\
\009\009local value = math.floor( math.log(colour) / math.log(2) ) + 1\
\009\009if value >= 1 and value <= 16 then\
\009\009\009return string.sub( \"0123456789abcdef\", value, value )\
\009\009end\
\009end\
\009return \" \"\
end\009\
\
--[[\
\009Converts a text character to colour value\
\009params: char = the char (from string.byte) to convert to number\
\009returns: the colour number of the hex value\
]]\
local tColourLookup = {}\
for n=1,16 do\
\009tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\
end\
local function getColourOf( char )\
\009-- Values not in the hex table are transparent (canvas coloured)\
\009return tColourLookup[char]\
end\
\
--[[ \
\009Loads the file into the canvas\
\009params: path = the path of the file to open\
\009returns: nil\
]]\
local function load(path)\
\009-- Load the file\
\009if fs.exists(path) then\
\009\009local file = fs.open(sPath, \"r\")\
\009\009local sLine = file.readLine()\
\009\009while sLine do\
\009\009\009local line = {}\
\009\009\009for x=1,w-2 do\
\009\009\009\009line[x] = getColourOf( string.byte(sLine,x,x) )\
\009\009\009end\
\009\009\009table.insert( canvas, line )\
\009\009\009sLine = file.readLine()\
\009\009end\
\009\009file.close()\
\009end\
end\
\
--[[  \
\009Saves the current canvas to file  \
\009params: path = the path of the file to save\
\009returns: true if save was successful, false otherwise\
]]\
local function save(path)\
    -- Open file\
\009local sDir = string.sub(sPath, 1, #sPath - #fs.getName(sPath))\
\009if not fs.exists(sDir) then\
\009\009fs.makeDir(sDir)\
\009end\
\
\009local file = fs.open( path, \"w\" )\
\009if not file then\
\009    return false\
\009end\
\
    -- Encode (and trim)\
\009local tLines = {}\
\009local nLastLine = 0\
\009for y=1,h-1 do\
\009    local sLine = \"\"\
\009    local nLastChar = 0\
\009\009for x=1,w-2 do\
\009\009    local c = getCharOf( getCanvasPixel( x, y ) )\
\009\009    sLine = sLine .. c\
\009\009    if c ~= \" \" then\
\009\009        nLastChar = x\
\009\009    end\
\009\009end\
\009\009sLine = string.sub( sLine, 1, nLastChar )\
\009\009tLines[y] = sLine\
\009\009if string.len( sLine ) > 0 then\
\009\009    nLastLine = y\
\009\009end\
\009end\
\
    -- Save out\
\009for n=1,nLastLine do\
   \009    file.writeLine( tLines[ n ] )\
\009end\
\009file.close()\
\009return true\
end\
\
--[[  \
\009Draws colour picker sidebar, the pallette and the footer\
\009returns: nil\
]]\
local function drawInterface()\
\009-- Footer\
\009term.setCursorPos(1, h)\
\009term.setBackgroundColour(colours.black)\
\009term.setTextColour(colours.yellow)\
\009term.clearLine()\
\009term.write(fMessage)\
\009\
\009-- Colour Picker\
\009for i=1,16 do\
\009\009term.setCursorPos(w-1, i)\
\009\009term.setBackgroundColour( 2^(i-1) )\
\009\009term.write(\"  \")\
\009end\
\
\009term.setCursorPos(w-1, 17)\
\009term.setBackgroundColour( canvasColour )\
\009term.setTextColour( colours.grey )\
\009term.write(\"\\127\\127\")\
\009\009\009\
\009-- Left and Right Selected Colours\
\009for i=18,18 do\
\009\009term.setCursorPos(w-1, i)\
\009\009if leftColour ~= nil then\
\009\009\009term.setBackgroundColour( leftColour )\
\009\009\009term.write(\" \")\
\009\009else\
\009\009\009term.setBackgroundColour( canvasColour )\
\009\009\009term.setTextColour( colours.grey )\
\009\009\009term.write(\"\\127\")\
\009\009end\
\009\009if rightColour ~= nil then\
\009\009\009term.setBackgroundColour( rightColour )\
\009\009\009term.write(\" \")\
\009\009else\
\009\009\009term.setBackgroundColour( canvasColour )\
\009\009\009term.setTextColour( colours.grey )\
\009\009\009term.write(\"\\127\")\
\009\009end\
\009end\
\
\009-- Padding\
\009term.setBackgroundColour( canvasColour )\
\009for i=20,h-1 do\
\009\009term.setCursorPos(w-1, i)\
\009\009term.write(\"  \")\
\009end\
end\
\
--[[  \
\009Converts a single pixel of a single line of the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvasPixel( x, y )\
\009local pixel = getCanvasPixel( x, y )\
\009if pixel then\
\009\009term.setBackgroundColour( pixel or canvasColour )\
\009\009term.setCursorPos(x, y)\
\009\009term.write(\" \")\
\009else\
\009\009term.setBackgroundColour( canvasColour )\
\009\009term.setTextColour( colours.grey )\
\009\009term.setCursorPos(x, y)\
        term.write(\"\\127\")\
\009end\
end\
\
--[[  \
\009Converts each colour in a single line of the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvasLine( y )\
\009for x = 1, w-2 do\
\009\009drawCanvasPixel( x, y )\
\009end\
end\
\
--[[  \
\009Converts each colour in the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvas()\
\009for y = 1, h-1 do\
\009\009drawCanvasLine( y )\
\009end\
end\
\
--[[\
\009Draws menu options and handles input from within the menu.\
\009returns: true if the program is to be exited; false otherwise\
]]\
local function accessMenu()\
\009-- Selected menu option\
\009local selection = 1\
\009\
\009term.setBackgroundColour(colours.black)\
\009while true do\
\009\009-- Draw the menu\
\009\009term.setCursorPos(1,h)\
\009\009term.clearLine()\
\009\009term.setTextColour(colours.white)\
\009\009for k,v in pairs(mChoices) do\
\009\009\009if selection==k then \
\009\009\009\009term.setTextColour(colours.yellow)\
\009\009\009\009local ox,_ = term.getCursorPos()\
\009\009\009\009term.write(\"[\"..string.rep(\" \",#v)..\"]\")\
\009\009\009\009term.setCursorPos(ox+1,h)\
\009\009\009\009term.setTextColour(colours.white)\
\009\009\009\009term.write(v)\
\009\009\009\009term.setCursorPos(term.getCursorPos()+1,h)\
\009\009\009else\
\009\009\009\009term.write(\" \"..v..\" \")\
\009\009\009end\
\009\009end\
\009\009\
\009\009-- Handle input in the menu\
\009\009local id,key = os.pullEvent(\"key\")\
\009\009if id == \"key\" then\
\009\009\009-- S and E are shortcuts\
\009\009\009if key == keys.s then\
\009\009\009\009selection = 1\
\009\009\009\009key = keys.enter\
\009\009\009elseif key == keys.e then\
\009\009\009\009selection = 2\
\009\009\009\009key = keys.enter\
\009\009\009end\
\009\009\
\009\009\009if key == keys.right then\
\009\009\009\009-- Move right\
\009\009\009\009selection = selection + 1\
\009\009\009\009if selection > #mChoices then\
\009\009\009\009\009selection = 1\
\009\009\009\009end\
\009\009\009\009\
\009\009\009elseif key == keys.left and selection > 1 then\
\009\009\009\009-- Move left\
\009\009\009\009selection = selection - 1\
\009\009\009\009if selection < 1 then\
\009\009\009\009\009selection = #mChoices\
\009\009\009\009end\
\009\009\009\009\
\009\009\009elseif key == keys.enter then\
\009\009\009\009-- Select an option\
\009\009\009\009if mChoices[selection]==\"Save\" then \
\009\009\009\009\009if bReadOnly then \
\009\009\009\009\009\009fMessage = \"Access Denied\"\
\009\009\009\009\009\009return false\
\009\009\009\009\009end\
\009\009\009\009\009local success = save(sPath)\
\009\009\009\009\009if success then\
\009\009\009\009\009\009fMessage = \"Saved to \"..sPath\
\009\009\009\009\009else\
\009\009\009\009\009\009fMessage = \"Error saving to \"..sPath\
\009\009\009\009\009end\
\009\009\009\009\009return false\
\009\009\009\009elseif mChoices[selection]==\"Exit\" then \
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009elseif key == keys.leftCtrl or keys == keys.rightCtrl then\
\009\009\009\009-- Cancel the menu\
\009\009\009\009return false \
\009\009\009end\
\009\009end\
\009end\
end\
\
--[[  \
\009Runs the main thread of execution. Draws the canvas and interface, and handles\
\009mouse and key events.\
\009returns: nil\
]]\
local function handleEvents()\
\009local programActive = true\
\009while programActive do\
\009\009local id,p1,p2,p3 = os.pullEvent()\
\009\009if id==\"mouse_click\" or id==\"mouse_drag\" then\
\009\009\009if p2 >= w-1 and p3 >= 1 and p3 <= 17 then\
\009\009\009\009if id ~= \"mouse_drag\" then\
\009\009\009\009\009-- Selecting an items in the colour picker\
\009\009\009\009\009if p3 <= 16 then\
\009\009\009\009\009\009if p1==1 then\
\009\009\009\009\009\009\009leftColour = 2^(p3-1)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009rightColour = 2^(p3-1)\
\009\009\009\009\009\009end\
\009\009\009\009\009else\
\009\009\009\009\009\009if p1==1 then\
\009\009\009\009\009\009\009leftColour = nil\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009rightColour = nil\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009--drawCanvas()\
\009\009\009\009\009drawInterface()\
\009\009\009\009end\
\009\009\009elseif p2 < w-1 and p3 <= h-1 then\
\009\009\009\009-- Clicking on the canvas\
\009\009\009\009local paintColour = nil\
\009\009\009\009if p1==1 then\
\009\009\009\009\009paintColour = leftColour\
\009\009\009\009elseif p1==2 then\
\009\009\009\009\009paintColour = rightColour\
\009\009\009\009end\
\009\009\009\009if not canvas[p3] then\
                    canvas[p3] = {}\
    \009\009\009end\
                canvas[p3][p2] = paintColour\
\
\009\009\009\009drawCanvasPixel( p2, p3 )\
\009\009\009end\
\009\009elseif id==\"key\" then\
\009\009\009if p1==keys.leftCtrl or p1==keys.rightCtrl then\
\009\009\009\009programActive = not accessMenu()\
\009\009\009\009drawInterface()\
\009\009\009end\
\009\009elseif id==\"term_resize\" then\
\009\009    w,h = term.getSize()\
            drawCanvas()\
            drawInterface()\
        end\
\009end\
end\
\
-- Init\
load(sPath)\
drawCanvas()\
drawInterface()\
\
-- Main loop\
handleEvents()\
\
-- Shutdown\
term.setBackgroundColour(colours.black)\
term.setTextColour(colours.white)\
term.clear()\
term.setCursorPos(1,1)",
      "--CCRedirection by : RamiLego4Game and Dan200--\
--Based on Redirection by Dan200: http://www.redirectiongame.com--\
--Clearing Screen--\
\
--Vars--\
local TermW,TermH = term.getSize()\
\
local sLevelTitle\
local tScreen\
local oScreen\
local SizeW,SizeH\
local aExits\
local fExit\
local nSpeed\
local Speed\
local fSpeed\
local fSpeedS\
local bPaused\
local Tick\
local Blocks\
local XOrgin,YOrgin\
local fLevel\
\
local function reset()\
    sLevelTitle = \"\"\
    tScreen = {}\
    oScreen = {}\
    SizeW,SizeH = TermW,TermH\
    aExits = 0\
    fExit = \"nop\"\
    nSpeed = 0.6\
    Speed = nSpeed\
    fSpeed = 0.2\
    fSpeedS = false\
    bPaused = false\
    Tick = os.startTimer(Speed)\
    Blocks = 0\
    XOrgin,YOrgin = 1,1\
\
    term.setBackgroundColor(colors.black)\
    term.setTextColor(colors.white)\
    term.clear()\
end\
\
local InterFace = {}\
InterFace.cExit = colors.red\
InterFace.cSpeedD = colors.white\
InterFace.cSpeedA = colors.red\
InterFace.cTitle = colors.red\
\
local cG = colors.lightGray\
local cW = colors.gray\
local cS = colors.black\
local cR1 = colors.blue\
local cR2 = colors.red\
local cR3 = colors.green\
local cR4 = colors.yellow\
\
local tArgs = { ... }\
\
--Functions--\
local function printCentred( yc, stg )\
\009local xc = math.floor((TermW - string.len(stg)) / 2) + 1\
\009term.setCursorPos(xc,yc)\
\009term.write( stg )\
end\
\
local function centerOrgin()\
\009XOrgin = math.floor((TermW/2)-(SizeW/2))\
\009YOrgin = math.floor((TermH/2)-(SizeH/2))\
end\
\
local function reMap()\
\009tScreen = nil\
\009tScreen = {}\
\009for x=1,SizeW do\
\009\009tScreen[x] = {}\
\009\009for y=1,SizeH do\
\009\009\009tScreen[x][y] = { space = true, wall = false, ground = false, robot = \"zz\", start = \"zz\", exit = \"zz\" }\
\009\009end\
\009end\
end\
\
local function tablecopy(t)\
  local t2 = {}\
  for k,v in pairs(t) do\
    t2[k] = v\
  end\
  return t2\
end\
\
local function buMap()\
\009oScreen = nil\
\009oScreen = {}\
\009for x=1,SizeW do\
\009\009oScreen[x] = {}\
\009\009for y=1,SizeH do\
\009\009\009oScreen[x][y] = tablecopy(tScreen[x][y])\
\009\009end\
\009end\
end\
\
local function addRobot(x,y,side,color)\
\009local obj = tScreen[x][y]\
\009local data = side..color\
\009if obj.wall == nil and obj.robot == nil then\
\009\009tScreen[x][y].robot = data\
\009else\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009tScreen[x][y].robot = data\
\009end\
end\
\
local function addStart(x,y,side,color)\
\009local obj = tScreen[x][y]\
\009local data = side..color\
\009if obj.wall == nil and obj.space == nil then\
\009\009tScreen[x][y].start = data\
\009else\
\009\009obj.wall = nil\
\009\009obj.space = nil\
\009\009tScreen[x][y].start = data\
\009end\
\009aExits = aExits+1\
end\
\
local function addGround(x,y)\
\009local obj = tScreen[x][y]\
\009if obj.space == nil and obj.exit == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].ground = true\
\009else\
\009\009obj.space = nil\
\009\009obj.exit = \"zz\"\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009obj.start = \"zz\"\
\009\009tScreen[x][y].ground = true\
\009end\
end\
\
local function addExit(x,y,cl)\
\009local obj = tScreen[x][y]\
\009if obj.space == nil and obj.ground == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].exit = cl\
\009else\
\009\009obj.space = nil\
\009\009obj.ground = nil\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009obj.start = \"zz\"\
\009\009tScreen[x][y].exit = cl\
\009end\
end\
\
local function addWall(x,y)\
\009local obj = tScreen[x][y]\
\009if obj == nil then\
\009\009return error(\"Here X\"..x..\" Y\"..y)\
\009end\
\009if obj.space == nil and obj.exit == nil and obj.ground == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].wall = true\
\009else\
\009\009obj.space = nil\
\009\009obj.exit = nil\
\009\009obj.ground = nil\
\009\009obj.robot = nil\
\009\009obj.start = nil\
\009\009tScreen[x][y].wall = true\
\009end\
end\
\
local function loadLevel(nNum)\
    sLevelTitle = \"Level \"..nNum\
\009if nNum == nil then return error(\"nNum == nil\") end\
\009local sDir = fs.getDir( shell.getRunningProgram() )\
\009local sLevelD = sDir .. \"/levels/\" .. tostring(nNum)\
\009if not ( fs.exists(sLevelD) or fs.isDir(sLevelD) ) then return error(\"Level Not Exists : \"..sLevelD) end\
\009fLevel = fs.open(sLevelD,\"r\")\
\009local Line = 0\
\009local wl = true\
\009Blocks = tonumber(string.sub(fLevel.readLine(),1,1))\
\009local xSize = string.len(fLevel.readLine())+2\
\009local Lines = 3\
\009while wl do\
\009\009local wLine = fLevel.readLine()\
\009\009if wLine == nil then\
\009\009\009fLevel.close()\
\009\009\009wl = false\
\009\009else\
    \009    xSize = math.max(string.len(wLine)+2,xSize)\
\009\009\009Lines = Lines + 1\
\009\009end\
\009end\
\009SizeW,SizeH = xSize,Lines\
\009reMap()\
\009fLevel = fs.open(sLevelD,\"r\")\
\009fLevel.readLine()\
\009for Line=2,Lines-1 do\
\009\009sLine = fLevel.readLine()\
\009\009local chars = string.len(sLine)\
\009\009for char = 1, chars do\
\009\009\009local el = string.sub(sLine,char,char)\
\009\009\009if el == \"8\" then\
\009\009\009\009addGround(char+1,Line)\
\009\009\009elseif el == \"0\" then\
\009\009\009\009addStart(char+1,Line,\"a\",\"a\")\
\009\009\009elseif el == \"1\" then\
\009\009\009\009addStart(char+1,Line,\"b\",\"a\")\
\009\009\009elseif el == \"2\" then\
\009\009\009\009addStart(char+1,Line,\"c\",\"a\")\
\009\009\009elseif el == \"3\" then\
\009\009\009\009addStart(char+1,Line,\"d\",\"a\")\
\009\009\009elseif el == \"4\" then\
\009\009\009\009addStart(char+1,Line,\"a\",\"b\")\
\009\009\009elseif el == \"5\" then\
\009\009\009\009addStart(char+1,Line,\"b\",\"b\")\
\009\009\009elseif el == \"6\" then\
\009\009\009\009addStart(char+1,Line,\"c\",\"b\")\
\009\009\009elseif el == \"9\" then\
\009\009\009\009addStart(char+1,Line,\"d\",\"b\")\
\009\009\009elseif el == \"b\" then\
\009\009\009\009addExit(char+1,Line,\"a\")\
\009\009\009elseif el == \"e\" then\
\009\009\009\009addExit(char+1,Line,\"b\")\
\009\009\009elseif el == \"7\" then\
\009\009\009\009addWall(char+1,Line)\
\009\009\009end\
\009\009end\
\009end\
\009fLevel.close()\
end\
\
local function drawStars()\
\009--CCR Background By : RamiLego--\
\009local cStar,cStarG,crStar,crStarB = colors.lightGray,colors.gray,\".\",\"*\"\
\009local DStar,BStar,nStar,gStar = 14,10,16,3\
\009local TermW,TermH = term.getSize()\
\
    term.clear()\
    term.setCursorPos(1,1)\
\009for x=1,TermW do\
\009\009for y=1,TermH do\
\009\009\009local StarT = math.random(1,30)\
\009\009\009if StarT == DStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStar)\
\009\009\009\009write(crStar)\
\009\009\009elseif StarT == BStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStar)\
\009\009\009\009write(crStarB)\
\009\009\009elseif StarT == nStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStarG)\
\009\009\009\009write(crStar)\
\009\009\009elseif StarT == gStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStarG)\
\009\009\009\009write(crStarB)\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function drawMap()\
\009for x=1,SizeW do\
\009\009for y=1,SizeH do\
\009\009  \
\009\009\009local obj = tScreen[x][y]\
\009\009\009if obj.ground == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cG)\
\009\009\009end\
\009\009\009if obj.wall == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cW)\
\009\009\009end\
\009\009 \
\009\009 local ex = tostring(tScreen[x][y].exit)\
\009\009\009if not(ex == \"zz\" or ex == \"nil\") then\
\009\009\009\009if ex == \"a\" then\
\009\009\009\009\009ex = cR1\
\009\009\009\009elseif ex == \"b\" then\
\009\009\009\009\009ex = cR2\
\009\009\009\009elseif ex == \"c\" then\
\009\009\009\009\009ex = cR3\
\009\009\009\009elseif ex == \"d\" then\
\009\009\009\009\009ex = cR4\
\009\009\009\009else\
\009\009\009\009\009return error(\"Exit Color Out\")\
\009\009\009\009end\
\009\009\009\009term.setBackgroundColor(cG)\
\009\009\009\009term.setTextColor(ex)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\009print(\"X\")\
\009\009\009end\
\009\009 \
\009\009 local st = tostring(tScreen[x][y].start)\
\009\009\009if not(st == \"zz\" or st == \"nil\") then\
\009\009\009\009local Cr = string.sub(st,2,2)\
\009\009\009\009if Cr == \"a\" then\
\009\009\009\009\009Cr = cR1\
\009\009\009\009elseif Cr == \"b\" then\
\009\009\009\009\009Cr = cR2\
\009\009\009\009elseif Cr == \"c\" then\
\009\009\009\009\009Cr = cR3\
\009\009\009\009elseif Cr == \"d\" then\
\009\009\009\009\009Cr = cR4\
\009\009\009\009else\
\009\009\009\009\009return error(\"Start Color Out\")\
\009\009\009\009end\
\009\009\009\
\009\009\009\009term.setTextColor(Cr)\
\009\009\009term.setBackgroundColor(cG)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\
\009\009\009\009sSide = string.sub(st,1,1)\
\009\009\009\009if sSide == \"a\" then\
\009\009\009\009\009print(\"^\")\
\009\009\009\009elseif sSide == \"b\" then\
\009\009\009\009\009print(\">\")\
\009\009\009\009elseif sSide == \"c\" then\
\009\009\009\009\009print(\"v\")\
\009\009\009\009elseif sSide == \"d\" then\
\009\009\009\009\009print(\"<\")\
\009\009\009\009else\
\009\009\009\009\009print(\"@\")\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if obj.space == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cS)\
\009\009\009end\
\009\009\009\
\009\009\009local rb = tostring(tScreen[x][y].robot)\
\009\009\009if not(rb == \"zz\" or rb == \"nil\") then\
\009\009\009\009local Cr = string.sub(rb,2,2)\
\009\009\009\009if Cr == \"a\" then\
\009\009\009\009\009Cr = cR1\
\009\009\009\009elseif Cr == \"b\" then\
\009\009\009\009\009Cr = cR2\
\009\009\009\009elseif Cr == \"c\" then\
\009\009\009\009\009Cr = cR3\
\009\009\009\009elseif Cr == \"d\" then\
\009\009\009\009\009Cr = cR4\
\009\009\009\009else\
\009\009\009\009\009Cr = colors.white\
\009\009\009\009end\
\009\009\009\009term.setBackgroundColor(Cr)\
\009\009\009\009term.setTextColor(colors.white)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\009sSide = string.sub(rb,1,1)\
\009\009\009\009if sSide == \"a\" then\
\009\009\009\009\009print(\"^\")\
\009\009\009\009elseif sSide == \"b\" then\
\009\009\009\009\009print(\">\")\
\009\009\009\009elseif sSide == \"c\" then\
\009\009\009\009\009print(\"v\")\
\009\009\009\009elseif sSide == \"d\" then\
\009\009\009\009\009print(\"<\")\
\009\009\009\009else\
\009\009\009\009\009print(\"@\")\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function isBrick(x,y)\
\009local brb = tostring(tScreen[x][y].robot)\
\009local bobj = oScreen[x][y]\
\009if (brb == \"zz\" or brb == \"nil\") and not bobj.wall == true then\
\009\009return false\
\009else\
\009\009return true\
\009end\
end\
\
local function gRender(sContext)\
\009if sContext == \"start\" then\
\009\009for x=1,SizeW do\
\009\009\009for y=1,SizeH do\
\009\009\009\009local st = tostring(tScreen[x][y].start)\
\009\009\009\009if not(st == \"zz\" or st == \"nil\") then\
\009\009\009\009\009local Cr = string.sub(st,2,2)\
\009\009\009\009\009local sSide = string.sub(st,1,1)\
\009\009\009\009\009addRobot(x,y,sSide,Cr)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009elseif sContext == \"tick\" then\
\009\009buMap()\
        for x=1,SizeW do\
            for y=1,SizeH do\
                local rb = tostring(oScreen[x][y].robot)\
                if not(rb == \"zz\" or rb == \"nil\") then\
                    local Cr = string.sub(rb,2,2)\
                    local sSide = string.sub(rb,1,1)\
                    local sobj = oScreen[x][y]\
                    if sobj.space == true then\
                        tScreen[x][y].robot = \"zz\"\
                        if not sSide == \"g\" then\
                            addRobot(x,y,\"g\",Cr)\
                        end\
                    elseif sobj.exit == Cr then\
                        if sSide == \"a\" or sSide == \"b\" or sSide == \"c\" or sSide == \"d\" then\
                        tScreen[x][y].robot = \"zz\"\
                        addRobot(x,y,\"g\",Cr)\
                        aExits = aExits-1\
                        end\
                    elseif sSide == \"a\" then\
                        local obj = isBrick(x,y-1)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x,y-1,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x-1,y)\
                            local obj3 = isBrick(x+1,y)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"c\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"b\" then\
                        local obj = isBrick(x+1,y)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x+1,y,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x,y-1)\
                            local obj3 = isBrick(x,y+1)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"d\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"c\" then\
                        local obj = isBrick(x,y+1)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x,y+1,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x-1,y)\
                            local obj3 = isBrick(x+1,y)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"b\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"d\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"a\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"d\" then\
                        local obj = isBrick(x-1,y)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x-1,y,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x,y-1)\
                            local obj3 = isBrick(x,y+1)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"c\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"a\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"b\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            end\
                        end\
                    else\
                        addRobot(x,y,sSide,\"g\")\
                    end\
                end\
            end\
        end\
    end\
end\
\
function InterFace.drawBar()\
\009term.setBackgroundColor( colors.black )\
\009term.setTextColor( InterFace.cTitle )\
\009printCentred( 1, \"  \"..sLevelTitle..\"  \" )\
\009\
\009term.setCursorPos(1,1)\
\009term.setBackgroundColor( cW )\
\009write( \" \" )\
\009term.setBackgroundColor( colors.black )\
\009write( \" x \"..tostring(Blocks)..\" \" )\
\009\
\009term.setCursorPos( TermW-8,TermH )\
\009term.setBackgroundColor( colors.black )\
    term.setTextColour(InterFace.cSpeedD)\
\009write(\" <<\" )\
\009if bPaused then\
\009\009term.setTextColour(InterFace.cSpeedA)\
\009else\
\009\009term.setTextColour(InterFace.cSpeedD)\
\009end\
\009write(\" ||\")\
\009if fSpeedS then\
\009\009term.setTextColour(InterFace.cSpeedA)\
\009else\
\009\009term.setTextColour(InterFace.cSpeedD)\
\009end\
\009write(\" >>\")\
\
\009term.setCursorPos( TermW-1, 1 )\
\009term.setBackgroundColor( colors.black )\
\009term.setTextColour( InterFace.cExit )\
\009write(\" X\")\
\009term.setBackgroundColor(colors.black)\
end\
\
function InterFace.render()\
\009local id,p1,p2,p3 = os.pullEvent()\
\009if id == \"mouse_click\" then\
\009\009if p3 == 1 and p2 == TermW then\
            return \"end\"\
        elseif p3 == TermH and p2 >= TermW-7 and p2 <= TermW-6 then\
            return \"retry\"\
        elseif p3 == TermH and p2 >= TermW-4 and p2 <= TermW-3 then\
            bPaused = not bPaused\
            fSpeedS = false\
            Speed = (bPaused and 0) or nSpeed\
            if Speed > 0 then\
                Tick = os.startTimer(Speed)\
            else\
                Tick = nil\
            end\
            InterFace.drawBar()\
        elseif p3 == TermH and p2 >= TermW-1 then\
            bPaused = false\
            fSpeedS = not fSpeedS\
            Speed = (fSpeedS and fSpeed) or nSpeed\
            Tick = os.startTimer(Speed)\
            InterFace.drawBar()\
\009\009elseif p3-1 < YOrgin+SizeH+1 and p3-1 > YOrgin and\
               p2 < XOrgin+SizeW+1 and p2 > XOrgin then\
            local eobj = tScreen[p2-XOrgin][p3-YOrgin-1]\
            local erobj = tostring(tScreen[p2-XOrgin][p3-YOrgin-1].robot)\
            if (erobj == \"zz\" or erobj == \"nil\") and not eobj.wall == true and not eobj.space == true and Blocks > 0 then\
                addWall(p2-XOrgin,p3-YOrgin-1)\
                Blocks = Blocks-1\
                InterFace.drawBar()\
                drawMap()\
            end\
\009\009end\
\009elseif id == \"timer\" and p1 == Tick then\
\009\009gRender(\"tick\")\
        drawMap()\
        if Speed > 0 then\
            Tick = os.startTimer(Speed)\
        else\
            Tick = nil\
        end\
\009end\
end\
\
local function startG(LevelN)\
\009drawStars()\
\009loadLevel(LevelN)\
\009centerOrgin()\
\009local create = true\
\009drawMap()\
\009InterFace.drawBar()\
\009gRender(\"start\")\
\009drawMap()\
\009\
\009local NExit = true\
\009if aExits == 0 then\
\009\009NExit = false\
\009end\
\009\
\009while true do\
\009\009local isExit = InterFace.render()\
\009\009if isExit == \"end\" then\
\009\009    return nil\
\009\009elseif isExit == \"retry\" then\
\009\009    return LevelN\
\009\009elseif fExit == \"yes\" then\
\009\009\009if fs.exists( fs.getDir( shell.getRunningProgram() ) .. \"/levels/\" .. tostring(LevelN + 1) ) then\
\009\009\009    return LevelN + 1\
\009\009\009else\
\009\009\009    return nil\
\009\009\009end\
\009\009end\
\009\009if aExits == 0 and NExit == true then\
\009\009\009fExit = \"yes\"\
\009\009end\
\009end\
end\
\
local ok, err = true, nil\
\
--Menu--\
local sStartLevel = tArgs[1]\
if ok and not sStartLevel then\
    ok, err = pcall( function()\
        term.setTextColor(colors.white)\
        term.setBackgroundColor( colors.black )\
        term.clear()\
        drawStars()\
        term.setTextColor( colors.red )\
        printCentred( TermH/2 - 1, \"  REDIRECTION  \" )\
        printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
        term.setTextColor( colors.yellow )\
        printCentred( TermH/2 + 2, \"  Click to Begin  \" )\
        os.pullEvent( \"mouse_click\" )\
    end )\
end\
\
--Game--\
if ok then\
    ok,err = pcall( function()\
        local nLevel\
        if sStartLevel then\
            nLevel = tonumber( sStartLevel )\
        else\
            nLevel = 1\
        end\
        while nLevel do\
            reset()\
            nLevel = startG(nLevel)\
        end\
    end )\
end\
\
--Upsell screen--\
if ok then\
    ok, err = pcall( function()\
        term.setTextColor(colors.white)\
        term.setBackgroundColor( colors.black )\
        term.clear()\
        drawStars()\
        term.setTextColor( colors.red )\
        if TermW >= 40 then\
            printCentred( TermH/2 - 1, \"  Thank you for playing Redirection  \" )\
            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\
            term.setTextColor( colors.yellow )\
            printCentred( TermH/2 + 3, \"  http://www.redirectiongame.com  \" )\
        else\
            printCentred( TermH/2 - 2, \"  Thank you for  \" )\
            printCentred( TermH/2 - 1, \"  playing Redirection  \" )\
            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\
            term.setTextColor( colors.yellow )\
            printCentred( TermH/2 + 3, \"  www.redirectiongame.com  \" )\
        end\
        parallel.waitForAll(\
            function() sleep(2) end,\
            function() os.pullEvent( \"mouse_click\" ) end\
        )\
    end )\
end\
\
--Clear and exit--\
term.setCursorPos(1,1)\
term.setTextColor(colors.white)\
term.setBackgroundColor(colors.black)\
term.clear()\
if not ok then\
    if err == \"Terminated\" then\
        print( \"Check out the full version of Redirection:\" )\
        print( \"http://www.redirectiongame.com\" )\
    else\
        printError( err )\
    end\
end",
      "\
local tBiomes = {\
\009\"in a forest\",\
\009\"in a pine forest\",\
\009\"knee deep in a swamp\",\
\009\"in a mountain range\",\
\009\"in a desert\",\
\009\"in a grassy plain\",\
\009\"in frozen tundra\",\
}\
\
local function hasTrees( _nBiome )\
\009return _nBiome <= 3\
end\
\
local function hasStone( _nBiome )\
\009return _nBiome == 4\
end\
\
local function hasRivers( _nBiome )\
\009return _nBiome ~= 3 and _nBiome ~= 5\
end\
\
local items = {\
\009[\"no tea\"] = {\
\009\009droppable = false,\
\009\009desc = \"Pull yourself together man.\",\
\009},\
\009[\"a pig\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009drops = { \"some pork\" },\
\009\009aliases = { \"pig\" },\
\009\009desc = \"The pig has a square nose.\",\
\009},\
\009[\"a cow\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009aliases = { \"cow\" },\
\009\009desc = \"The cow stares at you blankly.\",\
\009},\
\009[\"a sheep\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009hitDrops = { \"some wool\" },\
\009\009aliases = { \"sheep\" },\
\009\009desc = \"The sheep is fluffy.\",\
\009},\
\009[\"a chicken\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009drops = { \"some chicken\" },\
\009\009aliases = { \"chicken\" },\
\009\009desc = \"The chicken looks delicious.\",\
\009},\
\009[\"a creeper\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"creeper\" },\
\009\009desc = \"The creeper needs a hug.\",\
\009},\
\009[\"a skeleton\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"skeleton\" },\
\009\009nocturnal = true,\
\009\009desc = \"The head bone's connected to the neck bone, the neck bone's connected to the chest bone, the chest bone's connected to the arm bone, the arm bone's connected to the bow, and the bow is pointed at you.\",\
\009},\
\009[\"a zombie\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"zombie\" },\
\009\009nocturnal = true,\
\009\009desc = \"All he wants to do is eat your brains.\",\
\009},\
\009[\"a spider\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"spider\" },\
\009\009desc = \"Dozens of eyes stare back at you.\",\
\009},\
\009[\"a cave entrance\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"cave entance\", \"cave\", \"entrance\" },\
\009\009desc = \"The entrance to the cave is dark, but it looks like you can climb down.\",\
\009},\
\009[\"an exit to the surface\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"exit to the surface\", \"exit\", \"opening\" },\
\009\009desc = \"You can just see the sky through the opening.\",\
\009},\
\009[\"a river\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"river\" },\
\009\009desc = \"The river flows majestically towards the horizon. It doesn't do anything else.\",\
\009},\
\009[\"some wood\"] = {\
\009\009aliases = { \"wood\" },\
\009\009material = true,\
\009\009desc = \"You could easilly craft this wood into planks.\",\
\009},\
\009[\"some planks\"] = {\
\009\009aliases = { \"planks\", \"wooden planks\", \"wood planks\" },\
\009\009desc = \"You could easilly craft these planks into sticks.\",\
\009},\
\009[\"some sticks\"] = {\
\009\009aliases = { \"sticks\", \"wooden sticks\", \"wood sticks\" },\
\009\009desc = \"A perfect handle for torches or a pickaxe.\",\
\009},\
\009[\"a crafting table\"] = {\
\009\009aliases = { \"crafting table\", \"craft table\", \"work bench\", \"workbench\", \"crafting bench\", \"table\", },\
\009\009desc = \"It's a crafting table. I shouldn't tell you this, but these don't actually do anything in this game, you can craft tools whenever you like.\",\
\009},\
\009[\"a furnace\"] = {\
\009\009aliases = { \"furnace\" },\
\009\009desc = \"It's a furnace. Between you and me, these don't actually do anything in this game.\",\
\009},\
\009[\"a wooden pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"wooden pick\", \"wooden pickaxe\", \"wood pick\", \"wood pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks good for breaking stone and coal.\",\
\009},\
\009[\"a stone pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"stone pick\", \"stone pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks good for breaking iron.\",\
\009},\
\009[\"an iron pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"iron pick\", \"iron pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks strong enough to break diamond.\",\
\009},\
\009[\"a diamond pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"diamond pick\", \"diamond pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"pick\",\
\009\009desc = \"Best. Pickaxe. Ever.\",\
\009},\
\009[\"a wooden sword\"] = {\
\009\009aliases = { \"sword\", \"wooden sword\", \"wood sword\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"sword\",\
\009\009desc = \"Flimsy, but better than nothing.\",\
\009},\
\009[\"a stone sword\"] = {\
\009\009aliases = { \"sword\", \"stone sword\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"sword\",\
\009\009desc = \"A pretty good sword.\",\
\009},\
\009[\"an iron sword\"] = {\
\009\009aliases = { \"sword\", \"iron sword\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"sword\",\
\009\009desc = \"This sword can slay any enemy.\",\
\009},\
\009[\"a diamond sword\"] = {\
\009\009aliases = { \"sword\", \"diamond sword\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"sword\",\
\009\009desc = \"Best. Sword. Ever.\",\
\009},\
\009[\"a wooden shovel\"] = {\
\009\009aliases = { \"shovel\", \"wooden shovel\", \"wood shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"a stone shovel\"] = {\
\009\009aliases = { \"shovel\", \"stone shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"an iron shovel\"] = {\
\009\009aliases = { \"shovel\", \"iron shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"a diamond shovel\"] = {\
\009\009aliases = { \"shovel\", \"diamond shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"some coal\"] = {\
\009\009aliases = { \"coal\" },\
\009\009ore = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"That coal looks useful for building torches, if only you had a pickaxe to mine it.\",\
\009},\
\009[\"some dirt\"] = {\
\009\009aliases = { \"dirt\" },\
\009\009material = true,\
\009\009desc = \"Why not build a mud hut?\",\
\009},\
\009[\"some stone\"] = {\
\009\009aliases = { \"stone\", \"cobblestone\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009infinite = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"Stone is useful for building things, and making stone pickaxes.\",\
\009},\
\009[\"some iron\"] = {\
\009\009aliases = { \"iron\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"pick\",\
\009\009desc = \"That iron looks mighty strong, you'll need a stone pickaxe to mine it.\",\
\009},\
\009[\"some diamond\"] = {\
\009\009aliases = { \"diamond\", \"diamonds\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"pick\",\
\009\009desc = \"Sparkly, rare, and impossible to mine without an iron pickaxe.\",\
\009},\
\009[\"some torches\"] = {\
\009\009aliases = { \"torches\", \"torch\" },\
\009\009desc = \"These won't run out for a while.\",\
\009},\
\009[\"a torch\"] = {\
\009\009aliases = { \"torch\" },\
\009\009desc = \"Fire, fire, burn so bright, won't you light my cave tonight?\",\
\009},\
\009[\"some wool\"] = {\
\009\009aliases = { \"wool\" },\
\009\009material = true,\
\009\009desc = \"Soft and good for building.\",\
\009},\
\009[\"some pork\"] = {\
\009\009aliases = { \"pork\", \"porkchops\" },\
\009\009food = true,\
\009\009desc = \"Delicious and nutricious.\",\
\009},\
\009[\"some chicken\"] = {\
\009\009aliases = { \"chicken\" },\
\009\009food = true,\
\009\009desc = \"Finger licking good.\",\
\009},\
}\
\
local tAnimals = {\
\009\"a pig\", \"a cow\", \"a sheep\", \"a chicken\",\
}\
\
local tMonsters = {\
\009\"a creeper\", \"a skeleton\", \"a zombie\", \"a spider\"\
}\
\
local tRecipes = {\
\009[\"some planks\"] = { \"some wood\" },\
\009[\"some sticks\"] = { \"some planks\" },\
\009[\"some sticks\"] = { \"some planks\" },\
\009[\"a crafting table\"] = { \"some planks\" },\
\009[\"a furnace\"] = { \"some stone\" },\
\009[\"some torches\"] = { \"some sticks\", \"some coal\" },\
\009\
\009[\"a wooden pickaxe\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone pickaxe\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron pickaxe\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond pickaxe\"] = { \"some diamond\", \"some sticks\" },\
\
\009[\"a wooden sword\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone sword\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron sword\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond sword\"] = { \"some diamond\", \"some sticks\" },\
\
\009[\"a wooden shovel\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone shovel\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron shovel\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond shovel\"] = { \"some diamond\", \"some sticks\" },\
}\
\
local tGoWest = {\
\009\"(life is peaceful there)\",\
\009\"(lots of open air)\",\
\009\"(to begin life anew)\",\
\009\"(this is what we'll do)\",\
\009\"(sun in winter time)\",\
\009\"(we will do just fine)\",\
\009\"(where the skies are blue)\",\
\009\"(this and more we'll do)\",\
}\
local nGoWest = 0\
\
local bRunning = true\
local tMap = { { {}, }, }\
local x,y,z = 0,0,0\
local inventory = {\
\009[\"no tea\"] = items[\"no tea\"],\
}\
\
local nTurn = 0\
local nTimeInRoom = 0\
local bInjured = false\
\
local tDayCycle = {\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"The sun is setting.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"The sun is rising.\",\
}\
\
local function getTimeOfDay()\
\009return math.fmod( math.floor(nTurn/3), #tDayCycle ) + 1\
end\
\
local function isSunny()\
\009return (getTimeOfDay() < 10)\
end\
\
local function getRoom( x, y, z, dontCreate )\
\009tMap[x] = tMap[x] or {}\
\009tMap[x][y] = tMap[x][y] or {}\
\009if not tMap[x][y][z] and dontCreate ~= true then\
 \009\009local room = {\
 \009\009\009items = {},\
 \009\009\009exits = {},\
 \009\009\009nMonsters = 0,\
 \009\009}\
\009\009tMap[x][y][z] = room\
\009\009\
\009\009if y == 0 then\
\009\009\009-- Room is above ground\
\
\009\009\009-- Pick biome\
\009\009\009room.nBiome = math.random( 1, #tBiomes )\
\009\009\009room.trees = hasTrees( room.nBiome )\
\009\009\
\009\009\009-- Add animals\
\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009for n = 1,math.random(1,2) do\
\009\009\009\009\009local sAnimal = tAnimals[ math.random( 1, #tAnimals ) ]\
\009\009\009\009\009room.items[ sAnimal ] = items[ sAnimal ]\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009-- Add surface ore\
\009\009\009if math.random(1,5) == 1 or hasStone( room.nBiome ) then\
\009\009\009\009room.items[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.items[ \"some coal\" ] = items[ \"some coal\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 and hasRivers( room.nBiome ) then\
\009\009\009\009room.items[ \"a river\" ] = items[ \"a river\" ]\
\009\009\009end\
\
\009\009\009-- Add exits\
\009\009\009room.exits = {\
\009\009\009\009[\"north\"] = true,\
\009\009\009\009[\"south\"] = true,\
\009\009\009\009[\"east\"] = true,\
\009\009\009\009[\"west\"] = true,\
\009\009\009}\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.exits[\"down\"] = true\
\009\009\009\009room.items[\"a cave entrance\"] = items[\"a cave entrance\"]\
\009\009\009end\
\009\009\009\009\009\009\
\009\009else\
\009\009\009-- Room is underground\
\009\009\009-- Add exits\
\009\009\009local function tryExit( sDir, sOpp, x, y, z )\
\009\009\009\009local adj = getRoom( x, y, z, true )\
\009\009\009\009if adj then\
\009\009\009\009\009if adj.exits[sOpp] then\
\009\009\009\009\009\009room.exits[sDir] = true\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009\009\009room.exits[sDir] = true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if y == -1 then\
\009\009\009\009local above = getRoom( x, y + 1, z )\
\009\009\009\009if above.exits[\"down\"] then\
\009\009\009\009\009room.exits[\"up\"] = true\
\009\009\009\009\009room.items[\"an exit to the surface\"] = items[\"an exit to the surface\"]\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009tryExit( \"up\", \"down\", x, y + 1, z )\
\009\009\009end\
\009\009\009\
\009\009\009if y > -3 then\
\009\009\009\009tryExit( \"down\", \"up\", x, y - 1, z )\
\009\009\009end\
\009\009\009\
\009\009\009tryExit( \"east\", \"west\", x - 1, y, z )\
\009\009\009tryExit( \"west\", \"east\", x + 1, y, z )\
\009\009\009tryExit( \"north\", \"south\", x, y, z + 1 )\
\009\009\009tryExit( \"south\", \"north\", x, y, z - 1 )\009\
\009\009\009\
\009\009\009-- Add ores\
\009\009\009room.items[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009room.items[ \"some coal\" ] = items[ \"some coal\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.items[ \"some iron\" ] = items[ \"some iron\" ]\
\009\009\009end\
\009\009\009if y == -3 and math.random(1,15) == 1 then\
\009\009\009\009room.items[ \"some diamond\" ] = items[ \"some diamond\" ]\
\009\009\009end\
\009\009\009\
\009\009\009-- Turn out the lights\
\009\009\009room.dark = true\
\009\009end\
\009end\
\009return tMap[x][y][z]\
end\
\
local function itemize( t )\
\009local item = next( t )\
\009if item == nil then\
\009\009return \"nothing\"\
\009end\
\009\
\009local text = \"\"\
\009while item do\
\009\009text = text .. item\
\009\009\
\009\009local nextItem = next( t, item )\
\009\009if nextItem ~= nil then\
\009\009\009local nextNextItem = next( t, nextItem )\
\009\009\009if nextNextItem == nil then\
\009\009\009\009text = text .. \" and \"\
\009\009\009else\
\009\009\009\009text = text .. \", \"\
\009\009\009end\
\009\009end\
\009\009item = nextItem\
\009end\
\009return text\
end\
\
local function findItem( _tList, _sQuery )\
\009for sItem, tItem in pairs( _tList ) do\
\009\009if sItem == _sQuery then\
\009\009\009return sItem\
\009\009end\
\009\009if tItem.aliases ~= nil then\
\009\009\009for n, sAlias in pairs( tItem.aliases ) do\
\009\009\009\009if sAlias == _sQuery then\
\009\009\009\009\009return sItem\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
local tMatches = {\
\009[\"wait\"] = {\
\009\009\"wait\",\
\009},\
\009[\"look\"] = {\
\009\009\"look at the ([%a ]+)\",\
\009\009\"look at ([%a ]+)\",\
\009\009\"look\",\
\009\009\"inspect ([%a ]+)\",\
\009\009\"inspect the ([%a ]+)\",\
\009\009\"inspect\",\
\009},\
\009[\"inventory\"] = {\
\009\009\"check self\",\
\009\009\"check inventory\",\
\009\009\"inventory\",\
\009\009\"i\",\
\009},\
\009[\"go\"] = {\
\009\009\"go (%a+)\",\
\009\009\"travel (%a+)\",\
\009\009\"walk (%a+)\",\
\009\009\"run (%a+)\",\
\009\009\"go\",\
\009},\
\009[\"dig\"] = {\
\009\009\"dig (%a+) using ([%a ]+)\",\
\009\009\"dig (%a+) with ([%a ]+)\",\
\009\009\"dig (%a+)\",\
\009\009\"dig\",\
\009},\
\009[\"take\"] = {\
\009\009\"pick up the ([%a ]+)\",\
\009\009\"pick up ([%a ]+)\",\
\009\009\"pickup ([%a ]+)\",\
\009\009\"take the ([%a ]+)\",\
\009\009\"take ([%a ]+)\",\
\009\009\"take\",\
\009},\
\009[\"drop\"] = {\
\009\009\"put down the ([%a ]+)\",\
\009\009\"put down ([%a ]+)\",\
\009\009\"drop the ([%a ]+)\",\
\009\009\"drop ([%a ]+)\",\
\009\009\"drop\",\
\009},\
\009[\"place\"] = {\
\009\009\"place the ([%a ]+)\",\
\009\009\"place ([%a ]+)\",\
\009\009\"place\",\
\009},\
\009[\"cbreak\"] = {\
\009\009\"punch the ([%a ]+)\",\
\009\009\"punch ([%a ]+)\",\
\009\009\"punch\",\
\009\009\"break the ([%a ]+) with the ([%a ]+)\",\
\009\009\"break ([%a ]+) with ([%a ]+) \",\
\009\009\"break the ([%a ]+)\",\
\009\009\"break ([%a ]+)\",\
\009\009\"break\",\
\009},\
\009[\"mine\"] = {\
\009\009\"mine the ([%a ]+) with the ([%a ]+)\",\
\009\009\"mine ([%a ]+) with ([%a ]+)\",\
\009\009\"mine ([%a ]+)\",\
\009\009\"mine\",\
\009},\
\009[\"attack\"] = {\
\009\009\"attack the ([%a ]+) with the ([%a ]+)\",\
\009\009\"attack ([%a ]+) with ([%a ]+)\",\
\009\009\"attack ([%a ]+)\",\
\009\009\"attack\",\
\009\009\"kill the ([%a ]+) with the ([%a ]+)\",\
\009\009\"kill ([%a ]+) with ([%a ]+)\",\
\009\009\"kill ([%a ]+)\",\
\009\009\"kill\",\
\009\009\"hit the ([%a ]+) with the ([%a ]+)\",\
\009\009\"hit ([%a ]+) with ([%a ]+)\",\
\009\009\"hit ([%a ]+)\",\
\009\009\"hit\",\
\009},\
\009[\"craft\"] = {\
\009\009\"craft a ([%a ]+)\",\
\009\009\"craft some ([%a ]+)\",\
\009\009\"craft ([%a ]+)\",\
\009\009\"craft\",\
\009\009\"make a ([%a ]+)\",\
\009\009\"make some ([%a ]+)\",\
\009\009\"make ([%a ]+)\",\
\009\009\"make\",\
\009},\
\009[\"build\"] = {\
\009\009\"build ([%a ]+) out of ([%a ]+)\",\
\009\009\"build ([%a ]+) from ([%a ]+)\",\
\009\009\"build ([%a ]+)\",\
\009\009\"build\",\
\009},\
\009[\"eat\"] = {\
\009\009\"eat a ([%a ]+)\",\
\009\009\"eat the ([%a ]+)\",\
\009\009\"eat ([%a ]+)\",\
\009\009\"eat\",\
\009},\
\009[\"help\"] = {\
\009\009\"help me\",\
\009\009\"help\",\
\009},\
\009[\"exit\"] = {\
\009\009\"exit\",\
\009\009\"quit\",\
\009\009\"goodbye\",\
\009\009\"good bye\",\
\009\009\"bye\",\
\009\009\"farewell\",\
\009},\
}\
\
local commands = {}\
local function doCommand( text )\
\009if text == \"\" then\
\009\009commands[ \"noinput\" ]()\
\009\009return\
\009end\
\009\
\009for sCommand, t in pairs( tMatches ) do\
\009\009for n, sMatch in pairs( t ) do\
\009\009\009local tCaptures = { string.match( text, \"^\" .. sMatch .. \"$\" ) }\
\009\009\009if #tCaptures ~= 0 then\
\009\009\009\009local fnCommand = commands[ sCommand ]\
\009\009\009\009if #tCaptures == 1 and tCaptures[1] == sMatch then\
\009\009\009\009\009fnCommand()\
\009\009\009\009else\
\009\009\009\009\009fnCommand( table.unpack( tCaptures ) )\
\009\009\009\009end\
\009\009\009\009return\
\009\009\009end\
\009\009end\
\009end\
\009commands[ \"badinput\" ]()\
end\
\
function commands.wait()\
\009print( \"Time passes...\" )\
end\
\
function commands.look( _sTarget )\
\009local room = getRoom( x,y,z )\
\009if room.dark then\
\009\009print( \"It is pitch dark.\" )\
\009\009return\
\009end\
\
\009if _sTarget == nil then\
\009\009-- Look at the world\
\009\009if y == 0 then\
\009\009\009io.write( \"You are standing \" .. tBiomes[room.nBiome] .. \". \" )\
\009\009\009print( tDayCycle[ getTimeOfDay() ] )\
\009\009else\
\009\009\009io.write( \"You are underground. \" )\
\009\009\009if next( room.exits ) ~= nil then\
\009\009\009\009print( \"You can travel \"..itemize( room.exits )..\".\" )\
\009\009\009else\
\009\009\009\009print()\
\009\009\009end\
\009\009end\
\009\009if next( room.items ) ~= nil then\
\009\009\009print( \"There is \" .. itemize( room.items ) .. \" here.\" )\
\009\009end\
\009\009if room.trees then\
\009\009\009print( \"There are trees here.\" )\
\009\009end\
\009\009\
\009else\
\009\009-- Look at stuff\
\009\009if room.trees and (_sTarget == \"tree\" or _sTarget == \"trees\") then\
\009\009\009print( \"The trees look easy to break.\" )\
\009\009elseif _sTarget == \"self\" or _sTarget == \"myself\" then\
\009\009\009print( \"Very handsome.\" )\
\009\009else\
\009\009\009local tItem = nil\
\009\009\009local sItem = findItem( room.items, _sTarget )\
\009\009\009if sItem then\
\009\009\009\009tItem = room.items[sItem]\
\009\009\009else\
\009\009\009\009sItem = findItem( inventory, _sTarget )\
\009\009\009\009if sItem then\
\009\009\009\009\009tItem = inventory[sItem]\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if tItem then\
\009\009\009\009print( tItem.desc or (\"You see nothing special about \"..sItem..\".\") )\
\009\009\009else\
\009\009\009\009print( \"You don't see any \".._sTarget..\" here.\" )\
\009\009\009end\
\009\009end\
\009end\
end\
\
function commands.go( _sDir )\
\009local room = getRoom( x,y,z )\
\009if _sDir == nil then\
\009\009print( \"Go where?\" )\
\009\009return\
\009end\
\009\
\009if nGoWest ~= nil then\
\009\009if _sDir == \"west\" then\
\009\009\009nGoWest = nGoWest + 1\
\009\009\009if nGoWest > #tGoWest then\
\009\009\009\009nGoWest = 1\
\009\009\009end\
\009\009\009print( tGoWest[ nGoWest ] )\
\009\009else\
\009\009\009if nGoWest > 0 or nTurn > 6 then\
\009\009\009\009nGoWest = nil\
\009\009\009end\
\009\009end\
\009end\
\009\
\009if room.exits[_sDir] == nil then\
\009\009print( \"You can't go that way.\" )\
\009\009return\
\009end\
\009\
\009if _sDir == \"north\" then\
\009\009z = z + 1\
\009elseif _sDir == \"south\" then\
\009\009z = z - 1\
\009elseif _sDir == \"east\" then\
\009\009x = x - 1\
\009elseif _sDir == \"west\" then\
\009\009x = x + 1\
\009elseif _sDir == \"up\" then\
\009\009y = y + 1\
\009elseif _sDir == \"down\" then\
\009\009y = y - 1\
\009else\
\009\009print( \"I don't understand that direction.\" )\
\009\009return\
\009end\
\009\
\009nTimeInRoom = 0\
\009doCommand( \"look\" )\
end\
\
function commands.dig( _sDir, _sTool )\
\009local room = getRoom( x,y,z )\
\009if _sDir == nil then\
\009\009print( \"Dig where?\" )\
\009\009return\
\009end\
\009\
\009local sTool = nil\
\009local tTool = nil\
\009if _sTool ~= nil then\
\009\009sTool = findItem( inventory, _sTool )\
\009\009if not sTool then\
\009\009\009print( \"You're not carrying a \".._sTool..\".\" )\
\009\009\009return\
\009\009end\
\009\009tTool = inventory[ sTool ]\
\009end\
\009\
\009local room = getRoom( x, y, z )\
\009local bActuallyDigging = (room.exits[ _sDir ] ~= true)\
\009if bActuallyDigging then\
\009\009if sTool == nil or tTool.toolType ~= \"pick\" then\
\009\009\009print( \"You need to use a pickaxe to dig through stone.\" )\
\009\009\009return\
\009\009end\
\009end\
\009\
\009if _sDir == \"north\" then\
\009\009room.exits[\"north\"] = true\
\009\009z = z + 1\
\009\009getRoom( x, y, z ).exits[\"south\"] = true\
\
\009elseif _sDir == \"south\" then\
\009\009room.exits[\"south\"] = true\
\009\009z = z - 1\
\009\009getRoom( x, y, z ).exits[\"north\"] = true\
\009\009\
\009elseif _sDir == \"east\" then\
\009\009room.exits[\"east\"] = true\
\009\009x = x - 1\
\009\009getRoom( x, y, z ).exits[\"west\"] = true\
\009\009\
\009elseif _sDir == \"west\" then\
\009\009room.exits[\"west\"] = true\
\009\009x = x + 1\
\009\009getRoom( x, y, z ).exits[\"east\"] = true\
\009\009\
\009elseif _sDir == \"up\" then\
\009\009if y == 0 then\
\009\009\009print( \"You can't dig that way.\" )\
\009\009\009return\
\009\009end\
\
\009\009room.exits[\"up\"] = true\
\009\009if y == -1 then\
\009\009\009room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\
\009\009end\
\009\009y = y + 1\
\009\009\
\009\009room = getRoom( x, y, z )\
\009\009room.exits[\"down\"] = true\
\009\009if y == 0 then\
\009\009\009room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\
\009\009end\
\009\009\
\009elseif _sDir == \"down\" then\
\009\009if y <= -3 then\
\009\009\009print( \"You hit bedrock.\" )\
\009\009\009return\
\009\009end\
\
\009\009room.exits[\"down\"] = true\
\009\009if y == 0 then\
\009\009\009room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\
\009\009end\
\009\009y = y - 1\
\009\009\
\009\009room = getRoom( x, y, z )\
\009\009room.exits[\"up\"] = true\
\009\009if y == -1 then\
\009\009\009room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\
\009\009end\
\009\009\
\009else\
\009\009print( \"I don't understand that direction.\" )\
\009\009return\
\009end\
\009\
\009--\
\009if bActuallyDigging then\
\009\009if _sDir == \"down\" and y == -1 or\
\009\009   _sDir == \"up\" and y == 0 then\
\009\009\009inventory[ \"some dirt\" ] = items[ \"some dirt\" ]\
\009\009\009inventory[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some dirt and stone.\" )\
\009\009else\
\009\009\009inventory[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some stone.\" )\
\009\009end\
\009end\
\009\
\009nTimeInRoom = 0\
\009doCommand( \"look\" )\
end\
\
function commands.inventory()\
\009print( \"You are carrying \" .. itemize( inventory ) .. \".\" )\
end\
\
function commands.drop( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Drop what?\" )\
\009\009return\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( inventory, _sItem )\
\009if sItem then\
\009\009local tItem = inventory[ sItem ]\
\009\009if tItem.droppable == false then\
\009\009\009print( \"You can't drop that.\" )\
\009\009else\
\009\009\009room.items[ sItem ] = tItem\
\009\009\009inventory[ sItem ] = nil\
\009\009\009print( \"Dropped.\" )\
\009\009end\
\009else\
\009\009print( \"You don't have a \".._sItem..\".\" )\
\009end\
end\
\
function commands.place( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Place what?\" )\
\009\009return\
\009end\
\009\
\009if _sItem == \"torch\" or _sItem == \"a torch\" then\
\009\009local room = getRoom( x,y,z )\
\009\009if inventory[\"some torches\"] or inventory[\"a torch\"] then\
\009\009\009inventory[\"a torch\"] = nil\
\009\009\009room.items[\"a torch\"] = items[\"a torch\"]\
\009\009\009if room.dark then\
\009\009\009\009print( \"The cave lights up under the torchflame.\" )\
\009\009\009\009room.dark = false\
\009\009\009elseif y == 0 and not isSunny() then\
\009\009\009\009print( \"The night gets a little brighter.\" )\
\009\009\009else\
\009\009\009\009print( \"Placed.\" )\
\009\009\009end\
\009\009else\
\009\009\009print( \"You don't have torches.\" )\
\009\009end\
\009\009return\
\009end\
\009\
\009commands.drop( _sItem )\
end\
\
function commands.take( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Take what?\" )\
\009\009return\
\009end\
\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( room.items, _sItem )\
\009if sItem then\
\009\009local tItem = room.items[ sItem ]\
\009\009if tItem.heavy == true then\
\009\009\009print( \"You can't carry \"..sItem..\".\" )\
\009\009elseif tItem.ore == true then\
\009\009\009print( \"You need to mine this ore.\" )\
\009\009else\
\009\009\009if tItem.infinite ~= true then\
\009\009\009\009room.items[ sItem ] = nil\
\009\009\009end\
\009\009\009inventory[ sItem ] = tItem\
\009\009\009\
\009\009\009if inventory[\"some torches\"] and inventory[\"a torch\"] then\
\009\009\009\009inventory[\"a torch\"] = nil\
\009\009\009end\
\009\009\009if sItem == \"a torch\" and y < 0 then\
\009\009\009\009room.dark = true\
\009\009\009\009print( \"The cave plunges into darkness.\" )\
\009\009\009else\
\009\009\009\009print( \"Taken.\" )\
\009\009\009end\
\009\009end\
\009else\
\009\009print( \"You don't see a \".._sItem..\" here.\" )\
\009end\
end\
\
function commands.mine( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Mine what?\" )\
\009\009return\
\009end\
\009if _sTool == nil then\
\009\009print( \"Mine \".._sItem..\" with what?\" )\
\009\009return\
\009end\009\
\009commands.cbreak( _sItem, _sTool )\
end\
\
function commands.attack( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Attack what?\" )\
\009\009return\
\009end\
\009commands.cbreak( _sItem, _sTool )\
end\
\
function commands.cbreak( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Break what?\" )\
\009\009return\
\009end\
\009\
\009local sTool = nil\
\009if _sTool ~= nil then\
\009\009sTool = findItem( inventory, _sTool )\
\009\009if sTool == nil then\
\009\009\009print( \"You're not carrying a \".._sTool..\".\" )\
\009\009\009return\
\009\009end\
\009end\
\
\009local room = getRoom( x,y,z )\
\009if _sItem == \"tree\" or _sItem == \"trees\" or _sItem == \"a tree\" then\
\009\009print( \"The tree breaks into blocks of wood, which you pick up.\" )\
\009\009inventory[ \"some wood\" ] = items[ \"some wood\" ]\
\009\009return\
\009elseif _sItem == \"self\" or _sItem == \"myself\" then\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You have died.\" )\
\009\009print( \"Score: &e0\" )\
\009\009term.setTextColour( colours.white )\
\009\009bRunning = false\
\009\009return\
\009end\
\009\
\009local sItem = findItem( room.items, _sItem )\
\009if sItem then\
\009\009local tItem = room.items[ sItem ]\
\009\009if tItem.ore == true then\
\009\009\009-- Breaking ore\
\009\009\009if not sTool then\
\009\009\009\009print( \"You need a tool to break this ore.\" )\
\009\009\009\009return\
\009\009\009end\
\009\009\009local tTool = inventory[ sTool ]\
\009\009\009if tTool.tool then\
\009\009\009\009if tTool.toolLevel < tItem.toolLevel then\
\009\009\009\009\009print( sTool ..\" is not strong enough to break this ore.\" )\
\009\009\009\009elseif tTool.toolType ~= tItem.toolType then\
\009\009\009\009\009print( \"You need a different kind of tool to break this ore.\" )\
\009\009\009\009else\
\009\009\009\009\009print( \"The ore breaks, dropping \"..sItem..\", which you pick up.\" )\
\009\009\009\009\009inventory[ sItem ] = items[ sItem ]\
\009\009\009\009\009if tItem.infinite ~= true then\
\009\009\009\009\009\009room.items[ sItem ] = nil\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009print( \"You can't break \"..sItem..\" with \"..sTool..\".\")\
\009\009\009end\
\009\009\009\
\009\009elseif tItem.creature == true then\
\009\009\009-- Fighting monsters (or pigs)\
\009\009\009local toolLevel = 0\
\009\009\009local tTool = nil\
\009\009\009if sTool then\
\009\009\009\009tTool = inventory[ sTool ]\
\009\009\009\009if tTool.toolType == \"sword\" then\
\009\009\009\009\009toolLevel = tTool.toolLevel\
\009\009\009\009end\
\009\009\009end\
\009\009\009\009\009\009\
\009\009\009local tChances = { 0.2, 0.4, 0.55, 0.8, 1 }\
\009\009\009if math.random() <= tChances[ toolLevel + 1 ] then\
\009\009\009\009room.items[ sItem ] = nil\
\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dies.\" )\
\009\
\009\009\009\009if tItem.drops then\
\009\009\009\009\009for n, sDrop in pairs( tItem.drops ) do\
\009\009\009\009\009\009if not room.items[sDrop] then\
\009\009\009\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\
\009\009\009\009\009\009\009room.items[sDrop] = items[sDrop]\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009\
\009\009\009\009if tItem.monster then\
\009\009\009\009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009print( \"The \"..tItem.aliases[1]..\" is injured by your blow.\" )\
\009\009\009end\
\009\009\009\
\009\009\009if tItem.hitDrops then\
\009\009\009\009for n, sDrop in pairs( tItem.hitDrops ) do\
\009\009\009\009\009if not room.items[sDrop] then\
\009\009\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\
\009\009\009\009\009\009room.items[sDrop] = items[sDrop]\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\
\009\009else\
\009\009\009print( \"You can't break \"..sItem..\".\" )\
\009\009end\
\009else\
\009\009print( \"You don't see a \".._sItem..\" here.\" )\
\009end\
end\
\
function commands.craft( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Craft what?\" )\
\009\009return\
\009end\
\009\
\009if _sItem == \"computer\" or _sItem == \"a computer\" then\
\009\009print( \"By creating a computer in a computer in a computer, you tear a hole in the spacetime continuum from which no mortal being can escape.\" )\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You have died.\" )\
\009\009print( \"Score: &e0\" )\
\009\009term.setTextColour( colours.white )\
\009\009bRunning = false\
\009\009return\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( items, _sItem )\
\009local tRecipe = (sItem and tRecipes[ sItem ]) or nil\
\009if tRecipe then\
\009\009for n,sReq in ipairs( tRecipe ) do\
\009\009\009if inventory[sReq] == nil then\
\009\009\009\009print( \"You don't have the items you need to craft \"..sItem..\".\" )\
\009\009\009\009return\
\009\009\009end\
\009\009end\
\009\009\
\009\009for n,sReq in ipairs( tRecipe ) do\
\009\009\009inventory[sReq] = nil\
\009\009end\
\009\009inventory[ sItem ] = items[ sItem ]\
\009\009if inventory[\"some torches\"] and inventory[\"a torch\"] then\
\009\009\009inventory[\"a torch\"] = nil\
\009\009end\
\009\009print( \"Crafted.\" )\
\009else\
\009\009print( \"You don't know how to make \"..(sItem or _sItem)..\".\" )\
\009end\009\
end\
\
function commands.build( _sThing, _sMaterial )\
\009if _sThing == nil then\
\009\009print( \"Build what?\" )\
\009\009return\
\009end\
\009\009\
\009local sMaterial = nil\
\009if _sMaterial == nil then\
\009\009for sItem, tItem in pairs( inventory ) do\
\009\009\009if tItem.material then\
\009\009\009\009sMaterial = sItem\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009if sMaterial == nil then\
\009\009\009print( \"You don't have any building materials.\" )\
\009\009\009return\
\009\009end\
\009else\
\009\009sMaterial = findItem( inventory, _sMaterial )\
\009\009if not sMaterial then\
\009\009\009print( \"You don't have any \".._sMaterial )\
\009\009\009return\
\009\009end\
\009\009\
\009\009if inventory[sMaterial].material ~= true then\
\009\009\009print( sMaterial..\" is not a good building material.\" )\
\009\009\009return\
\009\009end\
\009end\
\009\
\009local alias = nil\
\009if string.sub(_sThing, 1, 1) == \"a\" then\
\009\009alias = string.match( _sThing, \"a ([%a ]+)\" )\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009inventory[sMaterial] = nil\
\009room.items[ _sThing ] = {\
\009\009heavy = true,\
\009\009aliases = { alias },\
\009\009desc = \"As you look at your creation (made from \"..sMaterial..\"), you feel a swelling sense of pride.\",\
\009}\
\
\009print( \"Your construction is complete.\" )\
end\
\
function commands.help()\
\009local sText = \
\009\009\"Welcome to adventure, the greatest text adventure game on CraftOS. \" ..\
\009\009\"To get around the world, type actions, and the adventure will \" ..\
\009\009\"be read back to you. The actions availiable to you are go, look, inspect, inventory, \" ..\
\009\009\"take, drop, place, punch, attack, mine, dig, craft, build, eat and exit.\"\
\009print( sText )\
end\
\
function commands.eat( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Eat what?\" )\
\009\009return\
\009end\
\
\009local sItem = findItem( inventory, _sItem )\
\009if not sItem then\
\009\009print( \"You don't have any \".._sItem..\".\" )\
\009\009return\
\009end\
\009\
\009local tItem = inventory[sItem]\
\009if tItem.food then\
\009\009print( \"That was delicious!\" )\
\009\009inventory[sItem] = nil\
\009\009\
\009\009if bInjured then\
\009\009\009print( \"You are no longer injured.\" )\
\009\009\009bInjured = false\
\009\009end\
\009else\
\009\009print( \"You can't eat \"..sItem..\".\" )\
\009end\
end\
\
function commands.exit()\
\009bRunning = false\
end\
\
function commands.badinput()\
\009local tResponses = {\
\009\009\"I don't understand.\",\
\009\009\"I don't understand you.\",\
\009\009\"You can't do that.\",\
\009\009\"Nope.\",\
\009\009\"Huh?\",\
\009\009\"Say again?\",\
\009\009\"That's crazy talk.\",\
\009\009\"Speak clearly.\",\
\009\009\"I'll think about it.\",\
\009\009\"Let me get back to you on that one.\",\
\009\009\"That doesn't make any sense.\",\
\009\009\"What?\",\
\009}\
\009print( tResponses[ math.random(1,#tResponses) ] )\
end\
\
function commands.noinput()\
\009local tResponses = {\
\009\009\"Speak up.\",\
\009\009\"Enunciate.\",\
\009\009\"Project your voice.\",\
\009\009\"Don't be shy.\",\
\009\009\"Use your words.\",\
\009}\
\009print( tResponses[ math.random(1,#tResponses) ] )\
end\
\
local function simulate()\
\009local bNewMonstersThisRoom = false\
\009\
\009-- Spawn monsters in nearby rooms\
\009for sx = -2,2 do\
\009\009for sy = -1,1 do\
\009\009\009for sz = -2,2 do\
\009\009\009\009local h = y + sy\
\009\009\009\009if h >= -3 and h <= 0 then\
\009\009\009\009\009local room = getRoom( x + sx, h, z + sz )\
\009\009\009\009\009\
\009\009\009\009\009-- Spawn monsters\
\009\009\009\009\009if room.nMonsters < 2 and\
\009\009\009\009\009   ((h == 0 and not isSunny() and not room.items[\"a torch\"]) or room.dark) and\
\009\009\009\009\009   math.random(1,6) == 1 then\
\009\009\009\009\009   \
\009\009\009\009\009\009local sMonster = tMonsters[ math.random(1,#tMonsters) ]\
\009\009\009\009\009\009if room.items[ sMonster ] == nil then\
\009\009\009\009\009   \009\009room.items[ sMonster ] = items[ sMonster ]\
\009\009\009\009\009   \009\009room.nMonsters = room.nMonsters + 1\
\009\009\009\009\009   \009\009\
\009\009\009\009\009   \009\009if sx == 0 and sy == 0 and sz == 0 and not room.dark then\
\009\009\009\009\009   \009\009\009print( \"From the shadows, \"..sMonster..\" appears.\" )\
\009\009\009\009\009   \009\009\009bNewMonstersThisRoom = true\
\009\009\009\009\009   \009\009end\
\009\009\009\009\009\009end\009\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009-- Burn monsters\
\009\009\009\009\009if h == 0 and isSunny() then\
\009\009\009\009\009\009for n,sMonster in ipairs( tMonsters ) do\
\009\009\009\009\009\009\009if room.items[sMonster] and items[sMonster].nocturnal then\
\009\009\009\009\009\009\009\009room.items[sMonster] = nil\
\009\009\009\009\009\009   \009\009if sx == 0 and sy == 0 and sz == 0 and not room.dark then\
\009\009\009\009\009\009   \009\009\009print( \"With the sun high in the sky, the \"..items[sMonster].aliases[1]..\" bursts into flame and dies.\" )\
\009\009\009\009\009\009   \009\009end\
\009\009\009\009\009\009   \009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009\009\009   \009end\
\009\009\009\009\009\009end\
\009\009\009\009\009end\009\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009-- Make monsters attack\
\009local room = getRoom( x, y, z )\
\009if nTimeInRoom >= 2 and not bNewMonstersThisRoom then\
\009\009for n,sMonster in ipairs( tMonsters ) do\
\009\009\009if room.items[sMonster] then\
\009\009\009\009if math.random(1,4) == 1 and\
\009\009\009\009   not (y == 0 and isSunny() and (sMonster == \"a spider\")) then\
\009\009\009\009\009if sMonster == \"a creeper\" then\
\009\009\009\009\009\009if room.dark then\
\009\009\009\009\009\009\009print( \"A creeper explodes.\" )\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009print( \"The creeper explodes.\" )\
\009\009\009\009\009\009end\
\009\009\009\009\009\009room.items[sMonster] = nil\
\009\009\009\009\009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009\009else\
\009\009\009\009\009\009if room.dark then\
\009\009\009\009\009\009\009print( \"A \"..items[sMonster].aliases[1]..\" attacks you.\" )\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009print( \"The \"..items[sMonster].aliases[1]..\" attacks you.\" )\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009if bInjured then\
\009\009\009\009\009\009if term.isColour() then\
\009\009\009\009\009\009\009term.setTextColour( colours.red )\
\009\009\009\009\009\009end\
\009\009\009\009\009\009print( \"You have died.\" )\
\009\009\009\009\009\009print( \"Score: &e0\" )\
\009\009\009\009\009\009term.setTextColour( colours.white )\
\009\009\009\009\009\009bRunning = false\
\009\009\009\009\009\009return\
\009\009\009\009\009else\
\009\009\009\009\009\009bInjured = true\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009\
\009-- Always print this\
\009if bInjured then\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You are injured.\" )\
\009\009term.setTextColour( colours.white )\
\009end\
\009\
\009-- Advance time\
\009nTurn = nTurn + 1\
\009nTimeInRoom = nTimeInRoom + 1\
end\
\
doCommand( \"look\" )\
simulate()\
\
local tCommandHistory = {}\
while bRunning do\
\009if term.isColour() then\
\009\009term.setTextColour( colours.yellow )\
\009end\
    write( \"? \" )\
\009term.setTextColour( colours.white )\
\009\009\
    local sRawLine = read( nil, tCommandHistory )\
    table.insert( tCommandHistory, sRawLine )\
    \
    local sLine = nil\
\009for match in string.gmatch(sRawLine, \"%a+\") do\
\009\009if sLine then\
\009\009\009sLine = sLine .. \" \" .. string.lower(match)\
\009\009else\
\009\009\009sLine = string.lower(match)\
\009\009end\
\009end\
\009\
\009doCommand( sLine or \"\" )\
    if bRunning then\
\009    simulate()\
\009end\
end",
      "local tArgs = { ... }\
\
local function printUsage()\
\009print( \"Usages:\")\
\009print( \"dj play\" )\
\009print( \"dj play <drive>\" )\
\009print( \"dj stop\" )\
end\
\
if #tArgs > 2 then\
\009printUsage()\
\009return\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"stop\" then\
\009-- Stop audio\
\009disk.stopAudio()\
\
elseif sCommand == \"play\" or sCommand == nil then\
\009-- Play audio\
\009local sName = tArgs[2]\
\009if sName == nil then\
\009\009-- No disc specified, pick one at random\
\009\009local tNames = {}\
\009\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009\009if disk.isPresent( sName ) and disk.hasAudio( sName ) then\
\009\009\009\009table.insert( tNames, sName )\
\009\009\009end\
\009\009end\
\009\009if #tNames == 0 then\
\009\009\009print( \"No Music Discs in attached disk drives\" )\
\009\009\009return\
\009\009end\
\009\009sName = tNames[ math.random(1,#tNames) ]\
\009end\
\
\009-- Play the disc\
\009if disk.isPresent( sName ) and disk.hasAudio( sName ) then\
\009\009print( \"Playing \"..disk.getAudioTitle( sName ) )\
\009\009disk.playAudio( sName )\
\009else\
\009\009print( \"No Music Disc in disk drive: \"..sName )\
\009\009return\
\009end\
\009\
else\
\009printUsage()\
\009\
end",
      "if term.isColour() then\
\009term.setTextColour( 2^math.random(0,15) )\
end\
textutils.slowPrint( \"Hello World!\" )\
term.setTextColour( colours.white )",
      "\
-- Display the start screen\
local w,h = term.getSize()\
\
local titleColour, headingColour, textColour, wormColour, fruitColour\
if term.isColour() then\
    titleColour = colours.red\
\009headingColour = colours.yellow\
\009textColour = colours.white\
\009wormColour = colours.green\
\009fruitColour = colours.red\
else\
    titleColour = colours.white\
\009headingColour = colours.white\
\009textColour = colours.white\
\009wormColour = colours.white\
\009fruitColour = colours.white\
end\
\
local function printCentred( y, s )\
\009local x = math.floor((w - string.len(s)) / 2)\
\009term.setCursorPos(x,y)\
\009--term.clearLine()\
\009term.write( s )\
end\
\
local xVel,yVel = 1,0\
local xPos, yPos = math.floor(w/2), math.floor(h/2)\
local pxVel, pyVel = nil, nil\
\
local nLength = 1\
local nExtraLength = 6\
local bRunning = true\
\
local tailX,tailY = xPos,yPos\
local nScore = 0\
local nDifficulty = 2\
local nSpeed, nInterval\
\
-- Setup the screen\
local screen = {}\
for x=1,w do\
\009screen[x] = {}\
\009for y=1,h do\
\009\009screen[x][y] = {}\
\009end\
end\
screen[xPos][yPos] = { snake = true }\
\
local nFruit = 1\
local tFruits = {\
\009\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\
\009\"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\
\009\"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\
\009\"Y\", \"Z\",\
\009\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\
\009\"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\",\
\009\"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\",\
\009\"y\", \"z\",\
\009\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\",\
\009\"@\", \"$\", \"%\", \"#\", \"&\", \"!\", \"?\", \"+\", \"*\", \"~\"\
}\
\
local function addFruit()\
\009while true do\
\009\009local x = math.random(1,w)\
\009\009local y = math.random(2,h)\
\009\009local fruit = screen[x][y]\
\009\009if fruit.snake == nil and fruit.wall == nil and fruit.fruit == nil then\
\009\009\009screen[x][y] = { fruit = true }\
\009\009\009term.setCursorPos(x,y)\
\009\009\009term.setBackgroundColour( fruitColour )\
\009\009\009term.write(\" \")\
\009\009\009term.setBackgroundColour( colours.black )\
\009\009\009break\
\009\009end\
\009end\
\009\
\009nFruit = nFruit + 1\
\009if nFruit > #tFruits then\
\009\009nFruit = 1\
\009end\
end\
\
local function drawMenu()\
\009term.setTextColour( headingColour )\
\009term.setCursorPos(1,1)\
\009term.write( \"SCORE \" )\
\009\
\009term.setTextColour( textColour )\
\009term.setCursorPos(7,1)\
\009term.write( tostring(nScore) )\
\
\009term.setTextColour( headingColour )\
\009term.setCursorPos(w-11,1)\
\009term.write( \"DIFFICULTY \")\
\
\009term.setTextColour( textColour )\
\009term.setCursorPos(w,1)\
\009term.write( tostring(nDifficulty or \"?\") ) \
\
\009term.setTextColour( colours.white )\
end\
\
local function update( )\
\009local x,y = xPos,yPos\
\009if pxVel and pyVel then\
\009\009xVel, yVel = pxVel, pyVel\
\009\009pxVel, pyVel = nil, nil\
\009end\
\
\009-- Remove the tail\
\009if nExtraLength == 0 then\
\009\009local tail = screen[tailX][tailY]\
\009\009screen[tailX][tailY] = {}\
\009\009term.setCursorPos(tailX,tailY)\
\009\009term.write(\" \")\
\009\009tailX = tail.nextX\
\009\009tailY = tail.nextY\
\009else\
\009\009nExtraLength = nExtraLength - 1\
\009end\
\009\
\009-- Update the head\
\009local head = screen[xPos][yPos]\
\009local newXPos = xPos + xVel\
\009local newYPos = yPos + yVel\
\009if newXPos < 1 then\
\009\009newXPos = w\
\009elseif newXPos > w then\
\009\009newXPos = 1\
\009end\
\009if newYPos < 2 then\
\009\009newYPos = h\
\009elseif newYPos > h then\
\009\009newYPos = 2\
\009end\
\009\
\009local newHead = screen[newXPos][newYPos]\
\009term.setCursorPos(1,1);\
\009print( newHead.snake )\
\009if newHead.snake == true or newHead.wall == true then\
\009\009bRunning = false\
\009\009\
\009else\
\009\009if newHead.fruit == true then\
\009\009\009nScore = nScore + 10\
\009\009\009nExtraLength = nExtraLength + 1\
\009\009\009addFruit()\
\009\009end\
\009\009xPos = newXPos\
\009\009yPos = newYPos\
\009\009head.nextX = newXPos\
\009\009head.nextY = newYPos\
\009\009screen[newXPos][newYPos] = { snake = true }\
\009\009\
\009end\
\009\
\009term.setCursorPos(xPos,yPos)\
\009term.setBackgroundColour( wormColour )\
\009term.write(\" \")\
\009term.setBackgroundColour( colours.black )\
\
\009drawMenu()\
end\
\
-- Display the frontend\
term.clear()\
local function drawFrontend()\
\009--term.setTextColour( titleColour )\
    --printCentred( math.floor(h/2) - 4, \" W O R M \" )\
\
\009term.setTextColour( headingColour )\
\009printCentred( math.floor(h/2) - 3, \"\" )\
\009printCentred( math.floor(h/2) - 2, \" SELECT DIFFICULTY \" )\
\009printCentred( math.floor(h/2) - 1, \"\" )\
\009\
\009printCentred( math.floor(h/2) + 0, \"            \" )\
\009printCentred( math.floor(h/2) + 1, \"            \" )\
\009printCentred( math.floor(h/2) + 2, \"            \" )\
\009printCentred( math.floor(h/2) - 1 + nDifficulty, \" [        ] \" )\
\
\009term.setTextColour( textColour )\
\009printCentred( math.floor(h/2) + 0, \"EASY\" )\
\009printCentred( math.floor(h/2) + 1, \"MEDIUM\" )\
\009printCentred( math.floor(h/2) + 2, \"HARD\" )\
\009printCentred( math.floor(h/2) + 3, \"\" )\
\
\009term.setTextColour( colours.white )\
end\
\
drawMenu()\
drawFrontend()\
while true do\
\009local e,key = os.pullEvent( \"key\" )\
\009if key == keys.up or key == keys.w then\
\009\009-- Up\
\009\009if nDifficulty > 1 then\
\009\009\009nDifficulty = nDifficulty - 1\
\009\009\009drawMenu()\
\009\009\009drawFrontend()\
\009\009end\
\009elseif key == keys.down or key == keys.s then\
\009\009-- Down\
\009\009if nDifficulty < 3 then\
\009\009\009nDifficulty = nDifficulty + 1\
\009\009\009drawMenu()\
\009\009\009drawFrontend()\
\009\009end\
\009elseif key == keys.enter then\
\009\009-- Enter\
\009\009break\
\009end\
end\
\
local tSpeeds = { 5, 10, 25 }\
nSpeed = tSpeeds[nDifficulty]\
nInterval = 1 / nSpeed\
\
-- Grow the snake to its intended size\
term.clear()\
drawMenu()\
screen[tailX][tailY].snake = true\
while nExtraLength > 0 do\
\009update()\
end\
addFruit()\
addFruit()\
\
-- Play the game\
local timer = os.startTimer(0)\
while bRunning do\
\009local event, p1, p2 = os.pullEvent()\
\009if event == \"timer\" and p1 == timer then\
\009\009timer = os.startTimer(nInterval)\
\009\009update( false )\
\009\
\009elseif event == \"key\" then\
\009\009local key = p1\
\009\009if key == keys.up or key == keys.w then\
\009\009\009-- Up\
\009\009\009if yVel == 0 then\
\009\009\009\009pxVel,pyVel = 0,-1\
\009\009\009end\
\009\009elseif key == keys.down or key == keys.s then\
\009\009\009-- Down\
\009\009\009if yVel == 0 then\
\009\009\009\009pxVel,pyVel = 0,1\
\009\009\009end\
\009\009elseif key == keys.left or key == keys.a then\
\009\009\009-- Left\
\009\009\009if xVel == 0 then\
\009\009\009\009pxVel,pyVel = -1,0\
\009\009\009end\
\009\009\
\009\009elseif key == keys.right or key == keys.d then\
\009\009\009-- Right\
\009\009\009if xVel == 0 then\
\009\009\009\009pxVel,pyVel = 1,0\
\009\009\009end\
\009\009\
\009\009end\009\
\009end\
end\
\
-- Display the gameover screen\
term.setTextColour( headingColour )\
printCentred( math.floor(h/2) - 2, \"                   \" )\
printCentred( math.floor(h/2) - 1, \" G A M E   O V E R \" )\
\
term.setTextColour( textColour )\
printCentred( math.floor(h/2) + 0, \"                 \" )\
printCentred( math.floor(h/2) + 1, \" FINAL SCORE \"..nScore..\" \" )\
printCentred( math.floor(h/2) + 2, \"                 \" )\
term.setTextColour( colours.white )\
\
local timer = os.startTimer(2.5)\
repeat\
\009local e,p = os.pullEvent()\
\009if e == \"timer\" and p == timer then\
\009\009term.setTextColour( textColour )\
\009\009printCentred( math.floor(h/2) + 2, \" PRESS ANY KEY \" )\
\009\009printCentred( math.floor(h/2) + 3, \"               \" )\
\009\009term.setTextColour( colours.white )\
\009end\
until e == \"char\"\
\
term.clear()\
term.setCursorPos(1,1)\
\
\009\009",
      "\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"gps host\" )\
\009print( \"gps host <x> <y> <z>\" )\
\009print( \"gps locate\" )\
end\
\
local tArgs = { ... }\
if #tArgs < 1 then\
\009printUsage()\
\009return\
end\
\009\
 local sCommand = tArgs[1]\
if sCommand == \"locate\" then\
\009-- \"gps locate\"\
\009-- Just locate this computer (this will print the results)\
\009gps.locate( 2, true )\
\009\
elseif sCommand == \"host\" then\
\009-- \"gps host\"\
\009-- Act as a GPS host\
\009if pocket then\
\009    print( \"GPS Hosts must be stationary\" )\
\009    return\
\009end\
\
\009-- Find a modem\
\009local sModemSide = nil\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\009\
\009\009\009sModemSide = sSide\
\009\009\009break\
\009\009end\
\009end\
\
\009if sModemSide == nil then\
\009\009print( \"No wireless modems found. 1 required.\" )\
\009\009return\
\009end\
\
\009-- Determine position\
\009local x,y,z\
\009if #tArgs >= 4 then\
\009\009-- Position is manually specified\
\009\009x = tonumber(tArgs[2])\
\009\009y = tonumber(tArgs[3])\
\009\009z = tonumber(tArgs[4])\
\009\009if x == nil or y == nil or z == nil then\
\009\009\009printUsage()\
\009\009\009return\
\009\009end\
\009\009print( \"Position is \"..x..\",\"..y..\",\"..z )\
\009else\
\009\009-- Position is to be determined using locate\009\009\
\009\009x,y,z = gps.locate( 2, true )\
\009\009if x == nil then\
\009\009\009print( \"Run \\\"gps host <x> <y> <z>\\\" to set position manually\" )\
\009\009\009if bCloseChannel then\
\009\009\009\009print( \"Closing GPS channel\" )\
\009\009\009\009modem.close( gps.CHANNEL_GPS )\
\009\009\009end\
\009\009\009return\
\009\009end\
\009end\
\009\
\009-- Open a channel\
\009local modem = peripheral.wrap( sModemSide )\
    print( \"Opening channel on modem \"..sModemSide )\
    modem.open( gps.CHANNEL_GPS )\
\
\009-- Serve requests indefinately\
\009local nServed = 0\
\009while true do\
\009\009local e, p1, p2, p3, p4, p5 = os.pullEvent( \"modem_message\" )\
\009\009if e == \"modem_message\" then\
\009\009\009-- We received a message from a modem\
\009\009\009local sSide, sChannel, sReplyChannel, sMessage, nDistance = p1, p2, p3, p4, p5\
\009\009\009if sSide == sModemSide and sChannel == gps.CHANNEL_GPS and sMessage == \"PING\" and nDistance then\
\009\009\009\009-- We received a ping message on the GPS channel, send a response\
\009\009\009\009modem.transmit( sReplyChannel, gps.CHANNEL_GPS, { x, y, z } )\
\009\009\009\
\009\009\009\009-- Print the number of requests handled\
\009\009\009\009nServed = nServed + 1\
\009\009\009\009if nServed > 1 then\
\009\009\009\009\009local x,y = term.getCursorPos()\
\009\009\009\009\009term.setCursorPos(1,y-1)\
\009\009\009\009end\
\009\009\009\009print( nServed..\" GPS requests served\" )\
\009\009\009end\
\009\009end\
\009end\
\
\009-- Close the channel\
    print( \"Closing channel\" )\
    modem.close( gps.CHANNEL_GPS )\
\
else\
\009-- \"gps somethingelse\"\
\009-- Error\
\009printUsage()\
\009\
end",
      "local tArgs = { ... }\
if #tArgs > 0 then\
\009sTopic = tArgs[1]\
else\
\009sTopic = \"intro\"\
end\
\
if sTopic == \"index\" then\
\009print( \"Help topics availiable:\" )\
\009local tTopics = help.topics()\
\009textutils.pagedTabulate( tTopics )\
\009return\
end\
\009\
local w,h = term.getSize()\
local sFile = help.lookup( sTopic )\
local file = ((sFile ~= nil) and io.open( sFile )) or nil\
local nLinesPrinted = 0\
if file then\
\009local sLine = file:read()\
\009local nLines = 0\
\009while sLine do\
\009\009nLines = nLines + textutils.pagedPrint( sLine, (h-3) - nLines )\
    \009sLine = file:read()\
    end\
\009file:close()\
else\
\009print( \"No help available\" )\
end",
      "\
local function printUsage()\
    print( \"Usages:\" )\
    print( \"pastebin put <filename>\" )\
    print( \"pastebin get <code> <filename>\" )\
    print( \"pastebin run <code> <arguments>\" )\
end\
 \
local tArgs = { ... }\
if #tArgs < 2 then\
    printUsage()\
    return\
end\
 \
if not http then\
    printError( \"Pastebin requires http API\" )\
    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\
    return\
end\
 \
local function get(paste)\
    write( \"Connecting to pastebin.com... \" )\
    local response = http.get(\
        \"http://pastebin.com/raw/\"..textutils.urlEncode( paste )\
    )\
        \
    if response then\
        print( \"Success.\" )\
        \
        local sResponse = response.readAll()\
        response.close()\
        return sResponse\
    else\
        print( \"Failed.\" )\
    end\
end\
 \
local sCommand = tArgs[1]\
if sCommand == \"put\" then\
    -- Upload a file to pastebin.com\
    -- Determine file to upload\
    local sFile = tArgs[2]\
    local sPath = shell.resolve( sFile )\
    if not fs.exists( sPath ) or fs.isDir( sPath ) then\
        print( \"No such file\" )\
        return\
    end\
    \
    -- Read in the file\
    local sName = fs.getName( sPath )\
    local file = fs.open( sPath, \"r\" )\
    local sText = file.readAll()\
    file.close()\
    \
    -- POST the contents to pastebin\
    write( \"Connecting to pastebin.com... \" )\
    local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\
    local response = http.post(\
        \"http://pastebin.com/api/api_post.php\", \
        \"api_option=paste&\"..\
        \"api_dev_key=\"..key..\"&\"..\
        \"api_paste_format=lua&\"..\
        \"api_paste_name=\"..textutils.urlEncode(sName)..\"&\"..\
        \"api_paste_code=\"..textutils.urlEncode(sText)\
    )\
        \
    if response then\
        print( \"Success.\" )\
        \
        local sResponse = response.readAll()\
        response.close()\
                \
        local sCode = string.match( sResponse, \"[^/]+$\" )\
        print( \"Uploaded as \"..sResponse )\
        print( \"Run \\\"pastebin get \"..sCode..\"\\\" to download anywhere\" )\
 \
    else\
        print( \"Failed.\" )\
    end\
    \
elseif sCommand == \"get\" then\
    -- Download a file from pastebin.com\
    if #tArgs < 3 then\
        printUsage()\
        return\
    end\
 \
    -- Determine file to download\
    local sCode = tArgs[2]\
    local sFile = tArgs[3]\
    local sPath = shell.resolve( sFile )\
    if fs.exists( sPath ) then\
        print( \"File already exists\" )\
        return\
    end\
    \
    -- GET the contents from pastebin\
    local res = get(sCode)\
    if res then        \
        local file = fs.open( sPath, \"w\" )\
        file.write( res )\
        file.close()\
        \
        print( \"Downloaded as \"..sFile )\
    end \
elseif sCommand == \"run\" then\
    local sCode = tArgs[2]\
 \
    local res = get(sCode)\
    if res then\
        local func, err = load(res, sCode, \"t\", _ENV)\
        if not func then\
            printError( err )\
            return\
        end\
        local success, msg = pcall(func, table.unpack(tArgs, 3))\
        if not success then\
            printError( msg )\
        end\
    end\
else\
    printUsage()\
    return\
end",
      "\
local function printUsage()\
    print( \"Usage:\" )\
    print( \"wget <url> <filename>\" )\
end\
 \
local tArgs = { ... }\
if #tArgs < 2 then\
    printUsage()\
    return\
end\
 \
if not http then\
    printError( \"wget requires http API\" )\
    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\
    return\
end\
 \
local function get( sUrl )\
    write( \"Connecting to \" .. sUrl .. \"... \" )\
\
    local ok, err = http.checkURL( sUrl )\
    if not ok then\
        print( \"Failed.\" )\
        if err then\
            printError( err )\
        end\
        return nil\
    end\
\
    local response = http.get( sUrl )\
    if not response then\
        print( \"Failed.\" )\
        return nil\
    end\
\
    print( \"Success.\" )\
\
    local sResponse = response.readAll()\
    response.close()\
    return sResponse\
end\
 \
-- Determine file to download\
local sUrl = tArgs[1]\
local sFile = tArgs[2]\
local sPath = shell.resolve( sFile )\
if fs.exists( sPath ) then\
    print( \"File already exists\" )\
    return\
end\
\
-- Do the get\
local res = get( sUrl )\
if res then\
    local file = fs.open( sPath, \"w\" )\
    file.write( res )\
    file.close()\
\
    print( \"Downloaded as \"..sFile )\
end",
      "\
local sDrive = nil\
local tArgs = { ... }\
if #tArgs > 0 then\
\009sDrive = tostring( tArgs[1] )\
end\
\
if sDrive == nil then\
\009print( \"This is computer #\"..os.getComputerID() )\
\009\
\009local label = os.getComputerLabel()\
\009if label then\
\009\009print( \"This computer is labelled \\\"\"..label..\"\\\"\" )\
\009end\
\
else\
\009local bData = disk.hasData( sDrive )\
\009if not bData then\
\009\009print( \"No disk in drive \"..sDrive )\
\009\009return\
\009end\
\009\
\009print( \"The disk is #\"..disk.getID( sDrive ) )\
\
\009local label = disk.getLabel( sDrive )\
\009if label then\
\009\009print( \"The disk is labelled \\\"\"..label..\"\\\"\" )\
\009end\
end",
      "\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"label get\" )\
\009print( \"label get <drive>\" )\
\009print( \"label set <text>\" )\
\009print( \"label set <drive> <text>\" )\
\009print( \"label clear\" )\
\009print( \"label clear <drive>\" )\
end\
\
local function checkDrive( sDrive )\
    if peripheral.getType( sDrive ) == \"drive\" then\
        -- Check the disk exists\
        local bData = disk.hasData( sDrive )\
        if not bData then\
            print( \"No disk in \"..sDrive..\" drive\" )\
            return false\
        end\
    else\
\009    print( \"No disk drive named \"..sDrive )\
        return false\
\009end\
\009return true\
end\
\
local function get( sDrive )\
\009if sDrive ~= nil then\
\009    if checkDrive( sDrive ) then\
            local sLabel = disk.getLabel( sDrive )\
            if sLabel then\
                print( \"Disk label is \\\"\"..sLabel..\"\\\"\" )\
            else\
                print( \"No Disk label\" )\
            end\
        end\
\009else\
\009\009local sLabel = os.getComputerLabel()\
\009\009if sLabel then\
\009\009\009print( \"Computer label is \\\"\"..sLabel..\"\\\"\" )\
\009\009else\
\009\009\009print( \"No Computer label\" )\
\009\009end\
\009end\
end\
\
local function set( sDrive, sText )\
\009if sDrive ~= nil then\
\009    if checkDrive( sDrive ) then\
            disk.setLabel( sDrive, sText )\
            local sLabel = disk.getLabel( sDrive )\
            if sLabel then\
                print( \"Disk label set to \\\"\"..sLabel..\"\\\"\" )\
            else\
                print( \"Disk label cleared\" )\
            end\
        end\
\009else\
\009\009os.setComputerLabel( sText )\
\009\009local sLabel = os.getComputerLabel()\
\009\009if sLabel then\
\009\009\009print( \"Computer label set to \\\"\"..sLabel..\"\\\"\" )\
\009\009else\
\009\009\009print( \"Computer label cleared\" )\
\009\009end\
\009end\
end\
\
local tArgs = { ... }\
local sCommand = tArgs[1]\
if sCommand == \"get\" then\
    -- Get a label\
    if #tArgs == 1 then\
        get( nil )\
    elseif #tArgs == 2 then\
        get( tArgs[2] )\
    else\
        printUsage()\
    end\
elseif sCommand == \"set\" then\
    -- Set a label\
    if #tArgs == 2 then\
        set( nil, tArgs[2] )\
    elseif #tArgs == 3 then\
        set( tArgs[2], tArgs[3] )\
    else\
        printUsage()\
    end\
elseif sCommand == \"clear\" then\
    -- Clear a label\
    if #tArgs == 1 then\
        set( nil, nil )\
    elseif #tArgs == 2 then\
        set( tArgs[2], nil )\
    else\
        printUsage()\
    end\
else\
    printUsage()\
end",
      "\
local tArgs = { ... }\
\
-- Get all the files in the directory\
local sDir = shell.dir()\
if tArgs[1] ~= nil then\
\009sDir = shell.resolve( tArgs[1] )\
end\
\
-- Sort into dirs/files, and calculate column count\
local tAll = fs.list( sDir )\
local tFiles = {}\
local tDirs = {}\
\
local bShowHidden = settings.get( \"list.show_hidden\" )\
for n, sItem in pairs( tAll ) do\
\009if bShowHidden or string.sub( sItem, 1, 1 ) ~= \".\" then\
\009\009local sPath = fs.combine( sDir, sItem )\
\009\009if fs.isDir( sPath ) then\
\009\009\009table.insert( tDirs, sItem )\
\009\009else\
\009\009\009table.insert( tFiles, sItem )\
\009\009end\
\009end\
end\
table.sort( tDirs )\
table.sort( tFiles )\
\
if term.isColour() then\
\009textutils.pagedTabulate( colors.green, tDirs, colors.white, tFiles )\
else\
\009textutils.pagedTabulate( tDirs, tFiles )\
end",
      "\
local tArgs = { ... }\
if #tArgs > 0 then\
\009print( \"This is an interactive Lua prompt.\" )\
\009print( \"To run a lua program, just type its name.\" )\
\009return\
end\
\
local bRunning = true\
local tCommandHistory = {}\
local tEnv = {\
\009[\"exit\"] = function()\
\009\009bRunning = false\
\009end,\
\009[\"_echo\"] = function( ... )\
\009    return ...\
\009end,\
}\
setmetatable( tEnv, { __index = _ENV } )\
\
if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Interactive Lua prompt.\" )\
print( \"Call exit() to exit.\" )\
term.setTextColour( colours.white )\
\
while bRunning do\
\009--if term.isColour() then\
\009--\009term.setTextColour( colours.yellow )\
\009--end\
\009write( \"lua> \" )\
\009--term.setTextColour( colours.white )\
\
\009local s = read( nil, tCommandHistory, function( sLine )\
\009\009if settings.get( \"lua.autocomplete\" ) then\
\009\009    local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.]+$\" )\
\009\009    if nStartPos then\
\009\009        sLine = string.sub( sLine, nStartPos )\
\009\009    end\
\009\009    if #sLine > 0 then\
\009            return textutils.complete( sLine, tEnv )\
\009        end\
\009\009end\
        return nil\
\009end )\
\009table.insert( tCommandHistory, s )\
\009\
\009local nForcePrint = 0\
\009local func, e = load( s, \"lua\", \"t\", tEnv )\
\009local func2, e2 = load( \"return _echo(\"..s..\");\", \"lua\", \"t\", tEnv )\
\009if not func then\
\009\009if func2 then\
\009\009\009func = func2\
\009\009\009e = nil\
\009\009\009nForcePrint = 1\
\009\009end\
\009else\
\009\009if func2 then\
\009\009\009func = func2\
\009\009end\
\009end\
\009\
\009if func then\
        local tResults = { pcall( func ) }\
        if tResults[1] then\
        \009local n = 1\
        \009while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do\
        \009    local value = tResults[ n + 1 ]\
        \009    if type( value ) == \"table\" then\
        \009        local metatable = getmetatable( value )\
        \009        if type(metatable) == \"table\" and type(metatable.__tostring) == \"function\" then\
        \009            print( tostring( value ) )\
        \009        else\
                        local ok, serialised = pcall( textutils.serialise, value )\
                        if ok then\
                            print( serialised )\
                        else\
                            print( tostring( value ) )\
                        end\
            \009    end\
            \009else\
            \009    print( tostring( value ) )\
            \009end\
        \009\009n = n + 1\
        \009end\
        else\
        \009printError( tResults[2] )\
        end\
    else\
    \009printError( e )\
    end\
    \
end",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: mkdir <path>\" )\
\009return\
end\
\
local sNewDir = shell.resolve( tArgs[1] )\
fs.makeDir( sNewDir )",
      "\
local function printUsage()\
\009print( \"Usage: monitor <name> <program> <arguments>\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs < 2 then\
\009printUsage()\
\009return\
end\
\
local sName = tArgs[1]\
if peripheral.getType( sName ) ~= \"monitor\" then\
\009print( \"No monitor named \".. sName )\
\009return\
end\
\
local sProgram = tArgs[2]\
local sPath = shell.resolveProgram( sProgram )\
if sPath == nil then\
\009print( \"No such program: \"..sProgram )\
\009return\
end\
\
print( \"Running \"..sProgram..\" on monitor \"..sName )\
\
local monitor = peripheral.wrap( sName )\
local previousTerm = term.redirect( monitor )\
\
local co = coroutine.create( function()\
    shell.run( sProgram, table.unpack( tArgs, 3 ) )\
end )\
\
local function resume( ... )\
    local ok, param = coroutine.resume( co, ... )\
    if not ok then\
    \009printError( param )\
    end\
    return param\
end\
\
local ok, param = pcall( function()\
\009local sFilter = resume()\
\009while coroutine.status( co ) ~= \"dead\" do\
\009\009local tEvent = { os.pullEventRaw() }\
\009\009if sFilter == nil or tEvent[1] == sFilter or tEvent[1] == \"terminate\" then\
\009\009\009sFilter = resume( table.unpack( tEvent ) )\
\009\009end\
\009\009if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"mouse_click\") then\
\009\009\009if tEvent[1] == \"monitor_touch\" and tEvent[2] == sName then\
\009\009\009\009sFilter = resume( \"mouse_click\", 1, table.unpack( tEvent, 3 ) )\
\009\009\009end\
\009\009end\
\009\009if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"term_resize\") then\
\009\009\009if tEvent[1] == \"monitor_resize\" and tEvent[2] == sName then\
\009\009\009\009sFilter = resume( \"term_resize\" )\
\009\009\009end\
\009\009end\
\009end\
end )\
\
term.redirect( previousTerm )\
if not ok then\
\009printError( param )\
end\
\009",
      "\
local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: mv <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
local tFiles = fs.find( sSource )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        if fs.isDir( sDest ) then\
            fs.move( sFile, fs.combine( sDest, fs.getName(sFile) ) )\
        elseif #tFiles == 1 then\
            fs.move( sFile, sDest )\
        else\
            printError( \"Cannot overwrite file multiple times\" )\
            return\
        end\
    end\
else\
    printError( \"No matching files\" )\
end",
      "local tPeripherals = peripheral.getNames()\
print( \"Attached Peripherals:\" )\
if #tPeripherals > 0 then\
\009for n=1,#tPeripherals do\
\009\009local sPeripheral = tPeripherals[n]\
\009\009print( sPeripheral .. \" (\" .. peripheral.getType( sPeripheral ) .. \")\" )\
\009end\
else\
\009print( \"None\" )\
end",
      "--[[\
Falling - Based on Tetris by Alexey Pajitnov\
This version written by Gopher, at the request of Dan200, for\
ComputerCraft v1.6. No particular rights are reserved.\
--]]\
\
local function colorass(c,bw)\
  return term.isColor() and c or bw\
end\
\
local block_s1= {\
    {\
      { 1,0,0,0, },\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 0,1,1,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"{}\"),\
    fg=colorass(colors.blue,colors.black),\
    bg=colorass(colors.cyan,colors.white),\
  }\
local block_s2= {\
    {\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 1,0,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,0,0, },\
      { 0,1,1,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"{}\"),\
    fg=colorass(colors.green,colors.black),\
    bg=colorass(colors.lime,colors.white),\
  }\
local block_line = {\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,1, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"[]\"),\
    fg=colorass(colors.pink,colors.black),\
    bg=colorass(colors.red,colors.white),\
  }\
local block_square = {\
    {\
      { 1,1,0,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"[]\"),\
    fg=colorass(colors.lightBlue,colors.black),\
    bg=colorass(colors.blue,colors.white),\
  }\
local block_L1 = {\
    {\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 1,0,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,1,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,1,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"()\"),\
    fg=colorass(colors.orange,colors.black),\
    bg=colorass(colors.yellow,colors.white),\
  }\
local block_L2 = {\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 0,0,1,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,1,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 1,0,0,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"()\"),\
    fg=colorass(colors.brown,colors.black),\
    bg=colorass(colors.orange,colors.white),\
  }\
local block_T = {\
    {\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 0,1,1,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"<>\"),\
    fg=colorass(colors.cyan,colors.black),\
    bg=colorass(colors.purple,colors.white),\
  }\
\
local blocks={ block_line, block_square, block_s1, block_s2, block_L1, block_L2, block_T}\
\
local points={4,10,30,120}\
\
local function lpad(text,amt)\
  text=tostring(text)\
  return string.rep(\" \",amt-#text)..text\
end\
\
local width,height=term.getSize()\
\
if height<19 or width<26 then\
  print(\"Your screen is too small to play :(\")\
  return\
end\
\
\
local speedsByLevel={\
  1.2,\
  1.0,\
   .8,\
   .65,\
   .5,\
   .4,\
   .3,\
   .25,\
   .2,\
   .15,\
   .1,\
   .05,}\
\
local level=1\
\
local function playGame()\
  local score=0\
  local lines=0\
  local initialLevel=level\
  local next=blocks[math.random(1,#blocks)]\
\
  local pit={}\
\
\
  local heightAdjust=0\
\
  if height<=19 then\
    heightAdjust=1\
  end\
\
\
\
  local function drawScreen()\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    term.clear()\
\
    term.setTextColor(colors.black)\
    term.setBackgroundColor(colorass(colors.lightGray, colors.white))\
    term.setCursorPos(22,2)\
    term.write(\"Score\") --score\
    term.setCursorPos(22,5)\
    term.write(\"Level\")  --level\
    term.setCursorPos(22,8)\
    term.write(\"Lines\")  --lines\
    term.setCursorPos(22,12)\
    term.write(\"Next\") --next\
\
    term.setCursorPos(21,1)\
    term.write(\"      \")\
    term.setCursorPos(21,2)\
    term.write(\" \") --score\
    term.setCursorPos(21,3)\
    term.write(\" \")\
    term.setCursorPos(21,4)\
    term.write(\"      \")\
    term.setCursorPos(21,5)\
    term.write(\" \")  --level\
    term.setCursorPos(21,6)\
    term.write(\" \")\
    term.setCursorPos(21,7)\
    term.write(\"      \")\
    term.setCursorPos(21,8)\
    term.write(\" \")  --lines\
    term.setCursorPos(21,9)\
    term.write(\" \")\
    term.setCursorPos(21,10)\
    term.write(\"      \")\
    term.setCursorPos(21,11)\
    term.write(\"      \")\
    term.setCursorPos(21,12)\
    term.write(\" \") --next\
    term.setCursorPos(26,12)\
    term.write(\" \") --next\
    term.setCursorPos(21,13)\
    term.write(\"      \")\
    term.setCursorPos(21,14)\
    term.write(\" \")\
    term.setCursorPos(21,15)\
    term.write(\" \")\
    term.setCursorPos(21,16)\
    term.write(\" \")\
    term.setCursorPos(21,17)\
    term.write(\" \")\
    term.setCursorPos(21,18)\
    term.write(\" \")\
    term.setCursorPos(21,19)\
    term.write(\"      \")\
    term.setCursorPos(21,20)\
    term.write(\"      \")\
  end\
\
  local function updateNumbers()\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
\
    term.setCursorPos(22,3)\
    term.write(lpad(score,5)) --score\
    term.setCursorPos(22,6)\
    term.write(lpad(level,5))  --level\
    term.setCursorPos(22,9)\
    term.write(lpad(lines,5))  --lines\
  end\
\
  local function drawBlockAt(block,xp,yp,rot)\
    term.setTextColor(block.fg)\
    term.setBackgroundColor(block.bg)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\
          term.write(block.ch)\
        end\
      end\
    end\
  end\
\
  local function eraseBlockAt(block,xp,yp,rot)\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\
          term.write(\"  \")\
        end\
      end\
    end\
  end\
\
  local function testBlockAt(block,xp,yp,rot)\
    for y=1,4 do\
      local ty=yp+y-1\
      for x=1,4 do\
        local tx=xp+x-1\
        if block[rot][y][x]==1 then\
          if tx>10 or tx<1 or ty>20 or pit[ty][tx]~=0 then\
            return true\
          end\
        end\
      end\
    end\
  end\
\
  local function pitBlock(block,xp,yp,rot)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          pit[yp+y-1][xp+x-1]=block\
        end\
      end\
    end\
  end\
\
\
  local function clearPit()\
    for row=1,20 do\
      pit[row]={}\
      for col=1,10 do\
        pit[row][col]=0\
      end\
    end\
  end\
\
\
\
  drawScreen()\
  updateNumbers()\
\
  --declare & init the pit\
  clearPit()\
\
\
\
  local halt=false\
  local dropSpeed=speedsByLevel[math.min(level,12)]\
\
\
  local curBlock=next\
  next=blocks[math.random(1,7)]\
\
  local curX, curY, curRot=4, 1, 1\
  local dropTimer=os.startTimer(dropSpeed)\
\
  drawBlockAt(next,11.5,15+heightAdjust,1)\
  drawBlockAt(curBlock,curX,curY,curRot)\
\
  local function redrawPit()\
    for r=1+heightAdjust,20 do\
      term.setCursorPos(1,r-heightAdjust)\
      for c=1,10 do\
        if pit[r][c]==0 then\
          term.setTextColor(colors.black)\
          term.setBackgroundColor(colors.black)\
          term.write(\"  \")\
        else\
          term.setTextColor(pit[r][c].fg)\
          term.setBackgroundColor(pit[r][c].bg)\
          term.write(pit[r][c].ch)\
        end\
      end\
    end\
  end\
\
  local function hidePit()\
    for r=1+heightAdjust,20 do\
      term.setCursorPos(1,r-heightAdjust)\
      term.setTextColor(colors.black)\
      term.setBackgroundColor(colors.black)\
      term.write(\"                    \")\
    end\
  end\
\
  local function msgBox(message)\
    local x=math.floor((17-#message)/2)\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
    term.setTextColor(colors.black)\
    term.setCursorPos(x,9)\
    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\
    term.setCursorPos(x,10)\
    term.write(\"|\")\
    term.setCursorPos(x+#message+3,10)\
    term.write(\"|\")\
    term.setCursorPos(x,11)\
    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    term.setCursorPos(x+1,10)\
    term.write(\" \"..message..\" \")\
  end\
\
  local function clearRows()\
    local rows={}\
    for r=1,20 do\
      local count=0\
      for c=1,10 do\
        if pit[r][c]~=0 then\
          count=count+1\
        else\
          break\
        end\
      end\
      if count==10 then\
        rows[#rows+1]=r\
      end\
    end\
\
    if #rows>0 then\
      for i=1,4 do\
        sleep(.1)\
        for r=1,#rows do\
          r=rows[r]\
          term.setCursorPos(1,r-heightAdjust)\
          for c=1,10 do\
            term.setTextColor(pit[r][c].bg)\
            term.setBackgroundColor(pit[r][c].fg)\
            term.write(pit[r][c].ch)\
          end\
        end\
        sleep(.1)\
        for r=1,#rows do\
          r=rows[r]\
          term.setCursorPos(1,r-heightAdjust)\
          for c=1,10 do\
            term.setTextColor(pit[r][c].fg)\
            term.setBackgroundColor(pit[r][c].bg)\
            term.write(pit[r][c].ch)\
          end\
        end\
      end\
      --now remove the rows and drop everythign else\
      term.setBackgroundColor(colors.black)\
      for r=1,#rows do\
        r=rows[r]\
        term.setCursorPos(1,r-heightAdjust)\
        term.write(\"                    \")\
      end\
      sleep(.25)\
      for r=1,#rows do\
        table.remove(pit,rows[r])\
        table.insert(pit,1,{0,0,0,0,0,0,0,0,0,0})\
      end\
      redrawPit()\
      lines=lines+#rows\
      score=score+points[#rows]*math.min(level,20)\
      level=math.floor(lines/10)+initialLevel\
      dropSpeed=speedsByLevel[math.min(level,12)]\
      updateNumbers()\
    end\
    sleep(.25)\
  end\
\
  local function blockFall()\
    local result = false\
    if testBlockAt(curBlock,curX,curY+1,curRot) then\
      pitBlock(curBlock,curX,curY,curRot)\
      --detect rows that clear\
      clearRows(rows)\
\
      curBlock=next\
      curX=4\
      curY=1\
      curRot=1\
      if testBlockAt(curBlock,curX,curY,curRot) then\
        halt=true\
      end\
      drawBlockAt(curBlock,curX,curY,curRot)\
      eraseBlockAt(next,11.5,15+heightAdjust,1)\
      next=blocks[math.random(1,7)]\
      drawBlockAt(next,11.5,15+heightAdjust,1)\
      return true\
    else\
      eraseBlockAt(curBlock,curX,curY,curRot)\
      curY=curY+1\
      drawBlockAt(curBlock,curX,curY,curRot)\
      return false\
    end\
  end\
\
\
  while not halt do\
    local e={os.pullEvent()}\
    if e[1]==\"timer\" then\
      if e[2]==dropTimer then\
        blockFall()\
        dropTimer=os.startTimer(dropSpeed)\
      end\
    elseif e[1]==\"key\" then\
      local key=e[2]\
      local dx,dy,dr=0,0,0\
      if key==keys.left or key==keys.a then\
        dx=-1\
      elseif key==keys.right or key==keys.d then\
        dx=1\
      elseif key==keys.up or key==keys.w then\
        dr=1\
      elseif key==keys.down or key==keys.s then\
        while not blockFall() do end\
        dropTimer=os.startTimer(dropSpeed)\
      elseif key==keys.space then\
        hidePit()\
        msgBox(\"Paused\")\
        while ({os.pullEvent(\"key\")})[2]~=keys.space do end\
        redrawPit()\
        drawBlockAt(curBlock,curX,curY,curRot)\
        dropTimer=os.startTimer(dropSpeed)\
      end\
      if dx+dr~=0 then\
        if not testBlockAt(curBlock,curX+dx,curY+dy,(dr>0 and curRot%#curBlock+dr or curRot)) then\
          eraseBlockAt(curBlock,curX,curY,curRot)\
          curX=curX+dx\
          curY=curY+dy\
          curRot=dr==0 and curRot or (curRot%#curBlock+dr)\
          drawBlockAt(curBlock,curX,curY,curRot)\
        end\
      end\
    elseif e[1]==\"term_resize\" then\
      local w,h=term.getSize()\
      if h==20 then\
        heightAdjust=0\
      else\
        heightAdjust=1\
      end\
      redrawPit()\
      drawBlockAt(curBlock,curX,curY,curRot)\
    end\
  end\
\
  msgBox(\"Game Over!\")\
  while true do\
    local _,k=os.pullEvent(\"key\")\
    if k==keys.space or k==keys.enter then\
      break\
    end\
  end\
\
  level = math.min(level,9)\
end\
\
\
local selected=1\
local playersDetected=false\
\
local function drawMenu()\
  term.setBackgroundColor(colors.black)\
  term.setTextColor(colorass(colors.red,colors.white))\
  term.clear()\
\
  local cx,cy=math.floor(width/2),math.floor(height/2)\
\
  term.setCursorPos(cx-6,cy-2)\
  term.write(\"F A L L I N G\")\
\
  if playersDetected then\
    if selected==0 then\
      term.setTextColor(colorass(colors.blue,colors.black))\
      term.setBackgroundColor(colorass(colors.gray,colors.white))\
    else\
      term.setTextColor(colorass(colors.lightBlue,colors.white))\
      term.setBackgroundColor(colors.black)\
    end\
    term.setCursorPos(cx-12,cy)\
    term.write(\" Play head-to-head game! \")\
  end\
\
  term.setCursorPos(cx-10,cy+1)\
  if selected==1 then\
    term.setTextColor(colorass(colors.blue,colors.black))\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
  else\
    term.setTextColor(colorass(colors.lightBlue,colors.white))\
    term.setBackgroundColor(colors.black)\
  end\
  term.write(\" Play from level: <\" .. level .. \"> \")\
\
  term.setCursorPos(cx-3,cy+3)\
  if selected==2 then\
    term.setTextColor(colorass(colors.blue,colors.black))\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
  else\
    term.setTextColor(colorass(colors.lightBlue,colors.white))\
    term.setBackgroundColor(colors.black)\
  end\
  term.write(\" Quit \")\
end\
\
\
local function runMenu()\
  drawMenu()\
\
  while true do\
    local event={os.pullEvent()}\
    if event[1]==\"key\" then\
      local key=event[2]\
      if key==keys.right or key==keys.d and selected==1 then\
        level=math.min(level+1,9)\
        drawMenu()\
      elseif key==keys.left or key==keys.a and selected==1 then\
        level=math.max(level-1,1)\
        drawMenu()\
      elseif key>=keys.one and key<=keys.nine and selected==1 then\
        level=(key-keys.one) + 1\
        drawMenu()\
      elseif key==keys.up or key==keys.w then\
        selected=selected-1\
        if selected==0 then\
          selected=2\
        end\
        drawMenu()\
      elseif key==keys.down or key==keys.s then\
        selected=selected%2+1\
        drawMenu()\
      elseif key==keys.enter or key==keys.space then\
        break --begin play!\
      end\
    end\
  end\
end\
\
while true do\
  runMenu()\
  if selected==2 then\
    break\
  end\
\
  playGame()\
end\
\
\
term.setTextColor(colors.white)\
term.setBackgroundColor(colors.black)\
term.clear()\
term.setCursorPos(1,1)",
      "\
local bAll = false\
local tArgs = { ... }\
if #tArgs > 0 and tArgs[1] == \"all\" then\
\009bAll = true\
end\
\
local tPrograms = shell.programs( bAll )\
textutils.pagedTabulate( tPrograms )",
      "if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Goodbye\" )\
term.setTextColour( colours.white )\
\
sleep( 1 )\
os.reboot()",
      "\
local tArgs = { ... }\
\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"chat host <hostname>\" )\
\009print( \"chat join <hostname> <nickname>\" )\
end\
\
local sOpenedModem = nil\
local function openModem()\
    for n,sModem in ipairs( peripheral.getNames() ) do\
        if peripheral.getType( sModem ) == \"modem\" then\
            if not rednet.isOpen( sModem ) then\
                rednet.open( sModem )\
                sOpenedModem = sModem\
            end\
            return true\
        end\
    end\
    print( \"No modems found.\" )\
    return false\
end\
\
local function closeModem()\
    if sOpenedModem ~= nil then\
        rednet.close( sOpenedModem )\
        sOpenedModem = nil\
    end\
end\
\
-- Colours\
local highlightColour, textColour\
if term.isColour() then\
\009textColour = colours.white\
\009highlightColour = colours.yellow\
else\
\009textColour = colours.white\
\009highlightColour = colours.white\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"host\" then\
    -- \"chat host\"\
    -- Get hostname\
    local sHostname = tArgs[2]\
    if sHostname == nil then\
        printUsage()\
        return\
    end\
\
    -- Host server\
    if not openModem() then\
        return\
    end\
    rednet.host( \"chat\", sHostname )\
    print( \"0 users connected.\" )\
\
    local tUsers = {}\
    local nUsers = 0\
    function send( sText, nUserID )\
        if nUserID then\
            local tUser = tUsers[ nUserID ]\
            if tUser then\
                rednet.send( tUser.nID, {\
                    sType = \"text\",\
                    nUserID = nUserID,\
                    sText = sText,\
                }, \"chat\" )\
            end\
        else\
            for nUserID, tUser in pairs( tUsers ) do\
                rednet.send( tUser.nID, {\
                    sType = \"text\",\
                    nUserID = nUserID,\
                    sText = sText,\
                }, \"chat\" )\
            end\
        end\
    end\
\
    -- Setup ping pong\
    local tPingPongTimer = {}\
    function ping( nUserID )\
        local tUser = tUsers[ nUserID ]\
        rednet.send( tUser.nID, {\
            sType = \"ping to client\",\
            nUserID = nUserID,\
        }, \"chat\" )\
\
        local timer = os.startTimer( 15 )\
        tUser.bPingPonged = false\
        tPingPongTimer[ timer ] = nUserID\
    end\
\
    function printUsers()\
        local x,y = term.getCursorPos()\
        term.setCursorPos( 1, y - 1 )\
        term.clearLine()\
        if nUsers == 1 then\
            print( nUsers .. \" user connected.\" )\
        else\
            print( nUsers .. \" users connected.\" )\
        end\
    end\
\
    -- Handle messages\
    local ok, error = pcall( function()\
        parallel.waitForAny( function()\
            while true do\
                local sEvent, timer = os.pullEvent( \"timer\" )\
                local nUserID = tPingPongTimer[ timer ]\
                if nUserID and tUsers[ nUserID ] then\
                    local tUser = tUsers[ nUserID ]\
                    if tUser then\
                        if not tUser.bPingPonged then\
                            send( \"* \"..tUser.sUsername..\" has timed out\" )\
                            tUsers[ nUserID ] = nil\
                            nUsers = nUsers - 1\
                            printUsers()\
                        else\
                            ping( nUserID )\
                        end\
                    end\
                end\
            end\
        end,\
        function()\
            while true do\
                local tCommands\
                tCommands = {\
                    [\"me\"] = function( tUser, sContent )\
                        if string.len(sContent) > 0 then\
                            send( \"* \"..tUser.sUsername..\" \"..sContent )\
                        else\
                            send( \"* Usage: /me [words]\", tUser.nUserID )\
                        end\
                    end,\
                    [\"nick\"] = function( tUser, sContent )\
                        if string.len(sContent) > 0 then\
                            local sOldName = tUser.sUsername\
                            tUser.sUsername = sContent\
                            send( \"* \"..sOldName..\" is now known as \"..tUser.sUsername )\
                        else\
                            send( \"* Usage: /nick [nickname]\", tUser.nUserID )\
                        end\
                    end,\
                    [\"users\"] = function( tUser, sContent )\
                        send( \"* Connected Users:\", tUser.nUserID )\
                        local sUsers = \"*\"\
                        for nUserID, tUser in pairs( tUsers ) do\
                            sUsers = sUsers .. \" \" .. tUser.sUsername\
                        end\
                        send( sUsers, tUser.nUserID )\
                    end,\
                    [\"help\"] = function( tUser, sContent )\
                        send( \"* Available commands:\", tUser.nUserID )\
                        local sCommands = \"*\"\
                        for sCommand, fnCommand in pairs( tCommands ) do\
                            sCommands = sCommands .. \" /\" .. sCommand\
                        end\
                        send( sCommands..\" /logout\", tUser.nUserID )\
                    end,\
                }\
\
                local nSenderID, tMessage = rednet.receive( \"chat\" )\
                if type( tMessage ) == \"table\" then\
                    if tMessage.sType == \"login\" then\
                        -- Login from new client\
                        local nUserID = tMessage.nUserID\
                        local sUsername = tMessage.sUsername\
                        if nUserID and sUsername then\
                            tUsers[ nUserID ] = {\
                                nID = nSenderID,\
                                nUserID = nUserID,\
                                sUsername = sUsername,\
                            }\
                            nUsers = nUsers + 1\
                            printUsers()\
                            send( \"* \"..sUsername..\" has joined the chat\" )\
                            ping( nUserID )\
                        end\
\
                    else\
                        -- Something else from existing client\
                        local nUserID = tMessage.nUserID\
                        local tUser = tUsers[ nUserID ]\
                        if tUser and tUser.nID == nSenderID then\
                            if tMessage.sType == \"logout\" then\
                                send( \"* \"..tUser.sUsername..\" has left the chat\" )\
                                tUsers[ nUserID ] = nil\
                                nUsers = nUsers - 1\
                                printUsers()\
\
                            elseif tMessage.sType == \"chat\" then\
                                local sMessage = tMessage.sText\
                                if sMessage then\
                                    local sCommand = string.match( sMessage, \"^/([a-z]+)\" )\
                                    if sCommand then\
                                        local fnCommand = tCommands[ sCommand ]\
                                        if fnCommand then\
                                            local sContent = string.sub( sMessage, string.len(sCommand)+3 )\
                                            fnCommand( tUser, sContent )\
                                        else\
                                            send( \"* Unrecognised command: /\"..sCommand, tUser.nUserID )\
                                        end\
                                    else\
                                        send( \"<\"..tUser.sUsername..\"> \"..tMessage.sText )\
                                    end\
                                end\
\
                            elseif tMessage.sType == \"ping to server\" then\
                                rednet.send( tUser.nID, {\
                                    sType = \"pong to client\",\
                                    nUserID = nUserID,\
                                }, \"chat\" )\
\
                            elseif tMessage.sType == \"pong to server\" then\
                                tUser.bPingPonged = true\
\
                            end\
                        end\
                    end\
                 end\
            end\
        end )\
    end )\
    if not ok then\
        printError( error )\
    end\
\
    -- Unhost server\
    for nUserID, tUser in pairs( tUsers ) do\
        rednet.send( tUser.nID, {\
            sType = \"kick\",\
            nUserID = nUserID,\
        }, \"chat\" )\
    end\
    rednet.unhost( \"chat\" )\
    closeModem()\
\
elseif sCommand == \"join\" then\
    -- \"chat join\"\
    -- Get hostname and username\
    local sHostname = tArgs[2]\
    local sUsername = tArgs[3]\
    if sHostname == nil or sUsername == nil then\
        printUsage()\
        return\
    end\
\
    -- Connect\
    if not openModem() then\
        return\
    end\
    write( \"Looking up \" .. sHostname .. \"... \" )\
    local nHostID = rednet.lookup( \"chat\", sHostname )\
    if nHostID == nil then\
        print( \"Failed.\" )\
        return\
    else\
        print( \"Success.\" )\
    end\
\
    -- Login\
    local nUserID = math.random( 1, 2147483647 )\
    rednet.send( nHostID, {\
        sType = \"login\",\
        nUserID = nUserID,\
        sUsername = sUsername,\
    }, \"chat\" )\
\
    -- Setup ping pong\
    local bPingPonged = true\
    local pingPongTimer = os.startTimer( 0 )\
\
    function ping()\
        rednet.send( nHostID, {\
            sType = \"ping to server\",\
            nUserID = nUserID,\
        }, \"chat\" )\
        bPingPonged = false\
        pingPongTimer = os.startTimer( 15 )\
    end\
\
    -- Handle messages\
    local w,h = term.getSize()\
    local parentTerm = term.current()\
    local titleWindow = window.create( parentTerm, 1, 1, w, 1, true )\
    local historyWindow = window.create( parentTerm, 1, 2, w, h-2, true )\
    local promptWindow = window.create( parentTerm, 1, h, w, 1, true )\
    historyWindow.setCursorPos( 1, h-2 )\
\
    term.clear()\
    term.setTextColour( textColour )\
    term.redirect( promptWindow )\
    promptWindow.restoreCursor()\
\
    function drawTitle()\
        local x,y = titleWindow.getCursorPos()\
        local w,h = titleWindow.getSize()\
        local sTitle = sUsername..\" on \"..sHostname\
        titleWindow.setTextColour( highlightColour )\
        titleWindow.setCursorPos( math.floor( w/2 - string.len(sTitle)/2 ), 1 )\
        titleWindow.clearLine()\
        titleWindow.write( sTitle )\
        promptWindow.restoreCursor()\
    end\
\
    function printMessage( sMessage )\
        term.redirect( historyWindow )\
        print()\
        if string.match( sMessage, \"^\\*\" ) then\
            -- Information\
            term.setTextColour( highlightColour )\
            write( sMessage )\
            term.setTextColour( textColour )\
        else\
            -- Chat\
            local sUsernameBit = string.match( sMessage, \"^\\<[^\\>]*\\>\" )\
            if sUsernameBit then\
                term.setTextColour( highlightColour )\
                write( sUsernameBit )\
                term.setTextColour( textColour )\
                write( string.sub( sMessage, string.len( sUsernameBit ) + 1 ) )\
            else\
                write( sMessage )\
            end\
        end\
        term.redirect( promptWindow )\
        promptWindow.restoreCursor()\
    end\
\
    drawTitle()\
\
    local ok, error = pcall( function()\
        parallel.waitForAny( function()\
            while true do\
                local sEvent, timer = os.pullEvent()\
                if sEvent == \"timer\" then\
                    if timer == pingPongTimer then\
                        if not bPingPonged then\
                            printMessage( \"Server timeout.\" )\
                            return\
                        else\
                            ping()\
                        end\
                    end\
\
                elseif sEvent == \"term_resize\" then\
                    local w,h = parentTerm.getSize()\
                    titleWindow.reposition( 1, 1, w, 1 )\
                    historyWindow.reposition( 1, 2, w, h-2 )\
                    promptWindow.reposition( 1, h, w, 1 )\
\
                end\
            end\
        end,\
        function()\
            while true do\
                local nSenderID, tMessage = rednet.receive( \"chat\" )\
                if nSenderID == nHostID and type( tMessage ) == \"table\" and tMessage.nUserID == nUserID then\
                    if tMessage.sType == \"text\" then\
                        local sText = tMessage.sText\
                        if sText then\
                            printMessage( sText )\
                        end\
\
                    elseif tMessage.sType == \"ping to client\" then\
                        rednet.send( nSenderID, {\
                            sType = \"pong to server\",\
                            nUserID = nUserID,\
                        }, \"chat\" )\
\
                    elseif tMessage.sType == \"pong to client\" then\
                        bPingPonged = true\
\
                    elseif tMessage.sType == \"kick\" then\
                        return\
\
                    end\
                end\
            end\
        end,\
        function()\
            local tSendHistory = {}\
            while true do\
                promptWindow.setCursorPos( 1,1 )\
                promptWindow.clearLine()\
                promptWindow.setTextColor( highlightColour )\
                promptWindow.write( \": \")\
                promptWindow.setTextColor( textColour )\
\
                local sChat = read( nil, tSendHistory )\
                if string.match( sChat, \"^/logout\" ) then\
                    break\
                else\
                    rednet.send( nHostID, {\
                        sType = \"chat\",\
                        nUserID = nUserID,\
                        sText = sChat,\
                    }, \"chat\" )\
                    table.insert( tSendHistory, sChat )\
                end\
            end\
        end )\
    end )\
\
    -- Close the windows\
    term.redirect( parentTerm )\
\
    -- Print error notice\
    local w,h = term.getSize()\
    term.setCursorPos( 1, h )\
    term.clearLine()\
    term.setCursorBlink( false )\
    if not ok then\
        printError( error )\
    end\
\
    -- Logout\
    rednet.send( nHostID, {\
        sType = \"logout\",\
        nUserID = nUserID,\
    }, \"chat\" )\
    closeModem()\
\
    -- Print disconnection notice\
    print( \"Disconnected.\" )\
\
else\
    -- \"chat somethingelse\"\
    printUsage()\
\
end",
      "\
-- Find modems\
local tModems = {}\
for n,sModem in ipairs( peripheral.getNames() ) do\
    if peripheral.getType( sModem ) == \"modem\" then\
        table.insert( tModems, sModem )\
    end\
end\
if #tModems == 0 then\
    print( \"No modems found.\" )\
    return\
elseif #tModems == 1 then\
    print( \"1 modem found.\" )\
else\
    print( #tModems .. \" modems found.\" )\
end\
\
function open( nChannel )\
    for n=1,#tModems do\
        local sModem = tModems[n]\
        peripheral.call( sModem, \"open\", nChannel )\
    end\
end\
\
function close( nChannel )\
    for n=1,#tModems do\
        local sModem = tModems[n]\
        peripheral.call( sModem, \"close\", nChannel )\
    end\
end\
\
-- Open channels\
print( \"0 messages repeated.\" )\
open( rednet.CHANNEL_REPEAT )\
\
-- Main loop (terminate to break)\
local ok, error = pcall( function()\
    local tReceivedMessages = {}\
    local tReceivedMessageTimeouts = {}\
    local nTransmittedMessages = 0\
\
    while true do\
        local sEvent, sModem, nChannel, nReplyChannel, tMessage = os.pullEvent()\
        if sEvent == \"modem_message\" then\
            -- Got a modem message, rebroadcast it if it's a rednet thing\
            if nChannel == rednet.CHANNEL_REPEAT then\
                if type( tMessage ) == \"table\" and tMessage.nMessageID and tMessage.nRecipient then\
                    if not tReceivedMessages[ tMessage.nMessageID ] then\
                        -- Ensure we only repeat a message once\
                        tReceivedMessages[ tMessage.nMessageID ] = true\
                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID\
\
                        -- Send on all other open modems, to the target and to other repeaters\
                        for n=1,#tModems do\
                            local sOtherModem = tModems[n]\
                            peripheral.call( sOtherModem, \"transmit\", rednet.CHANNEL_REPEAT, nReplyChannel, tMessage )\
                            peripheral.call( sOtherModem, \"transmit\", tMessage.nRecipient, nReplyChannel, tMessage )\
                        end\
\
                        -- Log the event\
                        nTransmittedMessages = nTransmittedMessages + 1\
                        local x,y = term.getCursorPos()\
                        term.setCursorPos( 1, y - 1 )\
                        term.clearLine()\
                        if nTransmittedMessages == 1 then\
                            print( nTransmittedMessages .. \" message repeated.\" )\
                        else\
                            print( nTransmittedMessages .. \" messages repeated.\" )\
                        end\
                    end\
                end\
            end\
\
        elseif sEvent == \"timer\" then\
            -- Got a timer event, use it to clear the message history\
            local nTimer = sModem\
            local nMessageID = tReceivedMessageTimeouts[ nTimer ]\
            if nMessageID then\
                tReceivedMessageTimeouts[ nTimer ] = nil\
                tReceivedMessages[ nMessageID ] = nil\
            end\
\
        end\
    end\
end )\
if not ok then\
    printError( error )\
end\
\
-- Close channels\
close( rednet.CHANNEL_REPEAT )",
      "\
local tArgs = { ... }\
\
local function printUsage()\
    print( \"Usages:\" )\
    print( \"redstone probe\" )\
    print( \"redstone set <side> <value>\" )\
    print( \"redstone set <side> <color> <value>\" )\
    print( \"redstone pulse <side> <count> <period>\" )\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"probe\" then\
    -- \"redstone probe\"\
    -- Regular input\
    print( \"Redstone inputs: \" )\
\
    local count = 0\
    local bundledCount = 0\
    for n,sSide in ipairs( redstone.getSides() ) do\
        if redstone.getBundledInput( sSide ) > 0 then\
            bundledCount = bundledCount + 1\
        end\
        if redstone.getInput( sSide ) then\
            if count > 0 then\
                io.write( \", \" )\
            end\
            io.write( sSide )\
            count = count + 1\
        end\
    end\
    if count > 0 then\
        print( \".\" )\
    else\
        print( \"None.\" )\
    end\
\
    -- Bundled input\
    if bundledCount > 0 then\
        print()\
        print( \"Bundled inputs:\" )\
        for i,sSide in ipairs( redstone.getSides() ) do\
            local nInput = redstone.getBundledInput( sSide )\
            if nInput ~= 0 then\
                write( sSide..\": \" )\
                local count = 0\
                for sColour,nColour in pairs( colors ) do\
                    if type( nColour ) == \"number\" and colors.test( nInput, nColour ) then\
                        if count > 0 then\
                            write( \", \" )\
                        end\
                        if term.isColour() then\
                            term.setTextColour( nColour )\
                        end\
                        write( sColour )\
                        if term.isColour() then\
                            term.setTextColour( colours.white )\
                        end\
                        count = count + 1\
                    end\
                end\
                print( \".\" )\
            end\
        end\
    end\
\
elseif sCommand == \"pulse\" then\
    -- \"redstone pulse\"\
    local sSide = tArgs[2]\
    local nCount = tonumber( tArgs[3] ) or 1\
    local nPeriod = tonumber( tArgs[4] ) or 0.5\
    for n=1,nCount do\
        redstone.setOutput( sSide, true )\
        sleep( nPeriod / 2 )\
        redstone.setOutput( sSide, false )\
        sleep( nPeriod / 2 )\
    end\
\
elseif sCommand == \"set\" then\
    -- \"redstone set\"\
    local sSide = tArgs[2]\
    if #tArgs > 3 then\
        -- Bundled cable output\
        local sColour = tArgs[3]\
        local nColour = colors[sColour] or colours[sColour]\
        if type(nColour) ~= \"number\" then\
            printError( \"No such color\" )\
            return\
        end\
\
        local sValue = tArgs[4]\
        if sValue == \"true\" then\
            rs.setBundledOutput( sSide, colors.combine( rs.getBundledOutput( sSide ), nColour ) )\
        elseif sValue == \"false\" then\
            rs.setBundledOutput( sSide, colors.subtract( rs.getBundledOutput( sSide ), nColour ) )\
        else\
            print( \"Value must be boolean\" )\
        end\
    else\
        -- Regular output\
        local sValue = tArgs[3]\
        local nValue = tonumber(sValue)\
        if sValue == \"true\" then\
            rs.setOutput( sSide, true )\
        elseif sValue == \"false\" then\
            rs.setOutput( sSide, false )\
        elseif nValue and nValue >= 0 and nValue <= 15 then\
            rs.setAnalogOutput( sSide, nValue )\
        else\
            print( \"Value must be boolean or 0-15\" )\
        end\
    end\
\
else\
    -- Something else\
    printUsage()\
\
end",
      "local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: rename <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
fs.move( sSource, sDest )",
      "\
local tArgs = { ... }\
if #tArgs == 0 then\
\009-- \"set\"\
\009for n,sName in ipairs( settings.getNames() ) do\
\009\009print( textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName)) )\
\009end\
\
elseif #tArgs == 1 then\
\009-- \"set foo\"\
\009local sName = tArgs[1]\
    print( textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName)) )\
\
else\
\009-- \"set foo bar\"\
\009local sName = tArgs[1]\
\009local sValue = tArgs[2]\
\009local value\
\009if sValue == \"true\" then\
\009\009value = true\
\009elseif sValue == \"false\" then\
\009\009value = false\
\009elseif sValue == \"nil\" then\
\009\009value = nil\
\009elseif tonumber(sValue) then\
\009\009value = tonumber(sValue)\
\009else\
\009\009value = sValue\
\009end\
\
\009local oldValue = settings.get( sValue )\
\009if value ~= nil then\
\009\009settings.set( sName, value )\
\009\009print( textutils.serialize(sName) .. \" set to \" .. textutils.serialize(value) )\
\009else\
\009\009settings.unset( sName )\
\009\009print( textutils.serialize(sName) .. \" unset\" )\
\009end\
\009if value ~= oldValue then\
\009\009settings.save( \".settings\" )\
\009end\
end",
      "local colours = _G.colors\
local function write(string)\
    return term.write(string)\
end\
local multishell = multishell\
local parentShell = shell\
local parentTerm = term.current()\
\
if multishell then\
    multishell.setTitle( multishell.getCurrent(), \"shell\" )\
end\
\
local bExit = false\
local sDir = (parentShell and parentShell.dir()) or \"\"\
local sPath = (parentShell and parentShell.path()) or \".:/rom/programs\"\
local tAliases = (parentShell and parentShell.aliases()) or {}\
local tCompletionInfo = (parentShell and parentShell.getCompletionInfo()) or {}\
local tProgramStack = {}\
\
local shell = {}\
local tEnv = {\
\009[ \"shell\" ] = shell,\
\009[ \"multishell\" ] = multishell,\
}\
\
-- Colours\
local promptColour, textColour, bgColour\
if term.isColour() then\
\009promptColour = colours.yellow\
\009textColour = colours.white\
\009bgColour = colours.black\
else\
\009promptColour = colours.white\
\009textColour = colours.white\
\009bgColour = colours.black\
end\
\
local function run( _sCommand, ... )\
\009local sPath = shell.resolveProgram( _sCommand )\
\009if sPath ~= nil then\
\009\009tProgramStack[#tProgramStack + 1] = sPath\
\009\009if multishell then\
\009\009    multishell.setTitle( multishell.getCurrent(), fs.getName( sPath ) )\
\009\009end\
   \009\009local result = os.run( tEnv, sPath, ... )\
\009\009tProgramStack[#tProgramStack] = nil\
\009\009if multishell then\
\009\009    if #tProgramStack > 0 then\
    \009\009    multishell.setTitle( multishell.getCurrent(), fs.getName( tProgramStack[#tProgramStack] ) )\
    \009\009else\
    \009\009    multishell.setTitle( multishell.getCurrent(), \"shell\" )\
    \009\009end\
\009\009end\
\009\009return result\
   \009else\
    \009printError( \"No such program\" )\
    \009return false\
    end\
end\
\
local function tokenise( ... )\
    local sLine = table.concat( { ... }, \" \" )\
\009local tWords = {}\
    local bQuoted = false\
    for match in string.gmatch( sLine .. \"\\\"\", \"(.-)\\\"\" ) do\
        if bQuoted then\
            table.insert( tWords, match )\
        else\
            for m in string.gmatch( match, \"[^ \\t]+\" ) do\
                table.insert( tWords, m )\
            end\
        end\
        bQuoted = not bQuoted\
    end\
    return tWords\
end\
\
-- Install shell API\
function shell.run( ... )\
\009local tWords = tokenise( ... )\
\009local sCommand = tWords[1]\
\009if sCommand then\
\009\009return run( sCommand, table.unpack( tWords, 2 ) )\
\009end\
\009return false\
end\
\
function shell.exit()\
    bExit = true\
end\
\
function shell.dir()\
\009return sDir\
end\
\
function shell.setDir( _sDir )\
\009sDir = _sDir\
end\
\
function shell.path()\
\009return sPath\
end\
\
function shell.setPath( _sPath )\
\009sPath = _sPath\
end\
\
function shell.resolve( _sPath )\
\009local sStartChar = string.sub( _sPath, 1, 1 )\
\009if sStartChar == \"/\" or sStartChar == \"\\\\\" then\
\009\009return fs.combine( \"\", _sPath )\
\009else\
\009\009return fs.combine( sDir, _sPath )\
\009end\
end\
\
function shell.resolveProgram( _sCommand )\
\009-- Substitute aliases firsts\
\009if tAliases[ _sCommand ] ~= nil then\
\009\009_sCommand = tAliases[ _sCommand ]\
\009end\
\
    -- If the path is a global path, use it directly\
    local sStartChar = string.sub( _sCommand, 1, 1 )\
    if sStartChar == \"/\" or sStartChar == \"\\\\\" then\
    \009local sPath = fs.combine( \"\", _sCommand )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
\009\009return nil\
    end\
    \
 \009-- Otherwise, look on the path variable\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = fs.combine( shell.resolve( sPath ), _sCommand )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
    end\
\009\
\009-- Not found\
\009return nil\
end\
\
function shell.programs( _bIncludeHidden )\
\009local tItems = {}\
\009\
\009-- Add programs from the path\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = shell.resolve( sPath )\
\009\009if fs.isDir( sPath ) then\
\009\009\009local tList = fs.list( sPath )\
            for n=1,#tList do\
                local sFile = tList[n]\
\009\009\009\009if not fs.isDir( fs.combine( sPath, sFile ) ) and\
\009\009\009\009   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= \".\") then\
\009\009\009\009\009tItems[ sFile ] = true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    end\009\
\
\009-- Sort and return\
\009local tItemList = {}\
\009for sItem, b in pairs( tItems ) do\
\009\009table.insert( tItemList, sItem )\
\009end\
\009table.sort( tItemList )\
\009return tItemList\
end\
\
local function completeProgram( sLine )\
\009if #sLine > 0 and string.sub( sLine, 1, 1 ) == \"/\" then\
\009    -- Add programs from the root\
\009    return fs.complete( sLine, \"\", true, false )\
\
    else\
        local tResults = {}\
        local tSeen = {}\
\
        -- Add aliases\
        for sAlias, sCommand in pairs( tAliases ) do\
            if #sAlias > #sLine and string.sub( sAlias, 1, #sLine ) == sLine then\
                local sResult = string.sub( sAlias, #sLine + 1 )\
                if not tSeen[ sResult ] then\
                    table.insert( tResults, sResult )\
                    tSeen[ sResult ] = true\
                end\
            end\
        end\
\
        -- Add programs from the path\
        local tPrograms = shell.programs()\
        for n=1,#tPrograms do\
            local sProgram = tPrograms[n]\
            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then\
                local sResult = string.sub( sProgram, #sLine + 1 )\
                if not tSeen[ sResult ] then\
                    table.insert( tResults, sResult )\
                    tSeen[ sResult ] = true\
                end\
            end\
        end\
\
        -- Sort and return\
        table.sort( tResults )\
        return tResults\
    end\
end\
\
local function completeProgramArgument( sProgram, nArgument, sPart, tPreviousParts )\
    local tInfo = tCompletionInfo[ sProgram ]\
    if tInfo then\
        return tInfo.fnComplete( shell, nArgument, sPart, tPreviousParts )\
    end\
    return nil\
end\
\
function shell.complete( sLine )\
    if #sLine > 0 then\
        local tWords = tokenise( sLine )\
        local nIndex = #tWords\
        if string.sub( sLine, #sLine, #sLine ) == \" \" then\
            nIndex = nIndex + 1\
        end\
        if nIndex == 1 then\
            local sBit = tWords[1] or \"\"\
            local sPath = shell.resolveProgram( sBit )\
            if tCompletionInfo[ sPath ] then\
                return { \" \" }\
            else\
                local tResults = completeProgram( sBit )\
                for n=1,#tResults do\
                    local sResult = tResults[n]\
                    local sPath = shell.resolveProgram( sBit .. sResult )\
                    if tCompletionInfo[ sPath ] then\
                        tResults[n] = sResult .. \" \"\
                    end\
                end\
                return tResults\
            end\
\
        elseif nIndex > 1 then\
            local sPath = shell.resolveProgram( tWords[1] )\
            local sPart = tWords[nIndex] or \"\"\
            local tPreviousParts = tWords\
            tPreviousParts[nIndex] = nil\
            return completeProgramArgument( sPath , nIndex - 1, sPart, tPreviousParts )\
\
        end\
    end\
\009return nil\
end\
\
function shell.completeProgram( sProgram )\
    return completeProgram( sProgram )\
end\
\
function shell.setCompletionFunction( sProgram, fnComplete )\
    tCompletionInfo[ sProgram ] = {\
        fnComplete = fnComplete\
    }\
end\
\
function shell.getCompletionInfo()\
    return tCompletionInfo\
end\
\
function shell.getRunningProgram()\
\009if #tProgramStack > 0 then\
\009\009return tProgramStack[#tProgramStack]\
\009end\
\009return nil\
end\
\
function shell.setAlias( _sCommand, _sProgram )\
\009tAliases[ _sCommand ] = _sProgram\
end\
\
function shell.clearAlias( _sCommand )\
\009tAliases[ _sCommand ] = nil\
end\
\
function shell.aliases()\
\009-- Copy aliases\
\009local tCopy = {}\
\009for sAlias, sCommand in pairs( tAliases ) do\
\009\009tCopy[sAlias] = sCommand\
\009end\
\009return tCopy\
end\
\
if multishell then\
    function shell.openTab( ... )\
        local tWords = tokenise( ... )\
        local sCommand = tWords[1]\
        if sCommand then\
        \009local sPath = shell.resolveProgram( sCommand )\
        \009if sPath == \"rom/programs/shell\" then\
                return multishell.launch( tEnv, sPath, table.unpack( tWords, 2 ) )\
            elseif sPath ~= nil then\
                return multishell.launch( tEnv, \"rom/programs/shell\", sCommand, table.unpack( tWords, 2 ) )\
            else\
                printError( \"No such program\" )\
            end\
        end\
    end\
\
    function shell.switchTab( nID )\
        multishell.setFocus( nID )\
    end\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    -- \"shell x y z\"\
    -- Run the program specified on the commandline\
    shell.run( ... )\
\
else\
    -- \"shell\"\
    -- Print the header\
    term.setBackgroundColor( bgColour )\
    term.setTextColour( promptColour )\
    print( os.version() )\
    term.setTextColour( textColour )\
\
    -- Run the startup program\
    if parentShell == nil then\
        shell.run( \"/rom/startup\" )\
    end\
\
    -- Read commands and execute them\
    local tCommandHistory = {}\
    while not bExit do\
        term.redirect( parentTerm )\
        term.setBackgroundColor( bgColour )\
        term.setTextColour( promptColour )\
        write( shell.dir() .. \"> \" )\
        term.setTextColour( textColour )\
\
\
        local sLine\
        if settings.get( \"shell.autocomplete\" ) then\
            sLine = read( nil, tCommandHistory, shell.complete )\
        else\
            sLine = read( nil, tCommandHistory )\
        end\
        table.insert( tCommandHistory, sLine )\
        shell.run( sLine )\
    end\
end",
      "if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Goodbye\" )\
term.setTextColour( colours.white )\
\
sleep( 1 )\
os.shutdown()",
      "local nTime = os.time()\
local nDay = os.day()\
print( \"The time is \"..textutils.formatTime( nTime, false )..\" on Day \"..nDay )",
      "\
if not turtle.craft then\
    print( \"Requires a Crafty Turtle\" )\
    return\
end\
\
local tArgs = { ... }\
local nLimit = nil\
if #tArgs < 1 then\
\009print( \"Usage: craft [number]\" )\
\009return\
else\
\009nLimit = tonumber( tArgs[1] )\
end\
\
local nCrafted = 0\
local nOldCount = turtle.getItemCount( turtle.getSelectedSlot() )\
if turtle.craft( nLimit ) then\
    local nNewCount = turtle.getItemCount( turtle.getSelectedSlot() )\
    if nOldCount <= nLimit then\
        nCrafted = nNewCount\
    else\
        nCrafted = nOldCount - nNewCount\
    end\
end\
\
if nCrafted > 1 then\
    print( nCrafted..\" items crafted\" )\
elseif nCrafted == 1 then\
    print( \"1 item crafted\" )\
else\
    print( \"No items crafted\" )\
end",
      "\
local tMoves = {\
\009function()\
\009\009turtle.up()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.up()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.up()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009end,\
\009function()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009end,\
\009function()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009end,\
}\
\
textutils.slowWrite( \"Preparing to get down.\" )\
textutils.slowPrint( \"..\", 0.75 )\
\
local sAudio = nil\
for n,sName in pairs( peripheral.getNames() ) do\
\009if disk.hasAudio( sName ) then\
\009\009disk.playAudio( sName )\
\009\009print( \"Jamming to \"..disk.getAudioTitle( sName ) )\
\009\009sAudio = sName\
\009\009break\
\009end\
end\
\
print( \"Press any key to stop the groove\" )\
\
local bEnd = false\
parallel.waitForAll(\
\009function()\
\009\009while not bEnd do\
\009\009\009local event, key = os.pullEvent(\"key\")\
\009\009\009if key ~= keys.escape then\
\009\009\009\009bEnd = true\
\009\009\009end\
\009\009end\009\009\
\009end,\
\009function()\
\009\009while not bEnd do\
\009\009\009local fnMove = tMoves[math.random(1,#tMoves)]\
\009\009\009fnMove()\
\009\009end\
\009end\
)\
\
if sAudio then\
\009disk.stopAudio( sAudio )\
end",
      "\
local tArgs = { ... }\
local function printUsage()\
\009print( \"Usage: equip <slot> <side>\" )\
end\
\
if #tArgs ~= 2 then\
    printUsage()\
\009return\
end\
\
local function equip( nSlot, fnEquipFunction )\
    turtle.select( nSlot )\
    local nOldCount = turtle.getItemCount( nSlot )\
    if nOldCount == 0 then\
        print( \"Nothing to equip\" )\
    elseif fnEquipFunction() then\
        local nNewCount = turtle.getItemCount( nSlot )\
        if nNewCount > 0 then\
            print( \"Items swapped\" )\
        else\
            print( \"Item equipped\" )\
        end\
    else\
        print( \"Item not equippable\" )\
    end\
end\
\
local nSlot = tonumber( tArgs[1] )\
local sSide = tArgs[2]\
if sSide == \"left\" then\
    equip( nSlot, turtle.equipLeft )\
elseif sSide == \"right\" then\
    equip( nSlot, turtle.equipRight )\
else\
    printUsage()\
    return\
end",
      "\
local tArgs = { ... }\
if #tArgs ~= 1 then\
\009print( \"Usage: excavate <diameter>\" )\
\009return\
end\
\
-- Mine in a quarry pattern until we hit something we can't dig\
local size = tonumber( tArgs[1] )\
if size < 1 then\
\009print( \"Excavate diameter must be positive\" )\
\009return\
end\
\009\
local depth = 0\
local unloaded = 0\
local collected = 0\
\
local xPos,zPos = 0,0\
local xDir,zDir = 0,1\
\
local goTo -- Filled in further down\
local refuel -- Filled in further down\
 \
local function unload( _bKeepOneFuelStack )\
\009print( \"Unloading items...\" )\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nCount > 0 then\
\009\009\009turtle.select(n)\009\009\009\
\009\009\009local bDrop = true\
\009\009\009if _bKeepOneFuelStack and turtle.refuel(0) then\
\009\009\009\009bDrop = false\
\009\009\009\009_bKeepOneFuelStack = false\
\009\009\009end\009\009\009\
\009\009\009if bDrop then\
\009\009\009\009turtle.drop()\
\009\009\009\009unloaded = unloaded + nCount\
\009\009\009end\
\009\009end\
\009end\
\009collected = 0\
\009turtle.select(1)\
end\
\
local function returnSupplies()\
\009local x,y,z,xd,zd = xPos,depth,zPos,xDir,zDir\
\009print( \"Returning to surface...\" )\
\009goTo( 0,0,0,0,-1 )\
\009\
\009local fuelNeeded = 2*(x+y+z) + 1\
\009if not refuel( fuelNeeded ) then\
\009\009unload( true )\
\009\009print( \"Waiting for fuel\" )\
\009\009while not refuel( fuelNeeded ) do\
\009\009\009os.pullEvent( \"turtle_inventory\" )\
\009\009end\
\009else\
\009\009unload( true )\009\
\009end\
\009\
\009print( \"Resuming mining...\" )\
\009goTo( x,y,z,xd,zd )\
end\
\
local function collect()\009\
\009local bFull = true\
\009local nTotalItems = 0\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nCount == 0 then\
\009\009\009bFull = false\
\009\009end\
\009\009nTotalItems = nTotalItems + nCount\
\009end\
\009\
\009if nTotalItems > collected then\
\009\009collected = nTotalItems\
\009\009if math.fmod(collected + unloaded, 50) == 0 then\
\009\009\009print( \"Mined \"..(collected + unloaded)..\" items.\" )\
\009\009end\
\009end\
\009\
\009if bFull then\
\009\009print( \"No empty slots left.\" )\
\009\009return false\
\009end\
\009return true\
end\
\
function refuel( ammount )\
\009local fuelLevel = turtle.getFuelLevel()\
\009if fuelLevel == \"unlimited\" then\
\009\009return true\
\009end\
\009\
\009local needed = ammount or (xPos + zPos + depth + 2)\
\009if turtle.getFuelLevel() < needed then\
\009\009local fueled = false\
\009\009for n=1,16 do\
\009\009\009if turtle.getItemCount(n) > 0 then\
\009\009\009\009turtle.select(n)\
\009\009\009\009if turtle.refuel(1) then\
\009\009\009\009\009while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do\
\009\009\009\009\009\009turtle.refuel(1)\
\009\009\009\009\009end\
\009\009\009\009\009if turtle.getFuelLevel() >= needed then\
\009\009\009\009\009\009turtle.select(1)\
\009\009\009\009\009\009return true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009turtle.select(1)\
\009\009return false\
\009end\
\009\
\009return true\
end\
\
local function tryForwards()\
\009if not refuel() then\
\009\009print( \"Not enough Fuel\" )\
\009\009returnSupplies()\
\009end\
\009\
\009while not turtle.forward() do\
\009\009if turtle.detect() then\
\009\009\009if turtle.dig() then\
\009\009\009\009if not collect() then\
\009\009\009\009\009returnSupplies()\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attack() then\
\009\009\009if not collect() then\
\009\009\009\009returnSupplies()\
\009\009\009end\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009\
\009xPos = xPos + xDir\
\009zPos = zPos + zDir\
\009return true\
end\
\
local function tryDown()\
\009if not refuel() then\
\009\009print( \"Not enough Fuel\" )\
\009\009returnSupplies()\
\009end\
\009\
\009while not turtle.down() do\
\009\009if turtle.detectDown() then\
\009\009\009if turtle.digDown() then\
\009\009\009\009if not collect() then\
\009\009\009\009\009returnSupplies()\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackDown() then\
\009\009\009if not collect() then\
\009\009\009\009returnSupplies()\
\009\009\009end\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\
\009depth = depth + 1\
\009if math.fmod( depth, 10 ) == 0 then\
\009\009print( \"Descended \"..depth..\" metres.\" )\
\009end\
\
\009return true\
end\
\
local function turnLeft()\
\009turtle.turnLeft()\
\009xDir, zDir = -zDir, xDir\
end\
\
local function turnRight()\
\009turtle.turnRight()\
\009xDir, zDir = zDir, -xDir\
end\
\
function goTo( x, y, z, xd, zd )\
\009while depth > y do\
\009\009if turtle.up() then\
\009\009\009depth = depth - 1\
\009\009elseif turtle.digUp() or turtle.attackUp() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\
\009if xPos > x then\
\009\009while xDir ~= -1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while xPos > x do\
\009\009\009if turtle.forward() then\
\009\009\009\009xPos = xPos - 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009elseif xPos < x then\
\009\009while xDir ~= 1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while xPos < x do\
\009\009\009if turtle.forward() then\
\009\009\009\009xPos = xPos + 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009end\
\009\
\009if zPos > z then\
\009\009while zDir ~= -1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while zPos > z do\
\009\009\009if turtle.forward() then\
\009\009\009\009zPos = zPos - 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009elseif zPos < z then\
\009\009while zDir ~= 1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while zPos < z do\
\009\009\009if turtle.forward() then\
\009\009\009\009zPos = zPos + 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\009\
\009end\
\009\
\009while depth < y do\
\009\009if turtle.down() then\
\009\009\009depth = depth + 1\
\009\009elseif turtle.digDown() or turtle.attackDown() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009\
\009while zDir ~= zd or xDir ~= xd do\
\009\009turnLeft()\
\009end\
end\
\
if not refuel() then\
\009print( \"Out of Fuel\" )\
\009return\
end\
\
print( \"Excavating...\" )\
\
local reseal = false\
turtle.select(1)\
if turtle.digDown() then\
\009reseal = true\
end\
\
local alternate = 0\
local done = false\
while not done do\
\009for n=1,size do\
\009\009for m=1,size-1 do\
\009\009\009if not tryForwards() then\
\009\009\009\009done = true\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009if done then\
\009\009\009break\
\009\009end\
\009\009if n<size then\
\009\009\009if math.fmod(n + alternate,2) == 0 then\
\009\009\009\009turnLeft()\
\009\009\009\009if not tryForwards() then\
\009\009\009\009\009done = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009\009turnLeft()\
\009\009\009else\
\009\009\009\009turnRight()\
\009\009\009\009if not tryForwards() then\
\009\009\009\009\009done = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009\009turnRight()\
\009\009\009end\
\009\009end\
\009end\
\009if done then\
\009\009break\
\009end\
\009\
\009if size > 1 then\
\009\009if math.fmod(size,2) == 0 then\
\009\009\009turnRight()\
\009\009else\
\009\009\009if alternate == 0 then\
\009\009\009\009turnLeft()\
\009\009\009else\
\009\009\009\009turnRight()\
\009\009\009end\
\009\009\009alternate = 1 - alternate\
\009\009end\
\009end\
\009\
\009if not tryDown() then\
\009\009done = true\
\009\009break\
\009end\
end\
\
print( \"Returning to surface...\" )\
\
-- Return to where we started\
goTo( 0,0,0,0,-1 )\
unload( false )\
goTo( 0,0,0,0,1 )\
\
-- Seal the hole\
if reseal then\
\009turtle.placeDown()\
end\
\
print( \"Mined \"..(collected + unloaded)..\" items total.\" )",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: go <direction> <distance>\" )\
\009return\
end\
\
local tHandlers = {\
\009[\"fd\"] = turtle.forward,\
\009[\"forward\"] = turtle.forward,\
\009[\"forwards\"] = turtle.forward,\
\009[\"bk\"] = turtle.back,\
\009[\"back\"] = turtle.back,\
\009[\"up\"] = turtle.up,\
\009[\"dn\"] = turtle.down,\
\009[\"down\"] = turtle.down,\
\009[\"lt\"] = turtle.turnLeft,\
\009[\"left\"] = turtle.turnLeft,\
\009[\"rt\"] = turtle.turnRight,\
\009[\"right\"] = turtle.turnRight,\
}\
\
local nArg = 1\
while nArg <= #tArgs do\
\009local sDirection = tArgs[nArg]\
\009local nDistance = 1\
\009if nArg < #tArgs then\
\009\009local num = tonumber( tArgs[nArg + 1] )\
\009\009if num then\
\009\009\009nDistance = num\
\009\009\009nArg = nArg + 1\
\009\009end\
\009end\
\009nArg = nArg + 1\
\
\009local fnHandler = tHandlers[string.lower(sDirection)]\
\009if fnHandler then\
\009\009while nDistance > 0 do\
\009\009\009if fnHandler() then\
\009\009\009\009nDistance = nDistance - 1\
\009\009\009elseif turtle.getFuelLevel() == 0 then\
\009\009\009\009print( \"Out of fuel\" )\
\009\009\009\009return\
\009\009\009else\
\009\009\009\009sleep(0.5)\
\009\009\009end\
\009\009end\
\009else\
\009\009print( \"No such direction: \"..sDirection )\
\009\009print( \"Try: forward, back, up, down\" )\
\009\009return\
\009end\
\
end",
      "\
local tArgs = { ... }\
local nLimit = 1\
if #tArgs > 1 then\
\009print( \"Usage: refuel [number]\" )\
\009return\
elseif #tArgs > 0 then\
\009if tArgs[1] == \"all\" then\
\009\009nLimit = 64 * 16\
\009else\
\009\009nLimit = tonumber( tArgs[1] )\
\009end\
end\
\
if turtle.getFuelLevel() ~= \"unlimited\" then\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nLimit > 0 and nCount > 0 and turtle.getFuelLevel() < turtle.getFuelLimit() then\
\009\009    local nBurn = math.min( nLimit, nCount )\
\009\009\009turtle.select( n )\
\009\009\009if turtle.refuel( nBurn ) then\
\009\009\009    local nNewCount = turtle.getItemCount(n)\
    \009\009\009nLimit = nLimit - (nCount - nNewCount)\
    \009\009end\
\009\009end\
\009end\
    print( \"Fuel level is \"..turtle.getFuelLevel() )\
    if turtle.getFuelLevel() == turtle.getFuelLimit() then\
        print( \"Fuel limit reached\" )\
    end\
else\
    print( \"Fuel level is unlimited\" )\
end",
      "\
local tArgs = { ... }\
if #tArgs ~= 1 then\
\009print( \"Usage: tunnel <length>\" )\
\009return\
end\
\
-- Mine in a quarry pattern until we hit something we can't dig\
local length = tonumber( tArgs[1] )\
if length < 1 then\
\009print( \"Tunnel length must be positive\" )\
\009return\
end\
\009\
local depth = 0\
local collected = 0\
\
local function collect()\
\009collected = collected + 1\
\009if math.fmod(collected, 25) == 0 then\
\009\009print( \"Mined \"..collected..\" items.\" )\
\009end\
end\
\
local function tryDig()\
\009while turtle.detect() do\
\009\009if turtle.dig() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDigUp()\
\009while turtle.detectUp() do\
\009\009if turtle.digUp() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDigDown()\
\009while turtle.detectDown() do\
\009\009if turtle.digDown() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function refuel()\
\009local fuelLevel = turtle.getFuelLevel()\
\009if fuelLevel == \"unlimited\" or fuelLevel > 0 then\
\009\009return\
\009end\
\009\
\009local function tryRefuel()\
\009\009for n=1,16 do\
\009\009\009if turtle.getItemCount(n) > 0 then\
\009\009\009\009turtle.select(n)\
\009\009\009\009if turtle.refuel(1) then\
\009\009\009\009\009turtle.select(1)\
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009turtle.select(1)\
\009\009return false\
\009end\
\009\
\009if not tryRefuel() then\
\009\009print( \"Add more fuel to continue.\" )\
\009\009while not tryRefuel() do\
\009\009\009os.pullEvent( \"turtle_inventory\" )\
\009\009end\
\009\009print( \"Resuming Tunnel.\" )\
\009end\
end\
\
local function tryUp()\
\009refuel()\
\009while not turtle.up() do\
\009\009if turtle.detectUp() then\
\009\009\009if not tryDigUp() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackUp() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDown()\
\009refuel()\
\009while not turtle.down() do\
\009\009if turtle.detectDown() then\
\009\009\009if not tryDigDown() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackDown() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
local function tryForward()\
\009refuel()\
\009while not turtle.forward() do\
\009\009if turtle.detect() then\
\009\009\009if not tryDig() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attack() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
print( \"Tunnelling...\" )\
\
for n=1,length do\
\009turtle.placeDown()\
\009tryDigUp()\
\009turtle.turnLeft()\
\009tryDig()\
\009tryUp()\
\009tryDig()\
\009turtle.turnRight()\
\009turtle.turnRight()\
\009tryDig()\
\009tryDown()\
\009tryDig()\
\009turtle.turnLeft()\
\009\
\009if n<length then\
\009\009tryDig()\
\009\009if not tryForward() then\
\009\009\009print( \"Aborting Tunnel.\" )\
\009\009\009break\
\009\009end\
\009else\
\009\009print( \"Tunnel complete.\" )\
\009end\
\
end\
\
--[[\
print( \"Returning to start...\" )\
\
-- Return to where we started\
turtle.turnLeft()\
turtle.turnLeft()\
while depth > 0 do\
\009if turtle.forward() then\
\009\009depth = depth - 1\
\009else\
\009\009turtle.dig()\
\009end\
end\
turtle.turnRight()\
turtle.turnRight()\
]]\
\
print( \"Tunnel complete.\" )\
print( \"Mined \"..collected..\" items total.\" )",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: turn <direction> <turns>\" )\
\009return\
end\
\
local tHandlers = {\
\009[\"lt\"] = turtle.turnLeft,\
\009[\"left\"] = turtle.turnLeft,\
\009[\"rt\"] = turtle.turnRight,\
\009[\"right\"] = turtle.turnRight,\
}\
\
local nArg = 1\
while nArg <= #tArgs do\
\009local sDirection = tArgs[nArg]\
\009local nDistance = 1\
\009if nArg < #tArgs then\
\009\009local num = tonumber( tArgs[nArg + 1] )\
\009\009if num then\
\009\009\009nDistance = num\
\009\009\009nArg = nArg + 1\
\009\009end\
\009end\
\009nArg = nArg + 1\
\
\009local fnHandler = tHandlers[string.lower(sDirection)]\
\009if fnHandler then\
\009\009for n=1,nDistance do\
\009\009\009fnHandler( nArg )\
\009\009end\
\009else\
\009\009print( \"No such direction: \"..sDirection )\
\009\009print( \"Try: left, right\" )\
\009\009return\
\009end\
\009\
end",
      "\
local tArgs = { ... }\
local function printUsage()\
\009print( \"Usage: unequip <side>\" )\
end\
\
if #tArgs ~= 1 then\
    printUsage()\
\009return\
end\
\
local function unequip( fnEquipFunction )\
    for nSlot=1,16 do\
        local nOldCount = turtle.getItemCount( nSlot )\
        if nOldCount == 0 then\
            turtle.select( nSlot )\
            if fnEquipFunction() then\
                local nNewCount = turtle.getItemCount( nSlot )\
                if nNewCount > 0 then\
                    print( \"Item unequipped\" )\
                    return\
                else\
                    print( \"Nothing to unequip\" )\
                    return\
                end\
            end\
        end\
    end\
    print( \"No space to unequip item\" )\
end\
\
local sSide = tArgs[1]\
if sSide == \"left\" then\
    unequip( turtle.equipLeft )\
elseif sSide == \"right\" then\
    unequip( turtle.equipRight )\
else\
    printUsage()\
    return\
end",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: type <path>\" )\
  \009return\
end\
\
local sPath = shell.resolve( tArgs[1] )\
if fs.exists( sPath ) then\
\009if fs.isDir( sPath ) then\
\009\009print( \"directory\" )\
\009else\
\009\009print( \"file\" )\
\009end\
else\
\009print( \"No such path\" )\
end",
      "print(tostring(term))\
-- Setup paths\
local sPath = \".:/rom/programs\"\
if term.isColor() then\
\009sPath = sPath..\":/rom/programs/advanced\"\
end\
if turtle then\
\009sPath = sPath..\":/rom/programs/turtle\"\
else\
    sPath = sPath..\":/rom/programs/rednet:/rom/programs/fun\"\
    if term.isColor() then\
    \009sPath = sPath..\":/rom/programs/fun/advanced\"\
    end\
end\
if pocket then\
    sPath = sPath..\":/rom/programs/pocket\"\
end\
if commands then\
    sPath = sPath..\":/rom/programs/command\"\
end\
if http then\
\009sPath = sPath..\":/rom/programs/http\"\
end\
shell.setPath( sPath )\
help.setPath( \"/rom/help\" )\
\
-- Setup aliases\
shell.setAlias( \"ls\", \"list\" )\
shell.setAlias( \"dir\", \"list\" )\
shell.setAlias( \"cp\", \"copy\" )\
shell.setAlias( \"mv\", \"move\" )\
shell.setAlias( \"rm\", \"delete\" )\
shell.setAlias( \"clr\", \"clear\" )\
shell.setAlias( \"rs\", \"redstone\" )\
shell.setAlias( \"sh\", \"shell\" )\
if term.isColor() then\
    shell.setAlias( \"background\", \"bg\" )\
    shell.setAlias( \"foreground\", \"fg\" )\
end\
\
-- Setup completion functions\
local function completeMultipleChoice( sText, tOptions, bAddSpaces )\
    local tResults = {}\
    for n=1,#tOptions do\
        local sOption = tOptions[n]\
        if #sOption + (bAddSpaces and 1 or 0) > #sText and string.sub( sOption, 1, #sText ) == sText then\
            local sResult = string.sub( sOption, #sText + 1 )\
            if bAddSpaces then\
                table.insert( tResults, sResult .. \" \" )\
            else\
                table.insert( tResults, sResult )\
            end\
        end\
    end\
    return tResults\
end\
local function completePeripheralName( sText, bAddSpaces )\
    return completeMultipleChoice( sText, peripheral.getNames(), bAddSpaces )\
end\
--disable redstone, not available in cVM\
--[[local tRedstoneSides = redstone.getSides()\
local function completeSide( sText, bAddSpaces )\
    return completeMultipleChoice( sText, tRedstoneSides, bAddSpaces )\
end]]\
local function completeFile( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), true, false )\
    end\
end\
local function completeDir( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), false, true )\
    end\
end\
local function completeEither( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), true, true )\
    end\
end\
local function completeEitherEither( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        local tResults = fs.complete( sText, shell.dir(), true, true )\
        for n=1,#tResults do\
            local sResult = tResults[n]\
            if string.sub( sResult, #sResult, #sResult ) ~= \"/\" then\
                tResults[n] = sResult .. \" \"\
            end\
        end\
        return tResults\
    elseif nIndex == 2 then\
        return fs.complete( sText, shell.dir(), true, true )\
    end\
end\
local function completeProgram( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return shell.completeProgram( sText )\
    end\
end\
local function completeHelp( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return help.completeTopic( sText )\
    end\
end\
local function completeAlias( shell, nIndex, sText, tPreviousText )\
    if nIndex == 2 then\
        return shell.completeProgram( sText )\
    end\
end\
local function completePeripheral( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completePeripheralName( sText )\
    end\
end\
local tGPSOptions = { \"host\", \"host \", \"locate\" }\
local function completeGPS( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tGPSOptions )\
    end\
end\
local tLabelOptions = { \"get\", \"get \", \"set \", \"clear\", \"clear \" }\
local function completeLabel( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tLabelOptions )\
    elseif nIndex == 2 then\
        return completePeripheralName( sText )\
    end\
end\
local function completeMonitor( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completePeripheralName( sText, true )\
    elseif nIndex == 2 then\
        return shell.completeProgram( sText )\
    end\
end\
local tRedstoneOptions = { \"probe\", \"set \", \"pulse \" }\
local function completeRedstone( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tRedstoneOptions )\
    elseif nIndex == 2 then\
        return completeSide( sText )\
    end\
end\
local tDJOptions = { \"play\", \"play \", \"stop \" }\
local function completeDJ( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tDJOptions )\
    elseif nIndex == 2 then\
        return completePeripheralName( sText )\
    end\
end\
local tPastebinOptions = { \"put \", \"get \", \"run \" }\
local function completePastebin( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tPastebinOptions )\
    elseif nIndex == 2 then\
        if tPreviousText[2] == \"put\" then\
            return fs.complete( sText, shell.dir(), true, false )\
        end\
    end\
end\
local tChatOptions = { \"host \", \"join \" }\
local function completeChat( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tChatOptions )\
    end\
end\
local function completeSet( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, settings.getNames(), true )\
    end\
end\
shell.setCompletionFunction( \"rom/programs/alias\", completeAlias )\
shell.setCompletionFunction( \"rom/programs/cd\", completeDir )\
shell.setCompletionFunction( \"rom/programs/copy\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/delete\", completeEither )\
shell.setCompletionFunction( \"rom/programs/drive\", completeDir )\
shell.setCompletionFunction( \"rom/programs/edit\", completeFile )\
shell.setCompletionFunction( \"rom/programs/eject\", completePeripheral )\
shell.setCompletionFunction( \"rom/programs/gps\", completeGPS )\
shell.setCompletionFunction( \"rom/programs/help\", completeHelp )\
shell.setCompletionFunction( \"rom/programs/id\", completePeripheral )\
shell.setCompletionFunction( \"rom/programs/label\", completeLabel )\
shell.setCompletionFunction( \"rom/programs/list\", completeDir )\
shell.setCompletionFunction( \"rom/programs/mkdir\", completeFile )\
shell.setCompletionFunction( \"rom/programs/monitor\", completeMonitor )\
shell.setCompletionFunction( \"rom/programs/move\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/redstone\", completeRedstone )\
shell.setCompletionFunction( \"rom/programs/rename\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/shell\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/type\", completeEither )\
shell.setCompletionFunction( \"rom/programs/set\", completeSet )\
shell.setCompletionFunction( \"rom/programs/advanced/bg\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/advanced/fg\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/fun/dj\", completeDJ )\
shell.setCompletionFunction( \"rom/programs/fun/advanced/paint\", completeFile )\
shell.setCompletionFunction( \"rom/programs/http/pastebin\", completePastebin )\
shell.setCompletionFunction( \"rom/programs/rednet/chat\", completeChat )\
\
-- Run autorun files\
if fs.exists( \"/rom/autorun\" ) and fs.isDir( \"/rom/autorun\" ) then\
\009local tFiles = fs.list( \"/rom/autorun\" )\
\009table.sort( tFiles )\
\009for n, sFile in ipairs( tFiles ) do\
\009\009if string.sub( sFile, 1, 1 ) ~= \".\" then\
\009\009\009local sPath = \"/rom/autorun/\"..sFile\
\009\009\009if not fs.isDir( sPath ) then\
\009\009\009\009shell.run( sPath )\
\009\009\009end\
\009\009end\
\009end\
end\
\
-- Run the user created startup, either from disk drives or the root\
local sUserStartup = nil\
if settings.get( \"shell.allow_startup\" ) then\
    sUserStartup = shell.resolveProgram( \"/startup\" )\
end\
if settings.get( \"shell.allow_disk_startup\" ) then\
    for n,sName in pairs( peripheral.getNames() ) do\
        if disk.isPresent( sName ) and disk.hasData( sName ) then\
            local sDiskStartup = shell.resolveProgram( \"/\" .. disk.getMountPath( sName ) .. \"/startup\" )\
            if sDiskStartup then\
                sUserStartup = sDiskStartup\
                break\
            end\
        end\
    end\
end\
if sUserStartup then\
    shell.run( sUserStartup )\
end",
    },
  },
  bootSector = {
    [ "bios.lua" ] = "\
local label = \"cVM\"\
os.loadAPI = function(path)\
\009local f, err = loadfile(path)\
\009if not f then\
\009\009return false, err\
\009end\
\009local env = {}\
\009setmetatable(env, {__index=_G})\
\009setfenv(f, env)\
\009local k, err = pcall(f)\
\009if not k then \
\009\009return false, err\
\009end\
\009_G[fs.getName(path)] = {}\
\009for k, v in pairs(env) do\
\009\009_G[fs.getName(path)][k] = v\
\009end\
\009return true\
end\
os.version = function()\
\009return \"cVMWare CraftOS 1.7\"\
end\
os.getComputerID = function()\
\009return 0\
end\
os.getComputerLabel = function()\
\009return label\
end\
os.setComputerLabel = function(lbl)\
\009if lbl then\
\009\009label = lbl\
\009else\
\009\009label = \"cVM\"\
\009end\
end\
_G.write = function(string)\
\009term.write(string)\
end\
_G.sleep = function(time)\
\009return os.sleep(time)\
end\
function os.run(env, path, ...)\
\009local tArgs = {...}\
\009local func, err = loadfile(path)\
\009if not func then return false, err end\
\009setmetatable(env, {__index = _G})\
\009setfenv(func, env)\
\009return func(unpack(tArgs))\
end\
os.unloadAPI = function(name)\
\009_G[name] = nil\
end\
for k, v in pairs(_G) do\
\009term.write(k..\":\")\
end\
\
print(\"\")\
print(\"\")\
for k, v in ipairs(fs.list(\"/\")) do\
\009print(v)\
end\
print(\"Finished BIOS!\")\
print(\"NOTE: This is NOT CraftOS, many APIs you know from\")\
print(\"stock CC are not existent!!!\")\
print(\"Type 'reboot' to reboot this VM\")\
print(\"Type 'shutdown' to shut this VM down.\")\
print(\"Type 'newFile' to create a file in /\")\
print(\"Type 'ls' to list the files in /\")\
print(\"Type 'del' to delete a file in /\")\
while true do\
\009local e = read()\
\009if e == \"reboot\" then\
\009\009_vm.reboot()\
\009elseif e == \"shutdown\" then\
\009\009_vm.shutdown()\
\009elseif fs.exists(e) and fs.isDir(e) == false then\
\009\009local a, err = loadfile(e)\
\009\009if not a then\
\009\009\009print(err)\
\009\009else\
\009\009\009local _, err = pcall(a)\
\009\009\009if not _ then\
\009\009\009\009print(err)\
\009\009\009else\
\009\009\009\009print(\"Successfully executed!\")\
\009\009\009end\
\009\009end\
\009elseif e == \"newFile\" then\
\009\009term.write(\"Name: \")\
\009\009e = read()\
\009\009if #e < 1 then\
\009\009\009e = \"newFile\" \
\009\009end\
\009\009local file = fs.open(e, \"w\")\
\009\009term.write(\"Text: \")\
\009\009e = read()\
\009\009file.writeLine(e)\
\009\009file.close()\
\009\009print(\"Finished!\")\
\009elseif e == \"ls\" then\
\009\009local list = fs.list(\"/\")\
\009\009for k, v in ipairs(list) do\
\009\009\009print(v)\
\009\009end\
\009elseif e == \"del\" then\
\009\009term.write(\"Path:\")\
\009\009local e = read()\
\009\009local ok, err = fs.delete(e..\"/\")\
\009\009if ok or err == nil then\
\009\009\009print(\"Finished!\")\
\009\009else\
\009\009\009print(\"Error:\"..tostring(err))\
\009\009end\
\009end\
end",
  },
}