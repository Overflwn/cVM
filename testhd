{
  sector0 = {},
  sector1 = {
    folders = {
      "boot",
      "vit",
      "etc",
      "etc/repositories",
      "etc/services.d",
      "etc/.installed",
      "etc/.installed/clinux",
      "etc/.installed/main",
      "test",
      "bin",
      "home",
      "home/test",
      "home/root",
      "sys",
      "lib",
      "rom",
      "rom/help",
      "rom/help/licenses",
      "rom/autorun",
      "rom/programs",
      "rom/programs/fun",
      "rom/programs/fun/advanced",
      "rom/programs/fun/advanced/levels",
      "rom/programs/pocket",
      "rom/programs/http",
      "rom/programs/rednet",
      "rom/programs/advanced",
      "rom/programs/command",
      "rom/programs/turtle",
      "rom/apis",
      "rom/apis/pocket",
      "rom/apis/command",
      "rom/apis/turtle",
    },
    files = {
      "boot/load",
      "boot/CraftOS",
      "boot/clinux.i",
      "vit/alive",
      "etc/repositories/clinux",
      "etc/repositories/main",
      "etc/repolist",
      "etc/services.conf",
      "etc/services.d/rednet",
      "etc/.installed/clinux/luaide",
      "etc/.installed/clinux/updater",
      "etc/.installed/clinux/edit",
      "etc/.installed/main/packman",
      "KrapFile",
      "bin/cd",
      "bin/luaide",
      "bin/packman",
      "bin/UpdateCLinux",
      "bin/ls",
      "bin/rm",
      "bin/edit",
      "bin/ps",
      "bin/mkdir",
      "bin/clear",
      "grubcfg",
      "home/test/.aliases",
      "home/test/.bashcol",
      "sys/thread.l",
      "sys/.rootpw",
      "sys/usrData",
      "sys/perm.l",
      "sys/sThread.l",
      "sys/rednet",
      "sys/shell.lua",
      "sys/fs.l",
      "sys/cmdbak",
      "lib/sha.l",
      "lib/xstr.l",
      "lib/services.l",
      "startup",
      "rom/help/cd",
      "rom/help/repeat",
      "rom/help/modems",
      "rom/help/help",
      "rom/help/gpsapi",
      "rom/help/move",
      "rom/help/time",
      "rom/help/os",
      "rom/help/multishell",
      "rom/help/keys",
      "rom/help/chat",
      "rom/help/math",
      "rom/help/alias",
      "rom/help/type",
      "rom/help/redstoneapi",
      "rom/help/go",
      "rom/help/drives",
      "rom/help/http",
      "rom/help/commands",
      "rom/help/vector",
      "rom/help/dj",
      "rom/help/licenses/luaj",
      "rom/help/whatsnew",
      "rom/help/rs",
      "rom/help/bundled",
      "rom/help/lua",
      "rom/help/adventure",
      "rom/help/term",
      "rom/help/reboot",
      "rom/help/io",
      "rom/help/programs",
      "rom/help/textutils",
      "rom/help/bg",
      "rom/help/list",
      "rom/help/tunnel",
      "rom/help/sleep",
      "rom/help/set",
      "rom/help/printers",
      "rom/help/craft",
      "rom/help/falling",
      "rom/help/excavate",
      "rom/help/colors",
      "rom/help/fs",
      "rom/help/wget",
      "rom/help/rednet",
      "rom/help/delete",
      "rom/help/unequip",
      "rom/help/peripheral",
      "rom/help/turn",
      "rom/help/settings",
      "rom/help/redstone",
      "rom/help/refuel",
      "rom/help/redirection",
      "rom/help/parallel",
      "rom/help/events",
      "rom/help/changelog",
      "rom/help/dance",
      "rom/help/commandsapi",
      "rom/help/edit",
      "rom/help/exit",
      "rom/help/copy",
      "rom/help/label",
      "rom/help/programming",
      "rom/help/workbench",
      "rom/help/drive",
      "rom/help/worm",
      "rom/help/credits",
      "rom/help/shutdown",
      "rom/help/disk",
      "rom/help/mkdir",
      "rom/help/helpapi",
      "rom/help/pastebin",
      "rom/help/gps",
      "rom/help/eject",
      "rom/help/hello",
      "rom/help/peripherals",
      "rom/help/coroutine",
      "rom/help/bit",
      "rom/help/monitor",
      "rom/help/earth",
      "rom/help/shellapi",
      "rom/help/id",
      "rom/help/apis",
      "rom/help/string",
      "rom/help/equip",
      "rom/help/paint",
      "rom/help/window",
      "rom/help/rename",
      "rom/help/paintutils",
      "rom/help/clear",
      "rom/help/shell",
      "rom/help/turtle",
      "rom/help/colours",
      "rom/help/exec",
      "rom/help/table",
      "rom/help/intro",
      "rom/help/monitors",
      "rom/help/fg",
      "rom/autorun/.ignoreme",
      "rom/programs/cd",
      "rom/programs/help",
      "rom/programs/fun/dj",
      "rom/programs/fun/adventure",
      "rom/programs/fun/advanced/levels/6",
      "rom/programs/fun/advanced/levels/12",
      "rom/programs/fun/advanced/levels/1",
      "rom/programs/fun/advanced/levels/7",
      "rom/programs/fun/advanced/levels/3",
      "rom/programs/fun/advanced/levels/2",
      "rom/programs/fun/advanced/levels/5",
      "rom/programs/fun/advanced/levels/9",
      "rom/programs/fun/advanced/levels/4",
      "rom/programs/fun/advanced/levels/10",
      "rom/programs/fun/advanced/levels/0",
      "rom/programs/fun/advanced/levels/8",
      "rom/programs/fun/advanced/levels/11",
      "rom/programs/fun/advanced/redirection",
      "rom/programs/fun/advanced/paint",
      "rom/programs/fun/worm",
      "rom/programs/fun/hello",
      "rom/programs/pocket/falling",
      "rom/programs/move",
      "rom/programs/time",
      "rom/programs/alias",
      "rom/programs/type",
      "rom/programs/http/wget",
      "rom/programs/http/pastebin",
      "rom/programs/lua",
      "rom/programs/reboot",
      "rom/programs/programs",
      "rom/programs/list",
      "rom/programs/set",
      "rom/programs/rednet/repeat",
      "rom/programs/rednet/chat",
      "rom/programs/delete",
      "rom/programs/redstone",
      "rom/programs/advanced/multishell",
      "rom/programs/advanced/bg",
      "rom/programs/advanced/fg",
      "rom/programs/edit",
      "rom/programs/exit",
      "rom/programs/copy",
      "rom/programs/label",
      "rom/programs/drive",
      "rom/programs/shutdown",
      "rom/programs/mkdir",
      "rom/programs/gps",
      "rom/programs/eject",
      "rom/programs/peripherals",
      "rom/programs/command/commands",
      "rom/programs/command/exec",
      "rom/programs/monitor",
      "rom/programs/id",
      "rom/programs/apis",
      "rom/programs/rename",
      "rom/programs/clear",
      "rom/programs/shell",
      "rom/programs/turtle/go",
      "rom/programs/turtle/tunnel",
      "rom/programs/turtle/craft",
      "rom/programs/turtle/excavate",
      "rom/programs/turtle/unequip",
      "rom/programs/turtle/turn",
      "rom/programs/turtle/refuel",
      "rom/programs/turtle/dance",
      "rom/programs/turtle/equip",
      "rom/startup",
      "rom/apis/help",
      "rom/apis/keys",
      "rom/apis/vector",
      "rom/apis/term",
      "rom/apis/io",
      "rom/apis/textutils",
      "rom/apis/colors",
      "rom/apis/rednet",
      "rom/apis/peripheral",
      "rom/apis/settings",
      "rom/apis/parallel",
      "rom/apis/disk",
      "rom/apis/gps",
      "rom/apis/command/commands",
      "rom/apis/window",
      "rom/apis/paintutils",
      "rom/apis/turtle/turtle",
      "rom/apis/colours",
      "loadall",
    },
    fileData = {
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /boot/load\
\009CATEGORY:    boot\
\009SET:         Boot II\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This script is ran after /boot/clinux.i\
\009\009and loads important libraries up\
\009\009and starts the shell at the end.\
]]--\
\
if _G['flag'] and _G['flag']['STATE_INIT'] then\
\009if not fs.exists(\"/sys/fs.l\") then\
\009\009cLinuxPrintError(\"/sys/fs.l not found...\")\
\009\009sleep(2)\
\009\009flag.STATE_DEAD = true\
\009elseif not fs.exists(\"/sys/perm.l\") then\
\009\009cLinuxPrintError(\"/sys/perm.l not found...\")\
\009\009sleep(2)\
\009\009flag.STATE_DEAD = true\
\009elseif not fs.exists(\"/sys/thread.l\") then\
\009\009cLinuxPrintError(\"/sys/thread.l not found...\")\
\009\009sleep(2)\
\009\009flag.STATE_DEAD = true\
\009elseif not fs.exists(\"/sys/sThread.l\") then\
\009\009cLinuxPrintError(\"/sys/sThread.l not found...\")\
\009\009sleep(2)\
\009\009flag.STATE_DEAD = true\
\009end\
\
\009print(\"Loading perm API\")\
\009local ok, err = loadAPI(\"/sys/perm.l\")\
\009if ok == false or _G.lib.perm == nil then\
\009\009cLinuxPrintError(\"[perm.l] \"..tostring(err))\
\009\009flag.STATE_DEAD = true\
\009\009sleep(1)\
\009\009return\
\009end\
\009sleep(0.5)\
\009print(\"Loading FS API\")\
\009local ok, err = loadAPI(\"/sys/fs.l\")\
\009if ok == false or _G.fs == nil then\
\009\009cLinuxPrintError(\"[fs.l] \"..tostring(err))\
\009\009flag.STATE_DEAD = true\
\009\009sleep(1)\
\009\009return\
\009end\
\009sleep(0.5)\
\009print(\"Loading thread API\")\
\009local ok, err = loadAPI(\"/sys/thread.l\")\
\009if ok == false or _G.thread == nil then\
\009\009cLinuxPrintError(\"[thread.l] \"..tostring(err))\
\009\009flag.STATE_DEAD = true\
\009\009sleep(1)\
\009\009return\
\009end\
\009print(\"Loading sThread API\")\
\009local ok, err = loadAPI(\"/sys/sThread.l\")\
\009if ok == false or _G.sThread == nil then\
\009\009cLinuxPrintError(\"[thread.l] \"..tostring(err))\
\009\009flag.STATE_DEAD = true\
\009\009sleep(1)\
\009\009return\
\009end\
\009sleep(0.5)\
\009for _, a in ipairs(fs.list(\"/lib/\")) do\
\009\009print(\"Loading \"..a)\
\009\009local ok, err = loadAPI(\"/lib/\"..a)\
\009\009if ok == false then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"[\"..a..\"] \"..tostring(err))\
\009\009\009term.setTextColor(c)\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.green)\
\009\009\009term.write(\"[OK]\")\
\009\009\009term.setTextColor(c)\
\009\009\009print(\" \"..a..\" loaded!\")\
\009\009\009sleep(0.5)\
\009\009end\
\009end\
\009print(\"Finished!\")\
\009sleep(0.5)\
\009if _G.lib.os then\
\009\009_G.lib.os['shutdown'] = os.shutdown\
\009\009_G.lib.os['reboot'] = os.reboot\
\009end\
\
\009--initiate shell-level-tasklist\
\009local tasks = {}\
\009tasks['list'] = {}\
\009tasks['last_uid'] = 0\
\009tasks['somethingInFG'] = false\
\
\009local xBox = {}\
\
\009for _, a in pairs(_G) do\
\009\009xBox[_] = a\
\009end\
\009--xBox._G = xBox\
\009--setmetatable(xBox, {__index = xBox.lib})\
\009--xBox._G = xBox\
\009local x, err = thread.new(\"/sys/shell.lua\", xBox, \"Shell\", tasks)\
\009if x == false then\
\009\009cLinuxPrintError(\"Shell\", err)\
\009\009sleep(2)\
\009end\
\009local running = true\
\009local evt = {}\
\009while running do\
\009\009local ok = thread.resumeAll(tasks, evt)\
\009\009evt = {os.pullEventRaw()}\
\009\009if ok == false then\
\009\009\009running = false\
\009\009end\
\009end\
\009flag.STATE_DEAD = true\
else\
\009term.clear(1,1)\
\009term.setCursorPos(1,1)\
\009printError(\"cLinux not initialized, boot cLinux.i\")\
end",
      "--[[\
            THIS PROGRAM FINISHES THE GRUB LOOP OFF\
            TO BOOT CraftOS\
\
\
            ...nothing special...\
]]",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /boot/clinux.i\
\009CATEGORY:    boot\
\009SET:         Boot I\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This script is ran after /startup and\
\009\009it sets flags manually, also loading\
\009\009some utils for posterior scripts.\
]]--\
\
\
\
print(\"Welcome to cLinux !\")\
sleep(2)\
\
\
\
--Modify the os.loadAPI and others.... NOTE: I think loadAPI is useless here, as I already did that in the right way in thread.l\
local bos = {}\
\
for k, v in pairs(_G.os) do\
\009bos[k] = v\
end\
\
local tAPIsLoading = {}\
function bos.loadAPI( _sPath )\
\009\009print(\"Loading \".._sPath)\
    local sName = fs.getName( _sPath )\
    if tAPIsLoading[sName] == true then\
        printError( \"API \"..sName..\" is already being loaded\" )\
        return false\
    end\
    tAPIsLoading[sName] = true\
\
    local tEnv = {}\
    setmetatable( tEnv, { __index = _G } )\
    local fnAPI, err = loadfile( _sPath, tEnv )\
    if fnAPI then\
        local ok, err = pcall( fnAPI )\
        if not ok then\
            printError( err )\
            tAPIsLoading[sName] = nil\
            return false\
        end\
    else\
        printError( err )\
        tAPIsLoading[sName] = nil\
        return false\
    end\
\
    local tAPI = {}\
    for k,v in pairs( tEnv ) do\
        if k ~= \"_ENV\" then\
            tAPI[k] =  v\
        end\
    end\
    tAPIsLoading[sName] = nil\
\009\009--Edited part\
    return true, _putLib(sName, tAPI), _put(sName, tAPI)\
end\
\
local oos = {}\
for k, v in pairs(_G.os) do\
    oos[k] = v\
end\
\
--There was an error with returning the right event, this should fix it\
function bos.pullEvent(_filtr)\
    if _filtr then\
        repeat\
            local evt = {oos.pullEvent()}\
        until evt[1] == _filtr\
        return unpack(evt)\
    else\
        return oos.pullEvent()\
    end\
end\
\
function bos.pullEventRaw(_filtr)\
    if _filtr then\
        repeat\
            local _, a, b, c = oos.pullEventRaw()\
        until _ == _filtr\
        return _, a, b, c\
    else\
        return oos.pullEventRaw()\
    end\
end\
\
\
--Load the API, in the cLinux way (use _putLib in the API, for example)\
function loadAPI(path)\
\009local ok, err = loadfile(path)\
\009if not ok then\
\009\009return false, err\
\009else\
\009\009local ok, err = ok()\
\009\009if ok == false then\
\009\009\009return false, err\
\009\009else\
\009\009\009return true\
\009\009end\
\009end\
end\
\
-- Put in _G\
function _put(a,b) _G[a]=b end\
\
\
\
local lib = {}\
function _putLib(a,b) _G['lib'][a]=b end\
\
_put('_put', _put)\
_put('lib', lib)\
_put('_putLib', _putLib)\
_putLib('os', bos)\
function _check(a)\
\009if _G[a] == nil then\
\009\009return false\
\009else\
\009\009return true\
\009end\
end\
_put('_check', _check)\
\
-- Put in _G.flag\
_put('flag', {})\
\
\
local ok, err = loadAPI(\"/sys/thread.l\")\
if not ok then\
\009printError(err)\
\009return\
end\
\
\
function _flag(a,b) _G.flag[a] = b end\
_put('_flag', _flag)\
_put('loadAPI', loadAPI)\
-- Get _G.flag[flag]\
function _getflag(flag) return flag[flag] end\
_put('_getflag', _getflag)\
-- Loadfile, securely\
_put('_REQUIRECACHE', {})\
local function require(file)\
\009local function go()\
\009\009loadfile(file)\
\009end\
\009local ok, ret = pcall(go)\
\009if ok then\
\009\009_REQUIRECACHE[#_REQUIRECACHE+1] = file\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
local function cLinuxPrintError(status, message)\
\009local c = term.getTextColor()\
\009term.setTextColor(colors.red)\
\009print(\"[\"..tostring(status)..\"] \"..tostring(message))\
\009term.setTextColor(c)\
end\
\
_put('cLinuxPrintError', cLinuxPrintError)\
_put('require', require)\
-- Set system flags\
--- Debug level, set to 0 by default, use /startup\
_flag('SYSDEBUG', 0)\
-- Starting the OS, can't be changed\
_flag('STATE_INIT', true)\
-- Ignore the current services.conf, for example to start the commandline\
_flag('text', false)\
\
\
\
_arg = {...}\
if #_arg > 0 then\
\009for _,arg in pairs(_arg) do\
\009\009if arg == \"sysdebug\" then\
\009\009    flag.SYSDEBUG = flag.SYSDEBUG + 1\
\009\009elseif arg == \"rescue\" then\
\009\009\009flag.RESCUE = true\
\009\009elseif arg == \"text\" then\
\009\009\009flag.text = true\
\009\009end\
\009end\
end\
-- Top Level Corroutine Override\
local syserror = printError\
_put('syserror', syserror)\
_G.printError = function()\
\009_G.printError = syserror\
\009_G['rednet'] = nil\
\009local evt = {}\
\009\009--initiate ground-environment\
\009\009local newenv = {}\
\009\009for k, v in pairs(_G) do\
\009\009\009newenv[k] = v\
\009\009end\
\009\009setmetatable(newenv, {})\
\009\009--initiate ground-tasklist\
\009\009local tasks = {}\
\009\009tasks['list'] = {}\
\009\009tasks['last_uid'] = 0\
\009\009tasks['somethingInFG'] = false\
\
\
\
\009\009print(\"Loading core\")\
\009\009sleep(0.5)\
\009\009local ok, err = thread.new(\"/boot/load\", newenv, \"Core\", tasks)\
\009\009if not ok then\
\009\009\009cLinuxPrintError(\"Core\", err)\
\009\009end\
\009\009print(\"Loading alive\")\
\009\009sleep(0.5)\
\009\009local ok, err = thread.new(\"/vit/alive\", newenv, \"Alive\", tasks, tasks)\
\009\009if not ok then\
\009\009\009cLinuxPrintError(\"Alive\", err)\
\009\009end\
\
\009\009sleep(0.5)\
\
\
\009\009local running = true\
\009\009while running do\
\009\009\009local ok = thread.resumeAll(tasks, evt)\
\009\009\009evt = {os.pullEventRaw()}\
\009\009\009if ok == false then\
\009\009\009\009running = false\
\009\009\009end\
\009\009end\
\009\009print(err)\
\009\009sleep(2)\
\009--end\
\009print(\"Looks like /vit/alive failed..\")\
\009sleep(1)\
\009os.reboot()\
\009-- NOTE: /boot/load is now in charge of all files to run. If that you know when is\
\009-- that branch going to die, please do _flag('STATUS_DEAD') to force a restart.\
end\
os.queueEvent(\"modem_message\", 0)",
      "-- Keep the TLCO alive\
-- Create a coroutine with alive, and execute the other.\
\
--catch the ground-tasklist\
\
local tasks = {}\
for k, v in pairs(startArgs) do\
\009tasks[k] = v\
end\
local function drawBlueScreen()\
\009if flag.STATE_CRASHED then\
\009\009term.setCursorPos(1,1)\
\009\009term.setBackgroundColor(colors.blue)\
\009\009term.setTextColor(colors.white)\
\009\009term.clear()\
\009\009local msg1 = \"Whoops, cLinux crashed!\"\
\009\009term.setCursorPos(26-#msg1/2, 2)\
\009\009term.write(msg1)\
\009\009local msg2 = flag.STATE_CRASHED\
\009\009local part1 = nil\
\009\009local part2 = nil\
\009\009if #msg2 > 51 then\
\009\009\009part1 = string.sub(msg2, 1, 51)\
\009\009\009part2 = string.sub(msg2, 52, #msg2)\
\009\009end\
\
\009\009if not part1 then\
\009\009\009term.setCursorPos(26-#msg2/2, 4)\
\009\009\009term.setTextColor(colors.red)\
\009\009\009term.write(msg2)\
\009\009else\
\009\009\009term.setCursorPos(26-#part1/2, 4)\
\009\009\009term.setTextColor(colors.red)\
\009\009\009term.write(part1)\
\009\009\009term.setCursorPos(26-#part2/2, 5)\
\009\009\009term.setTextColor(colors.red)\
\009\009\009term.write(part2)\
\009\009end\
\
\009\009local msg3 = \"Please report bugs in GitHub/my post.\"\
\009\009term.setCursorPos(26-#msg3/2, 15)\
\009\009term.setTextColor(colors.white)\
\009\009term.write(msg3)\
\009\009local msg4 = \"The computer tries to reboot now...\"\
\009\009term.setCursorPos(26-#msg4/2, 17)\
\009\009term.write(msg4)\
\009end\
end\
\
\
while true do\
\009local ok, err = thread.getStatus(\"Core\", tasks)\
\009if ok == \"dead\" or flag.STATE_DEAD or ok == nil then\
\009\009term.setTextColor(colors.red)\
\009\009print(\"/vit/alive : STATE_DEAD detected. Restarting...\")\
\009\009term.setCursorBlink(false)\
\009\009sleep(2)\
\009\009print(\"Trying to reboot\")\
\009\009os.reboot()\
\009elseif flag.STATE_CRASHED then\
\009\009drawBlueScreen()\
\009\009sleep(4)\
\009\009os.reboot()\
\009elseif flag.STATE_SHUTDOWN then\
\009\009term.setTextColor(colors.red)\
\009\009print(\"/vit/alive : Shutting down...\")\
\009\009term.setCursorBlink(false)\
\009\009sleep(2)\
\009\009print(\"Trying shutdown.\")\
\009\009os.shutdown()\
\009else\
\009\009sleep(0.1)\
\009end\
end",
      "name = edit\
\009type = raw\
\009\009url = https://raw.githubusercontent.com/Piorjade/cLinuxREPO/master/repo/edit\
\009\009filename = edit\
\009dependencies = none\
\009version = 1.0\
\009size = 17287\
end\
\
name = luaide\
\009type = raw\
\009\009url = http://pastebin.com/raw/vyAZc6tJ\
\009\009filename = luaide\
\009dependencies = none\
\009version = 1.0\
\009size = 61948\
end\
\
name = doorX\
\009type = raw\
\009\009url = http://pastebin.com/raw/Rnp97GRT\
\009\009filename = InstallDoorX\
\009dependencies = none\
\009cleanup = InstallDoorX uninstall\
\009version = 2.1\
\009size = 4210\
end\
\
name = updater\
\009type = raw\
\009\009url = http://pastebin.com/raw/NKEKjfpb\
\009\009filename = UpdateCLinux\
\009dependencies = none\
\009version = 1.0\
\009size = 4350\
end\
\
name = fseapi\
\009type = raw\
\009\009url = http://pastebin.com/raw/8JRrW0Va\
\009\009filename = fsEAPI\
\009dependencies = none\
\009version = 1.0\
\009size = 4350\
end\
\
name = fsexpose\
\009type = raw\
\009\009url = http://pastebin.com/raw/Wqp7RnVh\
\009\009filename = fsexpose\
\009dependencies = none\
\009version = 2.5\
\009size = 18195\
end",
      "name = packman\
\009type = raw\
\009\009url = https://raw.githubusercontent.com/lyqyd/cc-packman/master/packman\
\009\009filename = packman\
\009category = utility\
\009dependencies = none\
\009version = 0.3\
\009size = 17110\
end\
\
name = easy-shell\
\009type = pastebin\
\009\009url = wzWFmaav\
\009\009filename = easy-shell\
\009setup = easy-shell install\
\009cleanup = easy-shell remove\
\009category = shell\
\009dependencies = none\
\009version = 0.2\
\009size = 1626\
end",
      "clinux http://pastebin.com/raw/WfwDCSg5",
      "{\
  rednet = false,\
  [ \"/sys/cmdbak\" ] = \"core\",\
}",
      "os.loadAPI(\"/sys/rednet\")\
rednet.run()",
      "1.0\
bin/luaide",
      "1.0\
/bin/UpdateCLinux",
      "1.0\
bin/edit",
      "0.3\
/bin/packman\
/etc/api/package\
/etc/repolist\
etc/repositories/main\
etc/repositories/clinux\
/etc/repositories/clinux",
      "version = \"1.1\"\
----------------------------------------------------------\
--   ~\". _^_ \"~       --    KrapFile Version 1.1        --\
--   ~\" (____) \"~     --     Created by TehRockettek    --\
--   ~\"(______) \"~    --                                --\
--  \" (________) \"~   --    KrapFile is a simple file   --\
--  (____________) \"  --    managing program and is     --\
--  KRAP    SOFTWARE  --    a much more optimized       --\
-- \"Its like someone  --    version. This program will  --\
--  litteraly made    --    have much more features     --\
--  this whilst on    --    over time!                  --\
--  the toilet...  \"  --                                --\
----------------------------------------------------------\
\
-- I sometimes livestream to youtube!                            --\
-- https://www.youtube.com/channel/UC_WsSgl1UL1USK4K0RplcnQ/live --\
\
-- Older versions of craftOS dont support the characters used in\
-- KrapFile, if this is so just run -o after the program\
\
term.clear()\
term.setCursorPos(1,1)\
\
if shell then\
    pgrm = \"/\" .. shell.getRunningProgram()\
else\
\009pgrm = \"/KrapFile.lua\"\
    printError(\"Hmm, cant find shell api.\")\
    os.pullEvent(\"key\")\
end\
\
args = { ... }\
\
if http then\
\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009if not pbl then\
\009\009printError(\"Could not connect to pastebin\")\
\009else\
\009\009latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
\009\009latestver = string.gsub(latestver,\"\\\"\",\"\")\
\009end\
end\
\
term.clear()\
terminal = term.current()\
resolution = {term.getSize()}\
dialoguevisible = false\
print(\"Debug use only\")\
if _CC_VERSION then\
    supportspecialchars = (tonumber(_CC_VERSION) >= 1.76)\
\009print(\"cc-ver: \" .. _CC_VERSION)\
end\
if _HOST then\
    supportspecialchars = (tonumber(string.sub(string.gsub(_HOST,\"ComputerCraft \",\"\"),1,string.find(string.gsub(_HOST,\"ComputerCraft \",\"\"),\" \"))) >= 1.76)\
\009print(\"host: \" .. _HOST)\
end\
if not supportspecialchars or args[1] == \"-o\" then\
    back = \"<\"\
    up = \"^\"\
\009print(\"ssc: false\")\
else\
    back = \"\017\"\
    up = \"\030\"\
\009print(\"ssc: true\")\
end\
print(\"kf-ver: \" .. version)\
print(\"pb-ver: \" .. latestver)\
print(\"rpgrm: \" .. pgrm)\
sleep(1)\
local function minBytes(bytes)\
    if bytes > 1000000 then\
        return string.sub(bytes/1000000,1,string.len(math.ceil(bytes/1000000))+2) .. \"M\"\
    elseif bytes > 1000 then\
        return string.sub(bytes/1000,1,string.len(math.ceil(bytes/1000))+2) .. \"K\"\
    else\
        return bytes .. \"B\"\
    end\
end\
\
if string.find(pgrm,\"pastebin\") then -- Detect if using pastebin run (show installer)\
\009term.clear()\
\009paintutils.drawFilledBox(1,1,resolution[1],resolution[2],colours.cyan)\
\009local pastebin = http.get(\"http://www.pastebin.com/raw/wscpHypE\")\
\009filesize = minBytes(string.len(pastebin.readAll()))\
\009term.setCursorPos(1,resolution[2])\
\009term.write(\"File size: \" ..\009filesize)\
\009term.setCursorPos((resolution[1]-9)/2,resolution[2]/2)\
\009term.write(\"Download!\")\
\009os.pullEvent(\"mouse_click\")\
\009term.clear()\
    paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
    paintutils.drawFilledBox(1,4,resolution[1],resolution[2],colours.white)\
\009term.setCursorPos(2,2)\
    term.setBackgroundColour(colours.cyan)\
    term.setTextColour(colours.white)\
    textutils.slowPrint(\"KrapFile installer\")\
    term.setTextColour(colours.cyan)\
    term.setBackgroundColour(colours.white)\
    term.setCursorPos(1,5)\
    term.write(\" Loading...\")\
    sleep(2)\
    local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
    if not pbl then\
        printError(\" Could not connect to pastebin!\")\
        print(\" Error during update!\\n Computer will now reboot...\")\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        os.reboot()\
    end\
    latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
    latestver = string.gsub(latestver,\"\\\"\",\"\")\
    pbl.close()\
    term.setCursorPos(1,5)\
    print(\" Latest version: \" .. latestver .. \"\\n Download? (Y/N)\")\
    term.setCursorPos(2,10)\
    local _,id = os.pullEvent(\"key\")\
    if id == 21 then\
        print(\"\\n Downloading...\")\
        term.setCursorPos(1,12)\
        term.write(\" Connecting to pastebin...\")\
        local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
        if pbl then\
            print(\" Success\")\
        else\
            printError(\" Failed\")\
            print(\" Error during update!\\n Computer will reboot...\")\
            textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
            os.reboot()\
        end\
        print(\" Saving to file...\")\
        if fs.exists(\"KrapFile\") then fs.delete(\"/KrapFile\") end\
        krapfile = fs.open(\"/KrapFile\",\"w\")\
        krapfile.write(pbl.readAll())\
        print(\" Finished! Downloaded \" .. latestver .. \"\\n\\n Computer will reboot...\")\
        term.setCursorPos(2,resolution[2])\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        os.reboot()\
    else\
        print(\"Returing to Shell...\")\
        term.setCursorPos(2,resolution[2])\
        textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
        term.clear()\
\009\009textutils.setTextColour(colours.white)\
\009\009textutils.setBackgroundColour(colours.black)\
        term.setCursorPos(1,1)\
        shell.run(\"shell\")\
    end\
end\
\
if resolution[1] < 26 or resolution[2] < 5 then\
\009printError(\"Sorry! Your computer must be atleast 26x5 to run this! (\" .. resolution[1] .. \"x\" .. resolution[2] .. \")\")\
\009return\
elseif not colors then\
\009printError(\"Sorry! Your computer doesn't seem to support colour. Monochrome support for KrapFile will be released shortly\")\
\009return\
end\
\
paintutils.drawFilledBox(1,1,resolution[1],resolution[2],colours.cyan)\
term.setCursorPos((resolution[1]-string.len(\"KrapFile\"))/2,(resolution[2]/5)*2)\
term.write(\"KrapFile\")\
term.setCursorPos(1,resolution[2])\
term.write(version)\
term.setCursorPos(resolution[1]-string.len(\"By TehRockettek\")+1,resolution[2])\
\
term.write(\"By TehRockettek\")\
local comments = {\"To continue, enter your SS Number:\",\"Piorjade liking pie is a conspiracy\",\"Enter your credit card details\",\"Free one-time payment of Â£499\",\"Now with more loading time!\",\"May include nuts\",\"Attempt to index nil\",\"Now in 1080p!\",\"I got molested by a toaster\",\"I am bender, insert girder\",\"May include bugs\",\"This litteraly took 12 hours to make\",\"Im not joking\",\"You pirated free software!\",\"Child Lock is enabled\",\"Have you tried a gun? I have\",\"Screw switchcraft,i want my plot back\",\"Sample comment\",\"Wow, thats so racist\",\"file.flushDownToilet()\",\"I cunt speel properply\",\"What's the wecommended amount of dedotated wam\",\"Subscribe to my YT: Teh Rockettek\",\"Try doing 5x26, It works!\",\"If stuff is showing as ?, run with -o\",\"I have a fetish for keemstar's beard\",\"I play pokemon go\",\"Redirection is a good game\",\"Dan200, more like err... dan smelly hundred\",\"*Air horns*\",\"~You hear the windows xp startup noise~\"}\
local fits = {}\
for i=1,#comments,1 do\
    if #comments[i] <= resolution[1] then\
        table.insert(fits,comments[i])\
    end\
end\
if resolution[2] < 10 then\
\009fits = {\"This is small!\"}\
end\
local num = math.random(1,#fits)\
term.setCursorPos((resolution[1]-string.len(fits[num]))/2,(resolution[2]/5)*4)\
term.write(fits[num])\
\
sleep(2)\
term.clear()\
\
local windows = {}\
windows.HUD = window.create(terminal,1,1,resolution[1],3)\
windows.FILES = window.create(terminal,1,4,resolution[1]-1,resolution[2]-4)\
windows.SCROLLBAR = window.create(terminal,resolution[1],4,resolution[1],resolution[2]-4)\
windows.BOTTOM = window.create(terminal,1,resolution[2],resolution[1],1)\
windows.EXTRA = window.create(terminal,1,1,1,1,false)\
\
path = \"/\"\
offset = 0\
\
local function cut(text,length)\
    if string.len(text) > length then\
        return string.sub(text,1,length)\
    else\
        return text\
    end\
end\
\
local function getSize(path)\
    local size = fs.getSize(path)\
    if fs.isDir(path) then\
        local l = fs.list(path)\
        for i = 1, #l do\
            size = size + getSize(fs.combine(path, l[i]))\
        end\
    end\
    return size\
end\
\
local function getName(path)\
    num = -1\
    while not string.find(path,\"/\",num) do\
        num = num - 1\
    end\
    return string.sub(path,string.find(path,\"/\",num)+1,#path)\
end\
\
local function loadHUD()\
    term.redirect(windows.HUD)\
    paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
    term.setBackgroundColour(colours.cyan)\
    if path == \"\" or not path then path = \"/\" end\
    term.setTextColour(colours.white)\
    term.setCursorPos(2,2)\
    term.write(back)\
    if offset < 0 then offset = 0 end\
    term.setTextColour(colours.white)\
    term.setCursorPos(5,2)\
    term.write(up)\
    term.setCursorPos(8,2)\
    term.setTextColour(colours.white)\
    term.write(cut(path,resolution[1]-8))\
    term.redirect(terminal)\
\
end\
\
local function loadDETAILS(path)\
    fileList = fs.list(path)\
    folderSize = 0\
    filesinfolder = 0\
    foldersinfolder = 0\
    for i=1,#fileList,1 do\
        local filePath = \"/\" .. fs.combine(path,fileList[i])\
        if fs.isDir(filePath) then foldersinfolder = foldersinfolder + 1 else filesinfolder = filesinfolder + 1 end\
        folderSize = folderSize + getSize(filePath)\
    end\
\
end\
\
\
local function loadFILES()\
    loadDETAILS(path)\
    term.redirect(windows.FILES)\
    paintutils.drawFilledBox(1,1,resolution[1]-1,resolution[2]-4,colours.white)\
    fileList = fs.list(path)\
    containerWidth,containerHeight = term.getSize()\
    if #fileList-offset == containerHeight then\
        for i=1,containerHeight,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i+offset])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
            elseif (\"/\" .. fileList[i+offset] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
\009\009\009end\
            term.write(cut(fileList[i+offset],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i+offset],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    elseif #fileList < containerHeight then\
        for i=1,#fileList,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
\009\009\009elseif (\"/\" .. fileList[i] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
            end\
            term.write(cut(fileList[i],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    else\
        for i=1,containerHeight,1 do\
            filePath = \"/\" .. fs.combine(path,fileList[i+offset])\
            if fs.isDir(filePath) then\
                fileSize = \"(\"..minBytes(getSize(filePath))..\")\"\
            else\
                fileSize = minBytes(fs.getSize(filePath))\
            end\
            if filePath == pgrm then\
                paintutils.drawFilledBox(1,i,1,i,colours.green)\
            elseif fs.isDir(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.yellow)\
            elseif fs.isReadOnly(filePath) then\
                paintutils.drawFilledBox(1,i,1,i,colours.red)\
            else\
                paintutils.drawFilledBox(1,i,1,i,colours.blue)\
            end\
            term.setCursorPos(3,i)\
            term.setBackgroundColour(colours.white)\
            if string.sub(fileList[i],1,1) == \".\" then\
                term.setTextColour(colours.grey)\
            elseif (\"/\" .. fileList[i+offset] == pgrm) and (tonumber(version) < tonumber(latestver)) then\
\009\009\009\009term.setTextColour(colours.green)\
            else\
                term.setTextColour(colours.black)\
            end\
            term.write(cut(fileList[i+offset],containerWidth-10) .. string.rep(\" \",containerWidth - (string.len(cut(fileList[i+offset],containerWidth-10))+2+string.len(fileSize))) .. fileSize)\
        end\
    end\
    term.redirect(terminal)\
\
end\
\
local function loadBAR()\
    term.redirect(windows.SCROLLBAR)\
    local _,containerHeightb = term.getSize()\
    if #fileList <= containerHeight then\
        paintutils.drawFilledBox(1,1,1,containerHeightb,colours.grey)\
    else\
        paintutils.drawFilledBox(1,1,1,containerHeightb,colours.lightGrey)\
    end\
    barryscott = (containerHeightb/100) * ((offset/(#fileList - containerHeight))*100)\
    if barryscott < 1 then\
        barryscott = 1\
    end\
\009if offset == 0 then\
\009\009barryscott = 1\
\009end\
    paintutils.drawFilledBox(1,barryscott,1,barryscott,colours.grey)\
    term.redirect(terminal)\
\
end\
\
local function loadBOTTOM()\
    if not dialoguevisible then\
        term.redirect(windows.BOTTOM)\
        term.setBackgroundColour(colours.lightGrey)\
        term.setTextColour(colours.grey)\
        term.clearLine()\
        term.setCursorPos(1,1)\
        local info = filesinfolder .. \" files \" .. foldersinfolder .. \" folders\"\
        local posstats = offset .. \"/\" .. #fileList\
        bottombar = info .. string.rep(\" \",resolution[1]-string.len(info)-string.len(posstats)) .. posstats\
        term.write(bottombar)\
        term.redirect(terminal)\
    end\
end\
\
local function loadALL()\
    dialoguevisible = false\
    loadHUD()\
    loadFILES()\
    loadBAR()\
    loadBOTTOM()\
end\
\
local function loadDIALOGUE(text)\
    term.redirect(windows.BOTTOM)\
    term.setBackgroundColour(colours.lightGrey)\
    term.setTextColour(colours.grey)\
    term.clearLine()\
    term.setCursorPos(1,1)\
    term.write(text)\
    term.redirect(terminal)\
end\
-- INIT\
\
loadALL()\
\
-- Hint: Pretty much screwing arround with anything below will pretty much completely break the gui part of it ;)\
--       But to be honest, you shouldnt be screwing arround with the entire program at all...\
\
-- key,id,false\
-- key_up,id\
-- mouse_click,left(1)/right(2),X,Y\
-- mouse_scroll,down(-1)/up(1),X,Y\
\
os.pullEvent = os.pullEventRaw -- Just so i can say thanks for using it ;)\
while true do\
\
    if not fs.exists(path) then\
        path = \"/\"\
    end\
    local a,b,c,d = os.pullEvent()\
    if a == \"mouse_up\" then\
        if b == 1 then -- left\
            if c < 4 and d < 4 then\
                if path ~= \"/\" then\
                    path = \"/\" .. fs.combine(path,\"..\")\
                    offset = 0\
                    loadALL()\
                end\
            elseif c > 3 and c < 7 and d < 4 then\
                if offset > 0 then\
                    offset = 0\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBAR()\
                    loadFILES()\
                    loadBOTTOM()\
                end\
            elseif dialoguevisible and d == resolution[2] then\
                if c >= 1 and c <= 7 then\
                    finished = false\
                    while finished == false do\
                        if selectedfileDir == pgrm then\
                            term.clear()\
                            paintutils.drawFilledBox(1,1,resolution[1],3,colours.cyan)\
                            paintutils.drawFilledBox(1,4,resolution[1],resolution[2],colours.white)\
                            term.redirect(terminal)\
                            term.setCursorPos(2,2)\
                            term.setBackgroundColour(colours.cyan)\
                            term.setTextColour(colours.white)\
                            textutils.slowPrint(\"KrapFile updater\")\
                            term.setTextColour(colours.cyan)\
                            term.setBackgroundColour(colours.white)\
                            term.setCursorPos(1,5)\
                            term.write(\" Loading...\")\
    \009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009\009\009\009\009\009\009if not pbl then\
\009\009\009\009\009\009\009\009printError(\" Could not connect to pastebin!\")\
\009\009\009\009\009\009\009\009print(\" Error during update!\\n Computer will now reboot...\")\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009latestver = string.gsub(pbl.readLine(),\"version = \",\"\")\
\009\009\009\009\009\009\009latestver = string.gsub(latestver,\"\\\"\",\"\")\
\009\009\009\009\009\009\009pbl.close()\
\009\009\009\009\009\009\009term.setCursorPos(1,5)\
\009\009\009\009\009\009\009print(\" My version: \" .. version)\
\009\009\009\009\009\009\009print(\" New version: \" .. latestver .. \"\\n Update? (Y/N)\")\
\009\009\009\009\009\009\009term.setCursorPos(2,10)\
\009\009\009\009\009\009\009_,id = os.pullEvent(\"key\")\
\009\009\009\009\009\009\009if id == 21 then\
\009\009\009\009\009\009\009\009if version == latestver then\
\009\009\009\009\009\009\009\009\009print(\"\\n Redownloading...\")\
\009\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009\009print(\"\\n Downloading...\")\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009sleep(3)\
                            \009term.setCursorPos(1,12)\
\009\009\009\009\009\009\009\009term.write(\" Connecting to pastebin...\")\
\009\009\009\009\009\009\009\009local pbl = http.get(\"http://pastebin.com/raw/wscpHypE\")\
\009\009\009\009\009\009\009\009if pbl then\
\009\009\009\009\009\009\009\009\009print(\" Success\")\
\009\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009\009printError(\" Failed\")\
\009\009\009\009\009\009\009\009\009print(\" Error during update!\\n Computer will reboot...\")\
\009\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009print(\" Saving to file...\")\
                            \009krapfile = fs.open(pgrm,\"w\")\
\009\009\009\009\009\009\009\009krapfile.write(pbl.readAll())\
\009\009\009\009\009\009\009\009print(\" Finished!\\n \" .. version .. \" => \" .. latestver .. \"\\n\\n Computer will reboot...\")\
                            \009term.setCursorPos(2,resolution[2])\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
\009\009\009\009\009\009\009\009os.reboot()\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009print(\"Returing to KrapFile...\")\
\009\009\009\009\009\009\009\009term.setCursorPos(2,resolution[2])\
\009\009\009\009\009\009\009\009textutils.slowPrint(string.rep(\"*\",resolution[1]-2))\
                            end\
\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009editname = \"\"\
                        else\
\009\009\009\009\009\009\009loadDIALOGUE(\"Rename to: \")\
\009\009\009\009\009\009\009term.redirect(windows.BOTTOM)\
\009\009\009\009\009\009\009term.setCursorPos(12,1)\
\009\009\009\009\009\009\009editname = io.read()\
\009\009\009\009\009\009\009if fs.isReadOnly(selectedfileDir) then\
\009\009\009\009\009\009\009\009loadDIALOGUE(\"File is read-only!\")\
\009\009\009\009\009\009\009\009editname = \"\"\
\009\009\009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009elseif not fs.exists(fs.combine(selectedfileDir,\"..\")..\"/\"..editname) or editname == \"\" then\
\009\009\009\009\009\009\009\009finished = true\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009loadDIALOGUE(\"File already exists!\")\
\009\009\009\009\009\009\009\009sleep(2)\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        if fs.move(selectedfileDir,fs.combine(selectedfileDir,\"..\")..\"/\"..editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 8 and c <= 14 then\
                    finished = false\
                    while finished == false do\
                        loadDIALOGUE(\"Copy to: \")\
                        term.redirect(windows.BOTTOM)\
                        term.setCursorPos(10,1)\
                        editname = io.read()\
                        if fs.isReadOnly(editname) then\
                            loadDIALOGUE(\"Directory is read-only!\")\
                            sleep(2)\
                        elseif not fs.exists(editname) or editname == \"\" then\
                            finished = true\
                        else\
                            loadDIALOGUE(\"File already exists!\")\
                            sleep(2)\
                        end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        fs.copy(selectedfileDir,editname)\
                        if not fs.exists(editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 15 and c <= 17 then\
                    finished = false\
                    while finished == false do\
                        loadDIALOGUE(\"Move to: \")\
                        term.redirect(windows.BOTTOM)\
                        term.setCursorPos(12,1)\
                        editname = io.read()\
                        if fs.isReadOnly(selectedfileDir) then\
                            loadDIALOGUE(\"File is read-only!\")\
                            editname = \"\"\
                            sleep(2)\
                            finished = true\
                        elseif fs.isReadOnly(editname) then\
                            loadDIALOGUE(\"Directory is read-only!\")\
                            sleep(2)\
                        elseif not fs.exists(editname) or editname == \"\" then\
                            finished = true\
                        else\
                            loadDIALOGUE(\"File already exists!\")\
                            sleep(2)\
                        end\
                    end\
                    if editname ~= \"\" then\
                        loadDIALOGUE(\"Working...\")\
                        if fs.move(selectedfileDir,editname) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    loadALL()\
                elseif c >= 18 and c <= 26 then\
                    if selectedfileDir == pgrm then\
                        loadDIALOGUE(\"Nope...\")\
                        sleep(2)\
                        finished = true\
                        key = 1\
                    end\
                    finished = false\
                    loadDIALOGUE(\"Are you sure? (Y/N)\")\
                    if fs.isReadOnly(selectedfileDir) then\
                        finished = true\
                        loadDIALOGUE(\"File is read-only!\")\
                        sleep(2)\
                    end\
                    while finished == false do\
                        _,id = os.pullEvent(\"key\")\
                        if id then\
                            finished = true\
                        end\
                    end\
                    if id == 21 and not fs.isReadOnly(selectedfileDir) then\
                        loadDIALOGUE(\"Working...\")\
                        fs.delete(selectedfileDir)\
                        if fs.exists(selectedfileDir) then\
                            loadDIALOGUE(\"An error occured!\")\
                            sleep(5)\
                        end\
                    end\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBOTTOM()\
                    loadFILES()\
                end\
            elseif c < resolution[1] - 1 and d > 3 and d < resolution[2] then\
                if fileList[d - 3 + offset] then\
                    selectedfileDir = \"/\" .. fs.combine(path,fileList[d - 3 + offset])\
                    if fs.isDir(selectedfileDir) then\
                        path = selectedfileDir\
                        offset = 0\
                        loadALL()\
                    elseif selectedfileDir ~= selectedfileDir then\
                        dialoguevisible = false\
                        windows.FILES.redraw()\
                        loadBOTTOM()\
                    end\
                elseif dialoguevisible then\
                    dialoguevisible = false\
                    windows.FILES.redraw()\
                    loadBOTTOM()\
                end\
            end\
        elseif b == 2 then -- right\
            if c < resolution[1] - 1 and d > 3 and d < resolution[2] then\
                if fileList[d - 3 + offset] then\
                    windows.FILES.redraw()\
                    term.setBackgroundColour(colours.white)\
                    term.setCursorPos(3,d)\
                    term.setTextColour(colours.blue)\
                    term.write(fileList[d-3+offset])\
                    selectedfileDir = \"/\" .. fs.combine(path,fileList[d - 3 + offset])\
                    dialoguevisible = true\
                    local filepercentage = string.sub(tostring((getSize(selectedfileDir)/getSize(\"/\"))*100),1,string.len(math.ceil((getSize(selectedfileDir)/getSize(\"/\"))*100))+2)\
                    if selectedfileDir == pgrm then\
                        loadDIALOGUE(\"Update  Copy  Move  Delete\".. string.rep(\" \",resolution[1]-27-#filepercentage) .. filepercentage .. \"%\")\
                    else\
                        loadDIALOGUE(\"Rename  Copy  Move  Delete\".. string.rep(\" \",resolution[1]-27-#filepercentage) .. filepercentage .. \"%\")\
                    end\
                end\
            end\
        end\
    elseif a == \"mouse_scroll\" then\
        if b == -1 then -- down\
            if offset + containerHeight < #fileList then\
                offset = offset + 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        elseif b == 1 then -- up\
            if offset > 0 then\
                offset = offset - 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        end\
    elseif a == \"key\" then\
        if b == 208 then -- down\
            if offset + containerHeight < #fileList then\
                offset = offset + 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        elseif b == 200 then -- up\
            if offset > 0 then\
                offset = offset - 1\
                loadBAR()\
                loadFILES()\
                loadBOTTOM()\
                dialoguevisible = false\
            end\
        end\
    elseif a == \"terminate\" then\
        term.setCursorPos(1,1)\
        term.setTextColour(colours.white)\
        term.setBackgroundColour(colours.black)\
        term.clear()\
        print(\"Thank you for using KrapFile!\\n Please go onto the forums to post any bugs or issues that occured.\\nAnd thank you for supporting us!\")\
        return\
    end\
    loadBOTTOM()\
end",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/cd\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION: \
\009\009This program lists changes the current directory to\
\009\009the specified path.\
]]--\
\
local tArgs = {...}\
\
if #tArgs < 1 or #tArgs > 1 or tArgs[1] == \".\" then\
\009print(\"Usage:\")\
\009print(\"\009\009cd <path>\")\
else\
\009if tArgs[1] ~= \"..\" then\
\009\009local ok = shell.setDir(tArgs[1])\
\009\009if ok == false then\
\009\009\009printError(\"Not a directory.\")\
\009\009end\
\009elseif tArgs[1] == \"..\" then\
\009\009local p = shell.dir()\
\009\009p = string.reverse(p)\
\009\009local i, j = string.find(p, \"/\")\
\009\009if i == 1 then\
\009\009\009i, j = string.find(string.sub(p, j+1), \"/\")\
\009\009end\
\009\009if i then\
\009\009\009p = string.sub(p, i+1, #p)\
\009\009end\
\009\009p = string.reverse(p)\
\009\009local ok = shell.setDir(p)\
\009\009if ok == false then\
\009\009\009printError(\"Not a directory.\")\
\009\009end\
\009end\
end",
      "\
--  \
--  Lua IDE\
--  Made by GravityScore\
--  \
\
\
--  -------- Variables\
\
-- Version\
local version = \"1.0\"\
local args = {...}\
\
-- Editing\
local w, h = term.getSize()\
local tabWidth = 2\
\
local autosaveInterval = 20\
local allowEditorEvent = true\
local keyboardShortcutTimeout = 0.4\
\
-- Clipboard\
local clipboard = nil\
\
-- Theme\
local theme = {}\
\
-- Language\
local languages = {}\
local curLanguage = {}\
\
-- Events\
local event_distract = \"luaide_distractionEvent\"\
\
-- Locations\
local updateURL = \"https://raw.github.com/GravityScore/LuaIDE/master/luaide.lua\"\
local ideLocation = \"/\" .. shell.getRunningProgram()\
local themeLocation = \"/.LuaIDE-Theme\"\
\
local function isAdvanced() return term.isColor and term.isColor() end\
\
\
--  -------- Utilities\
\
local function modRead(properties)\
\009local w, h = term.getSize()\
\009local defaults = {replaceChar = nil, history = nil, visibleLength = nil, textLength = nil, \
\009\009liveUpdates = nil, exitOnKey = nil}\
\009if not properties then properties = {} end\
\009for k, v in pairs(defaults) do if not properties[k] then properties[k] = v end end\
\009if properties.replaceChar then properties.replaceChar = properties.replaceChar:sub(1, 1) end\
\009if not properties.visibleLength then properties.visibleLength = w end\
\
\009local sx, sy = term.getCursorPos()\
\009local line = \"\"\
\009local pos = 0\
\009local historyPos = nil\
\
\009local function redraw(repl)\
\009\009local scroll = 0\
\009\009if properties.visibleLength and sx + pos > properties.visibleLength + 1 then \
\009\009\009scroll = (sx + pos) - (properties.visibleLength + 1)\
\009\009end\
\
\009\009term.setCursorPos(sx, sy)\
\009\009local a = repl or properties.replaceChar\
\009\009if a then term.write(string.rep(a, line:len() - scroll))\
\009\009else term.write(line:sub(scroll + 1, -1)) end\
\009\009term.setCursorPos(sx + pos - scroll, sy)\
\009end\
\
\009local function sendLiveUpdates(event, ...)\
\009\009if type(properties.liveUpdates) == \"function\" then\
\009\009\009local ox, oy = term.getCursorPos()\
\009\009\009local a, data = properties.liveUpdates(line, event, ...)\
\009\009\009if a == true and data == nil then\
\009\009\009\009term.setCursorBlink(false)\
\009\009\009\009return line\
\009\009\009elseif a == true and data ~= nil then\
\009\009\009\009term.setCursorBlink(false)\
\009\009\009\009return data\
\009\009\009end\
\009\009\009term.setCursorPos(ox, oy)\
\009\009end\
\009end\
\
\009term.setCursorBlink(true)\
\009while true do\
\009\009local e, but, x, y, p4, p5 = os.pullEvent()\
\
\009\009if e == \"char\" then\
\009\009\009local s = false\
\009\009\009if properties.textLength and line:len() < properties.textLength then s = true\
\009\009\009elseif not properties.textLength then s = true end\
\
\009\009\009local canType = true\
\009\009\009if not properties.grantPrint and properties.refusePrint then\
\009\009\009\009local canTypeKeys = {}\
\009\009\009\009if type(properties.refusePrint) == \"table\" then\
\009\009\009\009\009for _, v in pairs(properties.refusePrint) do\
\009\009\009\009\009\009table.insert(canTypeKeys, tostring(v):sub(1, 1))\
\009\009\009\009\009end\
\009\009\009\009elseif type(properties.refusePrint) == \"string\" then\
\009\009\009\009\009for char in properties.refusePrint:gmatch(\".\") do\
\009\009\009\009\009\009table.insert(canTypeKeys, char)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009for _, v in pairs(canTypeKeys) do if but == v then canType = false end end\
\009\009\009elseif properties.grantPrint then\
\009\009\009\009canType = false\
\009\009\009\009local canTypeKeys = {}\
\009\009\009\009if type(properties.grantPrint) == \"table\" then\
\009\009\009\009\009for _, v in pairs(properties.grantPrint) do\
\009\009\009\009\009\009table.insert(canTypeKeys, tostring(v):sub(1, 1))\
\009\009\009\009\009end\
\009\009\009\009elseif type(properties.grantPrint) == \"string\" then\
\009\009\009\009\009for char in properties.grantPrint:gmatch(\".\") do\
\009\009\009\009\009\009table.insert(canTypeKeys, char)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009for _, v in pairs(canTypeKeys) do if but == v then canType = true end end\
\009\009\009end\
\
\009\009\009if s and canType then\
\009\009\009\009line = line:sub(1, pos) .. but .. line:sub(pos + 1, -1)\
\009\009\009\009pos = pos + 1\
\009\009\009\009redraw()\
\009\009\009end\
\009\009elseif e == \"key\" then\
\009\009\009if but == keys.enter then break\
\009\009\009elseif but == keys.left then if pos > 0 then pos = pos - 1 redraw() end\
\009\009\009elseif but == keys.right then if pos < line:len() then pos = pos + 1 redraw() end\
\009\009\009elseif (but == keys.up or but == keys.down) and properties.history then\
\009\009\009\009redraw(\" \")\
\009\009\009\009if but == keys.up then\
\009\009\009\009\009if historyPos == nil and #properties.history > 0 then \
\009\009\009\009\009\009historyPos = #properties.history\
\009\009\009\009\009elseif historyPos > 1 then \
\009\009\009\009\009\009historyPos = historyPos - 1\
\009\009\009\009\009end\
\009\009\009\009elseif but == keys.down then\
\009\009\009\009\009if historyPos == #properties.history then historyPos = nil\
\009\009\009\009\009elseif historyPos ~= nil then historyPos = historyPos + 1 end\
\009\009\009\009end\
\
\009\009\009\009if properties.history and historyPos then\
\009\009\009\009\009line = properties.history[historyPos]\
\009\009\009\009\009pos = line:len()\
\009\009\009\009else\
\009\009\009\009\009line = \"\"\
\009\009\009\009\009pos = 0\
\009\009\009\009end\
\
\009\009\009\009redraw()\
\009\009\009\009local a = sendLiveUpdates(\"history\")\
\009\009\009\009if a then return a end\
\009\009\009elseif but == keys.backspace and pos > 0 then\
\009\009\009\009redraw(\" \")\
\009\009\009\009line = line:sub(1, pos - 1) .. line:sub(pos + 1, -1)\
\009\009\009\009pos = pos - 1\
\009\009\009\009redraw()\
\009\009\009\009local a = sendLiveUpdates(\"delete\")\
\009\009\009\009if a then return a end\
\009\009\009elseif but == keys.home then\
\009\009\009\009pos = 0\
\009\009\009\009redraw()\
\009\009\009elseif but == keys.delete and pos < line:len() then\
\009\009\009\009redraw(\" \")\
\009\009\009\009line = line:sub(1, pos) .. line:sub(pos + 2, -1)\
\009\009\009\009redraw()\
\009\009\009\009local a = sendLiveUpdates(\"delete\")\
\009\009\009\009if a then return a end\
\009\009\009elseif but == keys[\"end\"] then\
\009\009\009\009pos = line:len()\
\009\009\009\009redraw()\
\009\009\009elseif properties.exitOnKey then \
\009\009\009\009if but == properties.exitOnKey or (properties.exitOnKey == \"control\" and \
\009\009\009\009\009\009(but == 29 or but == 157)) then \
\009\009\009\009\009term.setCursorBlink(false)\
\009\009\009\009\009return nil\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009local a = sendLiveUpdates(e, but, x, y, p4, p5)\
\009\009if a then return a end\
\009end\
\
\009term.setCursorBlink(false)\
\009if line ~= nil then line = line:gsub(\"^%s*(.-)%s*$\", \"%1\") end\
\009return line\
end\
\
\
--  -------- Themes\
\
local defaultTheme = {\
\009background = \"gray\",\
\009backgroundHighlight = \"lightGray\",\
\009prompt = \"cyan\",\
\009promptHighlight = \"lightBlue\",\
\009err = \"red\",\
\009errHighlight = \"pink\",\
\
\009editorBackground = \"gray\",\
\009editorLineHightlight = \"lightBlue\",\
\009editorLineNumbers = \"gray\",\
\009editorLineNumbersHighlight = \"lightGray\",\
\009editorError = \"pink\",\
\009editorErrorHighlight = \"red\",\
\
\009textColor = \"white\",\
\009conditional = \"yellow\",\
\009constant = \"orange\",\
\009[\"function\"] = \"magenta\",\
\009string = \"red\",\
\009comment = \"lime\"\
}\
\
local normalTheme = {\
\009background = \"black\",\
\009backgroundHighlight = \"black\",\
\009prompt = \"black\",\
\009promptHighlight = \"black\",\
\009err = \"black\",\
\009errHighlight = \"black\",\
\
\009editorBackground = \"black\",\
\009editorLineHightlight = \"black\",\
\009editorLineNumbers = \"black\",\
\009editorLineNumbersHighlight = \"white\",\
\009editorError = \"black\",\
\009editorErrorHighlight = \"black\",\
\
\009textColor = \"white\",\
\009conditional = \"white\",\
\009constant = \"white\",\
\009[\"function\"] = \"white\",\
\009string = \"white\",\
\009comment = \"white\"\
}\
\
local availableThemes = {\
\009{\"Water (Default)\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/default.txt\"},\
\009{\"Fire\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/fire.txt\"},\
\009{\"Sublime Text 2\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/st2.txt\"},\
\009{\"Midnight\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/midnight.txt\"},\
\009{\"TheOriginalBIT\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/bit.txt\"},\
\009{\"Superaxander\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/superaxander.txt\"},\
\009{\"Forest\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/forest.txt\"},\
\009{\"Night\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/night.txt\"},\
\009{\"Original\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/original.txt\"},\
}\
\
local function loadTheme(path)\
\009local f = io.open(path)\
\009local l = f:read(\"*l\")\
\009local config = {}\
\009while l ~= nil do\
\009\009local k, v = string.match(l, \"^(%a+)=(%a+)\")\
\009\009if k and v then config[k] = v end\
\009\009l = f:read(\"*l\")\
\009end\
\009f:close()\
\009return config\
end\
\
-- Load Theme\
if isAdvanced() then theme = defaultTheme\
else theme = normalTheme end\
\
\
--  -------- Drawing\
\
local function centerPrint(text, ny)\
\009if type(text) == \"table\" then for _, v in pairs(text) do centerPrint(v) end\
\009else\
\009\009local x, y = term.getCursorPos()\
\009\009local w, h = term.getSize()\
\009\009term.setCursorPos(w/2 - text:len()/2 + (#text % 2 == 0 and 1 or 0), ny or y)\
\009\009print(text)\
\009end\
end\
\
local function title(t)\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.background])\
\009term.clear()\
\
\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009for i = 2, 4 do term.setCursorPos(1, i) term.clearLine() end\
\009term.setCursorPos(3, 3)\
\009term.write(t)\
end\
\
local function centerRead(wid, begt)\
\009local function liveUpdate(line, e, but, x, y, p4, p5)\
\009\009if isAdvanced() and e == \"mouse_click\" and x >= w/2 - wid/2 and x <= w/2 - wid/2 + 10 \
\009\009\009\009and y >= 13 and y <= 15 then\
\009\009\009return true, \"\"\
\009\009end\
\009end\
\
\009if not begt then begt = \"\" end\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.promptHighlight])\
\009for i = 8, 10 do\
\009\009term.setCursorPos(w/2 - wid/2, i)\
\009\009term.write(string.rep(\" \", wid))\
\009end\
\
\009if isAdvanced() then\
\009\009term.setBackgroundColor(colors[theme.errHighlight])\
\009\009for i = 13, 15 do\
\009\009\009term.setCursorPos(w/2 - wid/2 + 1, i)\
\009\009\009term.write(string.rep(\" \", 10))\
\009\009end\
\009\009term.setCursorPos(w/2 - wid/2 + 2, 14)\
\009\009term.write(\"> Cancel\")\
\009end\
\
\009term.setBackgroundColor(colors[theme.promptHighlight])\
\009term.setCursorPos(w/2 - wid/2 + 1, 9)\
\009term.write(\"> \" .. begt)\
\009return modRead({visibleLength = w/2 + wid/2, liveUpdates = liveUpdate})\
end\
\
\
--  -------- Prompt\
\
local function prompt(list, dir, isGrid)\
\009local function draw(sel)\
\009\009for i, v in ipairs(list) do\
\009\009\009if i == sel then term.setBackgroundColor(v.highlight or colors[theme.promptHighlight])\
\009\009\009else term.setBackgroundColor(v.bg or colors[theme.prompt]) end\
\009\009\009term.setTextColor(v.tc or colors[theme.textColor])\
\009\009\009for i = -1, 1 do\
\009\009\009\009term.setCursorPos(v[2], v[3] + i)\
\009\009\009\009term.write(string.rep(\" \", v[1]:len() + 4))\
\009\009\009end\
\
\009\009\009term.setCursorPos(v[2], v[3])\
\009\009\009if i == sel then\
\009\009\009\009term.setBackgroundColor(v.highlight or colors[theme.promptHighlight])\
\009\009\009\009term.write(\" > \")\
\009\009\009else term.write(\" - \") end\
\009\009\009term.write(v[1] .. \" \")\
\009\009end\
\009end\
\
\009local key1 = dir == \"horizontal\" and 203 or 200\
\009local key2 = dir == \"horizontal\" and 205 or 208\
\009local sel = 1\
\009draw(sel)\
\
\009while true do\
\009\009local e, but, x, y = os.pullEvent()\
\009\009if e == \"key\" and but == 28 then\
\009\009\009return list[sel][1]\
\009\009elseif e == \"key\" and but == key1 and sel > 1 then\
\009\009\009sel = sel - 1\
\009\009\009draw(sel)\
\009\009elseif e == \"key\" and but == key2 and ((err == true and sel < #list - 1) or (sel < #list)) then\
\009\009\009sel = sel + 1\
\009\009\009draw(sel)\
\009\009elseif isGrid and e == \"key\" and but == 203 and sel > 2 then\
\009\009\009sel = sel - 2\
\009\009\009draw(sel)\
\009\009elseif isGrid and e == \"key\" and but == 205 and sel < 3 then\
\009\009\009sel = sel + 2\
\009\009\009draw(sel)\
\009\009elseif e == \"mouse_click\" then\
\009\009\009for i, v in ipairs(list) do\
\009\009\009\009if x >= v[2] - 1 and x <= v[2] + v[1]:len() + 3 and y >= v[3] - 1 and y <= v[3] + 1 then\
\009\009\009\009\009return list[i][1]\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function scrollingPrompt(list)\
\009local function draw(items, sel, loc)\
\009\009for i, v in ipairs(items) do\
\009\009\009local bg = colors[theme.prompt]\
\009\009\009local bghigh = colors[theme.promptHighlight]\
\009\009\009if v:find(\"Back\") or v:find(\"Return\") then\
\009\009\009\009bg = colors[theme.err]\
\009\009\009\009bghigh = colors[theme.errHighlight]\
\009\009\009end\
\
\009\009\009if i == sel then term.setBackgroundColor(bghigh)\
\009\009\009else term.setBackgroundColor(bg) end\
\009\009\009term.setTextColor(colors[theme.textColor])\
\009\009\009for x = -1, 1 do\
\009\009\009\009term.setCursorPos(3, (i * 4) + x + 4)\
\009\009\009\009term.write(string.rep(\" \", w - 13))\
\009\009\009end\
\
\009\009\009term.setCursorPos(3, i * 4 + 4)\
\009\009\009if i == sel then\
\009\009\009\009term.setBackgroundColor(bghigh)\
\009\009\009\009term.write(\" > \")\
\009\009\009else term.write(\" - \") end\
\009\009\009term.write(v .. \" \")\
\009\009end\
\009end\
\
\009local function updateDisplayList(items, loc, len)\
\009\009local ret = {}\
\009\009for i = 1, len do\
\009\009\009local item = items[i + loc - 1]\
\009\009\009if item then table.insert(ret, item) end\
\009\009end\
\009\009return ret\
\009end\
\
\009-- Variables\
\009local sel = 1\
\009local loc = 1\
\009local len = 3\
\009local disList = updateDisplayList(list, loc, len)\
\009draw(disList, sel, loc)\
\
\009-- Loop\
\009while true do\
\009\009local e, key, x, y = os.pullEvent()\
\
\009\009if e == \"mouse_click\" then\
\009\009\009for i, v in ipairs(disList) do\
\009\009\009\009if x >= 3 and x <= w - 11 and y >= i * 4 + 3 and y <= i * 4 + 5 then return v end\
\009\009\009end\
\009\009elseif e == \"key\" and key == 200 then\
\009\009\009if sel > 1 then\
\009\009\009\009sel = sel - 1\
\009\009\009\009draw(disList, sel, loc)\
\009\009\009elseif loc > 1 then\
\009\009\009\009loc = loc - 1\
\009\009\009\009disList = updateDisplayList(list, loc, len)\
\009\009\009\009draw(disList, sel, loc)\
\009\009\009end\
\009\009elseif e == \"key\" and key == 208 then\
\009\009\009if sel < len then\
\009\009\009\009sel = sel + 1\
\009\009\009\009draw(disList, sel, loc)\
\009\009\009elseif loc + len - 1 < #list then\
\009\009\009\009loc = loc + 1\
\009\009\009\009disList = updateDisplayList(list, loc, len)\
\009\009\009\009draw(disList, sel, loc)\
\009\009\009end\
\009\009elseif e == \"mouse_scroll\" then\
\009\009\009os.queueEvent(\"key\", key == -1 and 200 or 208)\
\009\009elseif e == \"key\" and key == 28 then\
\009\009\009return disList[sel]\
\009\009end\
\009end\
end\
\
function monitorKeyboardShortcuts()\
\009local ta, tb = nil, nil\
\009local allowChar = false\
\009local shiftPressed = false\
\009while true do\
\009\009local event, char = os.pullEvent()\
\009\009if event == \"key\" and (char == 42 or char == 52) then\
\009\009\009shiftPressed = true\
\009\009\009tb = os.startTimer(keyboardShortcutTimeout)\
\009\009elseif event == \"key\" and (char == 29 or char == 157 or char == 219 or char == 220) then\
\009\009\009allowEditorEvent = false\
\009\009\009allowChar = true\
\009\009\009ta = os.startTimer(keyboardShortcutTimeout)\
\009\009elseif event == \"key\" and allowChar then\
\009\009\009local name = nil\
\009\009\009for k, v in pairs(keys) do\
\009\009\009\009if v == char then\
\009\009\009\009\009if shiftPressed then os.queueEvent(\"shortcut\", \"ctrl shift\", k:lower())\
\009\009\009\009\009else os.queueEvent(\"shortcut\", \"ctrl\", k:lower()) end\
\009\009\009\009\009sleep(0.005)\
\009\009\009\009\009allowEditorEvent = true\
\009\009\009\009end\
\009\009\009end\
\009\009\009if shiftPressed then os.queueEvent(\"shortcut\", \"ctrl shift\", char)\
\009\009\009else os.queueEvent(\"shortcut\", \"ctrl\", char) end\
\009\009elseif event == \"timer\" and char == ta then\
\009\009\009allowEditorEvent = true\
\009\009\009allowChar = false\
\009\009elseif event == \"timer\" and char == tb then\
\009\009\009shiftPressed = false\
\009\009end\
\009end\
end\
\
\
--  -------- Saving and Loading\
\
local function download(url, path)\
\009for i = 1, 3 do\
\009\009local response = http.get(url)\
\009\009if response then\
\009\009\009local data = response.readAll()\
\009\009\009response.close()\
\009\009\009if path then\
\009\009\009\009local f = io.open(path, \"w\")\
\009\009\009\009f:write(data)\
\009\009\009\009f:close()\
\009\009\009end\
\009\009\009return true\
\009\009end\
\009end\
\
\009return false\
end\
\
local function saveFile(path, lines)\
\009local dir = path:sub(1, path:len() - fs.getName(path):len())\
\009if not fs.exists(dir) then fs.makeDir(dir) end\
\009if not fs.isDir(path) and not fs.isReadOnly(path) then\
\009\009local a = \"\"\
\009\009for _, v in pairs(lines) do a = a .. v .. \"\\n\" end\
\
\009\009local f = io.open(path, \"w\")\
\009\009f:write(a)\
\009\009f:close()\
\009\009return true\
\009else return false end\
end\
\
local function loadFile(path)\
\009if not fs.exists(path) then\
\009\009local dir = path:sub(1, path:len() - fs.getName(path):len())\
\009\009if not fs.exists(dir) then fs.makeDir(dir) end\
\009\009local f = io.open(path, \"w\")\
\009\009f:write(\"\")\
\009\009f:close()\
\009end\
\
\009local l = {}\
\009if fs.exists(path) and not fs.isDir(path) then\
\009\009local f = io.open(path, \"r\")\
\009\009if f then\
\009\009\009local a = f:read(\"*l\")\
\009\009\009while a do\
\009\009\009\009table.insert(l, a)\
\009\009\009\009a = f:read(\"*l\")\
\009\009\009end\
\009\009\009f:close()\
\009\009end\
\009else return nil end\
\
\009if #l < 1 then table.insert(l, \"\") end\
\009return l\
end\
\
\
--  -------- Languages\
\
languages.lua = {}\
languages.brainfuck = {}\
languages.none = {}\
\
--  Lua\
\
languages.lua.helpTips = {\
\009\"A function you tried to call doesn't exist.\",\
\009\"You made a typo.\",\
\009\"The index of an array is nil.\",\
\009\"The wrong variable type was passed.\",\
\009\"A function/variable doesn't exist.\",\
\009\"You missed an 'end'.\",\
\009\"You missed a 'then'.\",\
\009\"You declared a variable incorrectly.\",\
\009\"One of your variables is mysteriously nil.\"\
}\
\
languages.lua.defaultHelpTips = {\
\0092, 5\
}\
\
languages.lua.errors = {\
\009[\"Attempt to call nil.\"] = {1, 2},\
\009[\"Attempt to index nil.\"] = {3, 2},\
\009[\".+ expected, got .+\"] = {4, 2, 9},\
\009[\"'end' expected\"] = {6, 2},\
\009[\"'then' expected\"] = {7, 2},\
\009[\"'=' expected\"] = {8, 2}\
}\
\
languages.lua.keywords = {\
\009[\"and\"] = \"conditional\",\
\009[\"break\"] = \"conditional\",\
\009[\"do\"] = \"conditional\",\
\009[\"else\"] = \"conditional\",\
\009[\"elseif\"] = \"conditional\",\
\009[\"end\"] = \"conditional\",\
\009[\"for\"] = \"conditional\",\
\009[\"function\"] = \"conditional\",\
\009[\"if\"] = \"conditional\",\
\009[\"in\"] = \"conditional\",\
\009[\"local\"] = \"conditional\",\
\009[\"not\"] = \"conditional\",\
\009[\"or\"] = \"conditional\",\
\009[\"repeat\"] = \"conditional\",\
\009[\"return\"] = \"conditional\",\
\009[\"then\"] = \"conditional\",\
\009[\"until\"] = \"conditional\",\
\009[\"while\"] = \"conditional\",\
\
\009[\"true\"] = \"constant\",\
\009[\"false\"] = \"constant\",\
\009[\"nil\"] = \"constant\",\
\
\009[\"print\"] = \"function\",\
\009[\"write\"] = \"function\",\
\009[\"sleep\"] = \"function\",\
\009[\"pairs\"] = \"function\",\
\009[\"ipairs\"] = \"function\",\
\009[\"loadstring\"] = \"function\",\
\009[\"loadfile\"] = \"function\",\
\009[\"dofile\"] = \"function\",\
\009[\"rawset\"] = \"function\",\
\009[\"rawget\"] = \"function\",\
\009[\"setfenv\"] = \"function\",\
\009[\"getfenv\"] = \"function\",\
}\
\
languages.lua.parseError = function(e)\
\009local ret = {filename = \"unknown\", line = -1, display = \"Unknown!\", err = \"\"}\
\009if e and e ~= \"\" then\
\009\009ret.err = e\
\009\009if e:find(\":\") then\
\009\009\009ret.filename = e:sub(1, e:find(\":\") - 1):gsub(\"^%s*(.-)%s*$\", \"%1\")\
\009\009\009-- The \"\" is needed to circumvent a CC bug\
\009\009\009e = (e:sub(e:find(\":\") + 1) .. \"\"):gsub(\"^%s*(.-)%s*$\", \"%1\")\
\009\009\009if e:find(\":\") then\
\009\009\009\009ret.line = e:sub(1, e:find(\":\") - 1)\
\009\009\009\009e = e:sub(e:find(\":\") + 2):gsub(\"^%s*(.-)%s*$\", \"%1\") .. \"\"\
\009\009\009end\
\009\009end\
\009\009ret.display = e:sub(1, 1):upper() .. e:sub(2, -1) .. \".\"\
\009end\
\
\009return ret\
end\
\
languages.lua.getCompilerErrors = function(code)\
\009code = \"local function ee65da6af1cb6f63fee9a081246f2fd92b36ef2(...)\\n\\n\" .. code .. \"\\n\\nend\"\
\009local fn, err = loadstring(code)\
\009if not err then\
\009\009local _, e = pcall(fn)\
\009\009if e then err = e end\
\009end\
\
\009if err then\
\009\009local a = err:find(\"]\", 1, true)\
\009\009if a then err = \"string\" .. err:sub(a + 1, -1) end\
\009\009local ret = languages.lua.parseError(err)\
\009\009if tonumber(ret.line) then ret.line = tonumber(ret.line) end\
\009\009return ret\
\009else return languages.lua.parseError(nil) end\
end\
\
languages.lua.run = function(path, ar)\
\009local fn, err = loadfile(path)\
\009setfenv(fn, getfenv())\
\009if not err then\
\009\009_, err = pcall(function() fn(unpack(ar)) end)\
\009end\
\009return err\
end\
\
\
--  Brainfuck\
\
languages.brainfuck.helpTips = {\
\009\"Well idk...\",\
\009\"Isn't this the whole point of the language?\",\
\009\"Ya know... Not being able to debug it?\",\
\009\"You made a typo.\"\
}\
\
languages.brainfuck.defaultHelpTips = {\
\0091, 2, 3\
}\
\
languages.brainfuck.errors = {\
\009[\"No matching '['\"] = {1, 2, 3, 4}\
}\
\
languages.brainfuck.keywords = {}\
\
languages.brainfuck.parseError = function(e)\
\009local ret = {filename = \"unknown\", line = -1, display = \"Unknown!\", err = \"\"}\
\009if e and e ~= \"\" then\
\009\009ret.err = e\
\009\009ret.line = e:sub(1, e:find(\":\") - 1)\
\009\009e = e:sub(e:find(\":\") + 2):gsub(\"^%s*(.-)%s*$\", \"%1\") .. \"\"\
\009\009ret.display = e:sub(1, 1):upper() .. e:sub(2, -1) .. \".\"\
\009end\
\
\009return ret\
end\
\
languages.brainfuck.mapLoops = function(code)\
\009-- Map loops\
\009local loopLocations = {}\
\009local loc = 1\
\009local line = 1\
\009for let in string.gmatch(code, \".\") do\
\009\009if let == \"[\" then\
\009\009\009loopLocations[loc] = true\
\009\009elseif let == \"]\" then\
\009\009\009local found = false\
\009\009\009for i = loc, 1, -1 do \
\009\009\009\009if loopLocations[i] == true then\
\009\009\009\009\009loopLocations[i] = loc\
\009\009\009\009\009found = true\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009if not found then\
\009\009\009\009return line .. \": No matching '['\"\
\009\009\009end\
\009\009end\
\
\009\009if let == \"\\n\" then line = line + 1 end\
\009\009loc = loc + 1\
\009end\
\009return loopLocations\
end\
\
languages.brainfuck.getCompilerErrors = function(code)\
\009local a = languages.brainfuck.mapLoops(code)\
\009if type(a) == \"string\" then return languages.brainfuck.parseError(a)\
\009else return languages.brainfuck.parseError(nil) end\
end\
\
languages.brainfuck.run = function(path)\
\009-- Read from file\
\009local f = io.open(path, \"r\")\
\009local content = f:read(\"*a\")\
\009f:close()\
\
\009-- Define environment\
\009local dataCells = {}\
\009local dataPointer = 1\
\009local instructionPointer = 1\
\
\009-- Map loops\
\009local loopLocations = languages.brainfuck.mapLoops(content)\
\009if type(loopLocations) == \"string\" then return loopLocations end\
\
\009-- Execute code\
\009while true do\
\009\009local let = content:sub(instructionPointer, instructionPointer)\
\
\009\009if let == \">\" then\
\009\009\009dataPointer = dataPointer + 1\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009elseif let == \"<\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009dataPointer = dataPointer - 1\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009elseif let == \"+\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009dataCells[tostring(dataPointer)] = dataCells[tostring(dataPointer)] + 1\
\009\009elseif let == \"-\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009dataCells[tostring(dataPointer)] = dataCells[tostring(dataPointer)] - 1\
\009\009elseif let == \".\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009if term.getCursorPos() >= w then print(\"\") end\
\009\009\009write(string.char(math.max(1, dataCells[tostring(dataPointer)])))\
\009\009elseif let == \",\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009term.setCursorBlink(true)\
\009\009\009local e, but = os.pullEvent(\"char\")\
\009\009\009term.setCursorBlink(false)\
\009\009\009dataCells[tostring(dataPointer)] = string.byte(but)\
\009\009\009if term.getCursorPos() >= w then print(\"\") end\
\009\009\009write(but)\
\009\009elseif let == \"/\" then\
\009\009\009if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
\009\009\009if term.getCursorPos() >= w then print(\"\") end\
\009\009\009write(dataCells[tostring(dataPointer)])\
\009\009elseif let == \"[\" then\
\009\009\009if dataCells[tostring(dataPointer)] == 0 then\
\009\009\009\009for k, v in pairs(loopLocations) do\
\009\009\009\009\009if k == instructionPointer then instructionPointer = v end\
\009\009\009\009end\
\009\009\009end\
\009\009elseif let == \"]\" then\
\009\009\009for k, v in pairs(loopLocations) do\
\009\009\009\009if v == instructionPointer then instructionPointer = k - 1 end\
\009\009\009end\
\009\009end\
\
\009\009instructionPointer = instructionPointer + 1\
\009\009if instructionPointer > content:len() then print(\"\") break end\
\009end\
end\
\
--  None\
\
languages.none.helpTips = {}\
languages.none.defaultHelpTips = {}\
languages.none.errors = {}\
languages.none.keywords = {}\
\
languages.none.parseError = function(err)\
\009return {filename = \"\", line = -1, display = \"\", err = \"\"}\
end\
\
languages.none.getCompilerErrors = function(code)\
\009return languages.none.parseError(nil)\
end\
\
languages.none.run = function(path) end\
\
\
-- Load language\
curLanguage = languages.lua\
\
\
--  -------- Run GUI\
\
local function viewErrorHelp(e)\
\009title(\"LuaIDE - Error Help\")\
\
\009local tips = nil\
\009for k, v in pairs(curLanguage.errors) do\
\009\009if e.display:find(k) then tips = v break end\
\009end\
\
\009term.setBackgroundColor(colors[theme.err])\
\009for i = 6, 8 do\
\009\009term.setCursorPos(5, i)\
\009\009term.write(string.rep(\" \", 35))\
\009end\
\
\009term.setBackgroundColor(colors[theme.prompt])\
\009for i = 10, 18 do\
\009\009term.setCursorPos(5, i)\
\009\009term.write(string.rep(\" \", 46))\
\009end\
\
\009if tips then\
\009\009term.setBackgroundColor(colors[theme.err])\
\009\009term.setCursorPos(6, 7)\
\009\009term.write(\"Error Help\")\
\
\009\009term.setBackgroundColor(colors[theme.prompt])\
\009\009for i, v in ipairs(tips) do\
\009\009\009term.setCursorPos(7, i + 10)\
\009\009\009term.write(\"- \" .. curLanguage.helpTips[v])\
\009\009end\
\009else\
\009\009term.setBackgroundColor(colors[theme.err])\
\009\009term.setCursorPos(6, 7)\
\009\009term.write(\"No Error Tips Available!\")\
\
\009\009term.setBackgroundColor(colors[theme.prompt])\
\009\009term.setCursorPos(6, 11)\
\009\009term.write(\"There are no error tips available, but\")\
\009\009term.setCursorPos(6, 12)\
\009\009term.write(\"you could see if it was any of these:\")\
\
\009\009for i, v in ipairs(curLanguage.defaultHelpTips) do\
\009\009\009term.setCursorPos(7, i + 12)\
\009\009\009term.write(\"- \" .. curLanguage.helpTips[v])\
\009\009end\
\009end\
\
\009prompt({{\"Back\", w - 8, 7}}, \"horizontal\")\
end\
\
local function run(path, lines, useArgs)\
\009local ar = {}\
\009if useArgs then\
\009\009title(\"LuaIDE - Run \" .. fs.getName(path))\
\009\009local s = centerRead(w - 13, fs.getName(path) .. \" \")\
\009\009for m in string.gmatch(s, \"[^ \\t]+\") do ar[#ar + 1] = m:gsub(\"^%s*(.-)%s*$\", \"%1\") end\
\009end\
\009\
\009saveFile(path, lines)\
\009term.setCursorBlink(false)\
\009term.setBackgroundColor(colors.black)\
\009term.setTextColor(colors.white)\
\009term.clear()\
\009term.setCursorPos(1, 1)\
\009local err = curLanguage.run(path, ar)\
\
\009term.setBackgroundColor(colors.black)\
\009print(\"\\n\")\
\009if err then\
\009\009if isAdvanced() then term.setTextColor(colors.red) end\
\009\009centerPrint(\"The program has crashed!\")\
\009end\
\009term.setTextColor(colors.white)\
\009centerPrint(\"Press any key to return to LuaIDE...\")\
\009while true do\
\009\009local e = os.pullEvent()\
\009\009if e == \"key\" then break end\
\009end\
\
\009-- To prevent key from showing up in editor\
\009os.queueEvent(event_distract)\
\009os.pullEvent()\
\
\009if err then\
\009\009if curLanguage == languages.lua and err:find(\"]\") then\
\009\009\009err = fs.getName(path) .. err:sub(err:find(\"]\", 1, true) + 1, -1)\
\009\009end\
\
\009\009while true do\
\009\009\009title(\"LuaIDE - Error!\")\
\
\009\009\009term.setBackgroundColor(colors[theme.err])\
\009\009\009for i = 6, 8 do\
\009\009\009\009term.setCursorPos(3, i)\
\009\009\009\009term.write(string.rep(\" \", w - 5))\
\009\009\009end\
\009\009\009term.setCursorPos(4, 7)\
\009\009\009term.write(\"The program has crashed!\")\
\
\009\009\009term.setBackgroundColor(colors[theme.prompt])\
\009\009\009for i = 10, 14 do\
\009\009\009\009term.setCursorPos(3, i)\
\009\009\009\009term.write(string.rep(\" \", w - 5))\
\009\009\009end\
\
\009\009\009local formattedErr = curLanguage.parseError(err)\
\009\009\009term.setCursorPos(4, 11)\
\009\009\009term.write(\"Line: \" .. formattedErr.line)\
\009\009\009term.setCursorPos(4, 12)\
\009\009\009term.write(\"Error:\")\
\009\009\009term.setCursorPos(5, 13)\
\
\009\009\009local a = formattedErr.display\
\009\009\009local b = nil\
\009\009\009if a:len() > w - 8 then\
\009\009\009\009for i = a:len(), 1, -1 do\
\009\009\009\009\009if a:sub(i, i) == \" \" then\
\009\009\009\009\009\009b = a:sub(i + 1, -1)\
\009\009\009\009\009\009a = a:sub(1, i)\
\009\009\009\009\009\009break\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009term.write(a)\
\009\009\009if b then\
\009\009\009\009term.setCursorPos(5, 14)\
\009\009\009\009term.write(b)\
\009\009\009end\
\009\009\009\
\009\009\009local opt = prompt({{\"Error Help\", w/2 - 15, 17}, {\"Go To Line\", w/2 + 2, 17}},\
\009\009\009\009\"horizontal\")\
\009\009\009if opt == \"Error Help\" then\
\009\009\009\009viewErrorHelp(formattedErr)\
\009\009\009elseif opt == \"Go To Line\" then\
\009\009\009\009-- To prevent key from showing up in editor\
\009\009\009\009os.queueEvent(event_distract)\
\009\009\009\009os.pullEvent()\
\
\009\009\009\009return \"go to\", tonumber(formattedErr.line)\
\009\009\009end\
\009\009end\
\009end\
end\
\
\
--  -------- Functions\
\
local function goto()\
\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009term.setCursorPos(2, 1)\
\009term.clearLine()\
\009term.write(\"Line: \")\
\009local line = modRead({visibleLength = w - 2})\
\
\009local num = tonumber(line)\
\009if num and num > 0 then return num\
\009else\
\009\009term.setCursorPos(2, 1)\
\009\009term.clearLine()\
\009\009term.write(\"Not a line number!\")\
\009\009sleep(1.6)\
\009\009return nil\
\009end\
end\
\
local function setsyntax()\
\009local opts = {\
\009\009\"[Lua]   Brainfuck    None \",\
\009\009\" Lua   [Brainfuck]   None \",\
\009\009\" Lua    Brainfuck   [None]\"\
\009}\
\009local sel = 1\
\
\009term.setCursorBlink(false)\
\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009term.setCursorPos(2, 1)\
\009term.clearLine()\
\009term.write(opts[sel])\
\009while true do\
\009\009local e, but, x, y = os.pullEvent(\"key\")\
\009\009if but == 203 then\
\009\009\009sel = math.max(1, sel - 1)\
\009\009\009term.setCursorPos(2, 1)\
\009\009\009term.clearLine()\
\009\009\009term.write(opts[sel])\
\009\009elseif but == 205 then\
\009\009\009sel = math.min(#opts, sel + 1)\
\009\009\009term.setCursorPos(2, 1)\
\009\009\009term.clearLine()\
\009\009\009term.write(opts[sel])\
\009\009elseif but == 28 then\
\009\009\009if sel == 1 then curLanguage = languages.lua\
\009\009\009elseif sel == 2 then curLanguage = languages.brainfuck\
\009\009\009elseif sel == 3 then curLanguage = languages.none end\
\009\009\009term.setCursorBlink(true)\
\009\009\009return\
\009\009end\
\009end\
end\
\
\
--  -------- Re-Indenting\
\
local tabWidth = 2\
\
local comments = {}\
local strings = {}\
\
local increment = {\
\009\"if%s+.+%s+then%s*$\",\
\009\"for%s+.+%s+do%s*$\",\
\009\"while%s+.+%s+do%s*$\",\
\009\"repeat%s*$\",\
\009\"function%s+[a-zA-Z_0-9]\\(.*\\)%s*$\"\
}\
\
local decrement = {\
\009\"end\",\
\009\"until%s+.+\"\
}\
\
local special = {\
\009\"else%s*$\",\
\009\"elseif%s+.+%s+then%s*$\"\
}\
\
local function check(func)\
\009for _, v in pairs(func) do\
\009\009local cLineStart = v[\"lineStart\"]\
\009\009local cLineEnd = v[\"lineEnd\"]\
\009\009local cCharStart = v[\"charStart\"]\
\009\009local cCharEnd = v[\"charEnd\"]\
\
\009\009if line >= cLineStart and line <= cLineEnd then\
\009\009\009if line == cLineStart then return cCharStart < charNumb\
\009\009\009elseif line == cLineEnd then return cCharEnd > charNumb\
\009\009\009else return true end\
\009\009end\
\009end\
end\
\
local function isIn(line, loc)\
\009if check(comments) then return true end\
\009if check(strings) then return true end\
\009return false\
end\
\
local function setComment(ls, le, cs, ce)\
\009comments[#comments + 1] = {}\
\009comments[#comments].lineStart = ls\
\009comments[#comments].lineEnd = le\
\009comments[#comments].charStart = cs\
\009comments[#comments].charEnd = ce\
end\
\
local function setString(ls, le, cs, ce)\
\009strings[#strings + 1] = {}\
\009strings[#strings].lineStart = ls\
\009strings[#strings].lineEnd = le\
\009strings[#strings].charStart = cs\
\009strings[#strings].charEnd = ce\
end\
\
local function map(contents)\
\009local inCom = false\
\009local inStr = false\
\
\009for i = 1, #contents do\
\009\009if content[i]:find(\"%-%-%[%[\") and not inStr and not inCom then\
\009\009\009local cStart = content[i]:find(\"%-%-%[%[\")\
\009\009\009setComment(i, nil, cStart, nil)\
\009\009\009inCom = true\
\009\009elseif content[i]:find(\"%-%-%[=%[\") and not inStr and not inCom then\
\009\009\009local cStart = content[i]:find(\"%-%-%[=%[\")\
\009\009\009setComment(i, nil, cStart, nil)\
\009\009\009inCom = true\
\009\009elseif content[i]:find(\"%[%[\") and not inStr and not inCom then\
\009\009\009local cStart = content[i]:find(\"%[%[\")\
\009\009\009setString(i, nil, cStart, nil)\
\009\009\009inStr = true\
\009\009elseif content[i]:find(\"%[=%[\") and not inStr and not inCom then\
\009\009\009local cStart = content[i]:find(\"%[=%[\")\
\009\009\009setString(i, nil, cStart, nil)\
\009\009\009inStr = true\
\009\009end\
\
\009\009if content[i]:find(\"%]%]\") and inStr and not inCom then\
\009\009\009local cStart, cEnd = content[i]:find(\"%]%]\")\
\009\009\009strings[#strings].lineEnd = i\
\009\009\009strings[#strings].charEnd = cEnd\
\009\009\009inStr = false\
\009\009elseif content[i]:find(\"%]=%]\") and inStr and not inCom then\
\009\009\009local cStart, cEnd = content[i]:find(\"%]=%]\")\
\009\009\009strings[#strings].lineEnd = i\
\009\009\009strings[#strings].charEnd = cEnd\
\009\009\009inStr = false\
\009\009end\
\
\009\009if content[i]:find(\"%]%]\") and not inStr and inCom then\
\009\009\009local cStart, cEnd = content[i]:find(\"%]%]\")\
\009\009\009comments[#comments].lineEnd = i\
\009\009\009comments[#comments].charEnd = cEnd\
\009\009\009inCom = false\
\009\009elseif content[i]:find(\"%]=%]\") and not inStr and inCom then\
\009\009\009local cStart, cEnd = content[i]:find(\"%]=%]\")\
\009\009\009comments[#comments].lineEnd = i\
\009\009\009comments[#comments].charEnd = cEnd\
\009\009\009inCom = false\
\009\009end\
\
\009\009if content[i]:find(\"%-%-\") and not inStr and not inCom then\
\009\009\009local cStart = content[i]:find(\"%-%-\")\
\009\009\009setComment(i, i, cStart, -1)\
\009\009elseif content[i]:find(\"'\") and not inStr and not inCom then\
\009\009\009local cStart, cEnd = content[i]:find(\"'\")\
\009\009\009local nextChar = content[i]:sub(cEnd + 1, string.len(content[i]))\
\009\009\009local _, cEnd = nextChar:find(\"'\")\
\009\009\009setString(i, i, cStart, cEnd)\
\009\009elseif content[i]:find('\"') and not inStr and not inCom then\
\009\009\009local cStart, cEnd = content[i]:find('\"')\
\009\009\009local nextChar = content[i]:sub(cEnd + 1, string.len(content[i]))\
\009\009\009local _, cEnd = nextChar:find('\"')\
\009\009\009setString(i, i, cStart, cEnd)\
\009\009end\
\009end\
end\
\
local function reindent(contents)\
\009local err = nil\
\009if curLanguage ~= languages.lua then\
\009\009err = \"Cannot indent languages other than Lua!\"\
\009elseif curLanguage.getCompilerErrors(table.concat(contents, \"\\n\")).line ~= -1 then\
\009\009err = \"Cannot indent a program with errors!\"\
\009end\
\
\009if err then\
\009\009term.setCursorBlink(false)\
\009\009term.setCursorPos(2, 1)\
\009\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009\009term.clearLine()\
\009\009term.write(err)\
\009\009sleep(1.6)\
\009\009return contents\
\009end\
\
\009local new = {}\
\009local level = 0\
\009for k, v in pairs(contents) do\
\009\009local incrLevel = false\
\009\009local foundIncr = false\
\009\009for _, incr in pairs(increment) do\
\009\009\009if v:find(incr) and not isIn(k, v:find(incr)) then\
\009\009\009\009incrLevel = true\
\009\009\009end\
\009\009\009if v:find(incr:sub(1, -2)) and not isIn(k, v:find(incr)) then\
\009\009\009\009foundIncr = true\
\009\009\009end\
\009\009end\
\
\009\009local decrLevel = false\
\009\009if not incrLevel then\
\009\009\009for _, decr in pairs(decrement) do\
\009\009\009\009if v:find(decr) and not isIn(k, v:find(decr)) and not foundIncr then\
\009\009\009\009\009level = math.max(0, level - 1)\
\009\009\009\009\009decrLevel = true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009\009if not decrLevel then\
\009\009\009for _, sp in pairs(special) do\
\009\009\009\009if v:find(sp) and not isIn(k, v:find(sp)) then\
\009\009\009\009\009incrLevel = true\
\009\009\009\009\009level = math.max(0, level - 1)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009\009new[k] = string.rep(\" \", level * tabWidth) .. v\
\009\009if incrLevel then level = level + 1 end\
\009end\
\
\009return new\
end\
\
\
--  -------- Menu\
\
local menu = {\
\009[1] = {\"File\",\
--\009\009\"About\",\
--\009\009\"Settings\",\
--\009\009\"\",\
\009\009\"New File  ^+N\",\
\009\009\"Open File ^+O\",\
\009\009\"Save File ^+S\",\
\009\009\"Close     ^+W\",\
\009\009\"Print     ^+P\",\
\009\009\"Quit      ^+Q\"\
\009}, [2] = {\"Edit\",\
\009\009\"Cut Line   ^+X\",\
\009\009\"Copy Line  ^+C\",\
\009\009\"Paste Line ^+V\",\
\009\009\"Delete Line\",\
\009\009\"Clear Line\"\
\009}, [3] = {\"Functions\",\
\009\009\"Go To Line    ^+G\",\
\009\009\"Re-Indent     ^+I\",\
\009\009\"Set Syntax    ^+E\",\
\009\009\"Start of Line ^+<\",\
\009\009\"End of Line   ^+>\"\
\009}, [4] = {\"Run\",\
\009\009\"Run Program       ^+R\",\
\009\009\"Run w/ Args ^+Shift+R\"\
\009}\
}\
\
local shortcuts = {\
\009-- File\
\009[\"ctrl n\"] = \"New File  ^+N\",\
\009[\"ctrl o\"] = \"Open File ^+O\",\
\009[\"ctrl s\"] = \"Save File ^+S\",\
\009[\"ctrl w\"] = \"Close     ^+W\",\
\009[\"ctrl p\"] = \"Print     ^+P\",\
\009[\"ctrl q\"] = \"Quit      ^+Q\",\
\
\009-- Edit\
\009[\"ctrl x\"] = \"Cut Line   ^+X\",\
\009[\"ctrl c\"] = \"Copy Line  ^+C\",\
\009[\"ctrl v\"] = \"Paste Line ^+V\",\
\
\009-- Functions\
\009[\"ctrl g\"] = \"Go To Line    ^+G\",\
\009[\"ctrl i\"] = \"Re-Indent     ^+I\",\
\009[\"ctrl e\"] = \"Set Syntax    ^+E\",\
\009[\"ctrl 203\"] = \"Start of Line ^+<\",\
\009[\"ctrl 205\"] = \"End of Line   ^+>\",\
\
\009-- Run\
\009[\"ctrl r\"] = \"Run Program       ^+R\",\
\009[\"ctrl shift r\"] = \"Run w/ Args ^+Shift+R\"\
}\
\
local menuFunctions = {\
\009-- File\
--\009[\"About\"] = function() end,\
--\009[\"Settings\"] = function() end,\
\009[\"New File  ^+N\"] = function(path, lines) saveFile(path, lines) return \"new\" end,\
\009[\"Open File ^+O\"] = function(path, lines) saveFile(path, lines) return \"open\" end,\
\009[\"Save File ^+S\"] = function(path, lines) saveFile(path, lines) end,\
\009[\"Close     ^+W\"] = function(path, lines) saveFile(path, lines) return \"menu\" end,\
\009[\"Print     ^+P\"] = function(path, lines) saveFile(path, lines) return nil end,\
\009[\"Quit      ^+Q\"] = function(path, lines) saveFile(path, lines) return \"exit\" end,\
\
\009-- Edit\
\009[\"Cut Line   ^+X\"] = function(path, lines, y)\
\009\009clipboard = lines[y] table.remove(lines, y) return nil, lines end,\
\009[\"Copy Line  ^+C\"] = function(path, lines, y) clipboard = lines[y] end,\
\009[\"Paste Line ^+V\"] = function(path, lines, y)\
\009\009if clipboard then table.insert(lines, y, clipboard) end return nil, lines end,\
\009[\"Delete Line\"] = function(path, lines, y) table.remove(lines, y) return nil, lines end,\
\009[\"Clear Line\"] = function(path, lines, y) lines[y] = \"\" return nil, lines, \"cursor\" end,\
\
\009-- Functions\
\009[\"Go To Line    ^+G\"] = function() return nil, \"go to\", goto() end,\
\009[\"Re-Indent     ^+I\"] = function(path, lines)\
\009\009local a = reindent(lines) saveFile(path, lines) return nil, a\
\009end,\
\009[\"Set Syntax    ^+E\"] = function(path, lines)\
\009\009setsyntax()\
\009\009if curLanguage == languages.brainfuck and lines[1] ~= \"-- Syntax: Brainfuck\" then\
\009\009\009table.insert(lines, 1, \"-- Syntax: Brainfuck\")\
\009\009\009return nil, lines\
\009\009end\
\009end,\
\009[\"Start of Line ^+<\"] = function() os.queueEvent(\"key\", 199) end,\
\009[\"End of Line   ^+>\"] = function() os.queueEvent(\"key\", 207) end,\
\
\009-- Run\
\009[\"Run Program       ^+R\"] = function(path, lines)\
\009\009saveFile(path, lines)\
\009\009return nil, run(path, lines, false)\
\009end,\
\009[\"Run w/ Args ^+Shift+R\"] = function(path, lines)\
\009\009saveFile(path, lines)\
\009\009return nil, run(path, lines, true)\
\009end,\
}\
\
local function drawMenu(open)\
\009term.setCursorPos(1, 1)\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009term.clearLine()\
\009local curX = 0\
\009for _, v in pairs(menu) do\
\009\009term.setCursorPos(3 + curX, 1)\
\009\009term.write(v[1])\
\009\009curX = curX + v[1]:len() + 3\
\009end\
\
\009if open then\
\009\009local it = {}\
\009\009local x = 1\
\009\009for _, v in pairs(menu) do\
\009\009\009if open == v[1] then\
\009\009\009\009it = v\
\009\009\009\009break\
\009\009\009end\
\009\009\009x = x + v[1]:len() + 3\
\009\009end\
\009\009x = x + 1\
\
\009\009local items = {}\
\009\009for i = 2, #it do\
\009\009\009table.insert(items, it[i])\
\009\009end\
\
\009\009local len = 1\
\009\009for _, v in pairs(items) do if v:len() + 2 > len then len = v:len() + 2 end end\
\
\009\009for i, v in ipairs(items) do\
\009\009\009term.setCursorPos(x, i + 1)\
\009\009\009term.write(string.rep(\" \", len))\
\009\009\009term.setCursorPos(x + 1, i + 1)\
\009\009\009term.write(v)\
\009\009end\
\009\009term.setCursorPos(x, #items + 2)\
\009\009term.write(string.rep(\" \", len))\
\009\009return items, len\
\009end\
end\
\
local function triggerMenu(cx, cy)\
\009-- Determine clicked menu\
\009local curX = 0\
\009local open = nil\
\009for _, v in pairs(menu) do\
\009\009if cx >= curX + 3 and cx <= curX + v[1]:len() + 2 then\
\009\009\009open = v[1]\
\009\009\009break\
\009\009end\
\009\009curX = curX + v[1]:len() + 3\
\009end\
\009local menux = curX + 2\
\009if not open then return false end\
\
\009-- Flash menu item\
\009term.setCursorBlink(false)\
\009term.setCursorPos(menux, 1)\
\009term.setBackgroundColor(colors[theme.background])\
\009term.write(string.rep(\" \", open:len() + 2))\
\009term.setCursorPos(menux + 1, 1)\
\009term.write(open)\
\009sleep(0.1)\
\009local items, len = drawMenu(open)\
\
\009local ret = true\
\
\009-- Pull events on menu\
\009local ox, oy = term.getCursorPos()\
\009while type(ret) ~= \"string\" do\
\009\009local e, but, x, y = os.pullEvent()\
\009\009if e == \"mouse_click\" then\
\009\009\009-- If clicked outside menu\
\009\009\009if x < menux - 1 or x > menux + len - 1 then break\
\009\009\009elseif y > #items + 2 then break\
\009\009\009elseif y == 1 then break end\
\
\009\009\009for i, v in ipairs(items) do\
\009\009\009\009if y == i + 1 and x >= menux and x <= menux + len - 2 then\
\009\009\009\009\009-- Flash when clicked\
\009\009\009\009\009term.setCursorPos(menux, y)\
\009\009\009\009\009term.setBackgroundColor(colors[theme.background])\
\009\009\009\009\009term.write(string.rep(\" \", len))\
\009\009\009\009\009term.setCursorPos(menux + 1, y)\
\009\009\009\009\009term.write(v)\
\009\009\009\009\009sleep(0.1)\
\009\009\009\009\009drawMenu(open)\
\
\009\009\009\009\009-- Return item\
\009\009\009\009\009ret = v\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009term.setCursorPos(ox, oy)\
\009term.setCursorBlink(true)\
\009return ret\
end\
\
\
--  -------- Editing\
\
local standardsCompletions = {\
\009\"if%s+.+%s+then%s*$\",\
\009\"for%s+.+%s+do%s*$\",\
\009\"while%s+.+%s+do%s*$\",\
\009\"repeat%s*$\",\
\009\"function%s+[a-zA-Z_0-9]?\\(.*\\)%s*$\",\
\009\"=%s*function%s*\\(.*\\)%s*$\",\
\009\"else%s*$\",\
\009\"elseif%s+.+%s+then%s*$\"\
}\
\
local liveCompletions = {\
\009[\"(\"] = \")\",\
\009[\"{\"] = \"}\",\
\009[\"[\"] = \"]\",\
\009[\"\\\"\"] = \"\\\"\",\
\009[\"'\"] = \"'\",\
}\
\
local x, y = 0, 0\
local edw, edh = 0, h - 1\
local offx, offy = 0, 1\
local scrollx, scrolly = 0, 0\
local lines = {}\
local liveErr = curLanguage.parseError(nil)\
local displayCode = true\
local lastEventClock = os.clock()\
\
local function attemptToHighlight(line, regex, col)\
\009local match = string.match(line, regex)\
\009if match then\
\009\009if type(col) == \"number\" then term.setTextColor(col)\
\009\009elseif type(col) == \"function\" then term.setTextColor(col(match)) end\
\009\009term.write(match)\
\009\009term.setTextColor(colors[theme.textColor])\
\009\009return line:sub(match:len() + 1, -1)\
\009end\
\009return nil\
end\
\
local function writeHighlighted(line)\
\009if curLanguage == languages.lua then\
\009\009while line:len() > 0 do\009\
\009\009\009line = attemptToHighlight(line, \"^%-%-%[%[.-%]%]\", colors[theme.comment]) or\
\009\009\009\009attemptToHighlight(line, \"^%-%-.*\", colors[theme.comment]) or\
\009\009\009\009attemptToHighlight(line, \"^\\\".*[^\\\\]\\\"\", colors[theme.string]) or\
\009\009\009\009attemptToHighlight(line, \"^\\'.*[^\\\\]\\'\", colors[theme.string]) or\
\009\009\009\009attemptToHighlight(line, \"^%[%[.-%]%]\", colors[theme.string]) or\
\009\009\009\009attemptToHighlight(line, \"^[%w_]+\", function(match)\
\009\009\009\009\009if curLanguage.keywords[match] then\
\009\009\009\009\009\009return colors[theme[curLanguage.keywords[match]]]\
\009\009\009\009\009end\
\009\009\009\009\009return colors[theme.textColor]\
\009\009\009\009end) or\
\009\009\009\009attemptToHighlight(line, \"^[^%w_]\", colors[theme.textColor])\
\009\009end\
\009else term.write(line) end\
end\
\
local function draw()\
\009-- Menu\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.editorBackground])\
\009term.clear()\
\009drawMenu()\
\
\009-- Line numbers\
\009offx, offy = tostring(#lines):len() + 1, 1\
\009edw, edh = w - offx, h - 1\
\
\009-- Draw text\
\009for i = 1, edh do\
\009\009local a = lines[scrolly + i]\
\009\009if a then\
\009\009\009local ln = string.rep(\" \", offx - 1 - tostring(scrolly + i):len()) .. tostring(scrolly + i) \
\009\009\009local l = a:sub(scrollx + 1, edw + scrollx + 1)\
\009\009\009ln = ln .. \":\"\
\
\009\009\009if liveErr.line == scrolly + i then ln = string.rep(\" \", offx - 2) .. \"!:\" end\
\
\009\009\009term.setCursorPos(1, i + offy)\
\009\009\009term.setBackgroundColor(colors[theme.editorBackground])\
\009\009\009if scrolly + i == y then\
\009\009\009\009if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
\009\009\009\009term.clearLine()\
\009\009\009elseif scrolly + i == liveErr.line then\
\009\009\009\009term.setBackgroundColor(colors[theme.editorError])\
\009\009\009\009term.clearLine()\
\009\009\009end\
\
\009\009\009term.setCursorPos(1 - scrollx + offx, i + offy)\
\009\009\009if scrolly + i == y then\
\009\009\009\009if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
\009\009\009elseif scrolly + i == liveErr.line then term.setBackgroundColor(colors[theme.editorError])\
\009\009\009else term.setBackgroundColor(colors[theme.editorBackground]) end\
\009\009\009if scrolly + i == liveErr.line then\
\009\009\009\009if displayCode then term.write(a)\
\009\009\009\009else term.write(liveErr.display) end\
\009\009\009else writeHighlighted(a) end\
\
\009\009\009term.setCursorPos(1, i + offy)\
\009\009\009if scrolly + i == y then\
\009\009\009\009if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorError])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineNumbersHighlight]) end\
\009\009\009elseif scrolly + i == liveErr.line then\
\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009else term.setBackgroundColor(colors[theme.editorLineNumbers]) end\
\009\009\009term.write(ln)\
\009\009end\
\009end\
\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function drawLine(...)\
\009local ls = {...}\
\009offx = tostring(#lines):len() + 1\
\009for _, ly in pairs(ls) do\
\009\009local a = lines[ly]\
\009\009if a then\
\009\009\009local ln = string.rep(\" \", offx - 1 - tostring(ly):len()) .. tostring(ly) \
\009\009\009local l = a:sub(scrollx + 1, edw + scrollx + 1)\
\009\009\009ln = ln .. \":\"\
\
\009\009\009if liveErr.line == ly then ln = string.rep(\" \", offx - 2) .. \"!:\" end\
\
\009\009\009term.setCursorPos(1, (ly - scrolly) + offy)\
\009\009\009term.setBackgroundColor(colors[theme.editorBackground])\
\009\009\009if ly == y then\
\009\009\009\009if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
\009\009\009elseif ly == liveErr.line then\
\009\009\009\009term.setBackgroundColor(colors[theme.editorError])\
\009\009\009end\
\009\009\009term.clearLine()\
\
\009\009\009term.setCursorPos(1 - scrollx + offx, (ly - scrolly) + offy)\
\009\009\009if ly == y then\
\009\009\009\009if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
\009\009\009elseif ly == liveErr.line then term.setBackgroundColor(colors[theme.editorError])\
\009\009\009else term.setBackgroundColor(colors[theme.editorBackground]) end\
\009\009\009if ly == liveErr.line then\
\009\009\009\009if displayCode then term.write(a)\
\009\009\009\009else term.write(liveErr.display) end\
\009\009\009else writeHighlighted(a) end\
\
\009\009\009term.setCursorPos(1, (ly - scrolly) + offy)\
\009\009\009if ly == y then\
\009\009\009\009if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
\009\009\009\009\009term.setBackgroundColor(colors[theme.editorError])\
\009\009\009\009else term.setBackgroundColor(colors[theme.editorLineNumbersHighlight]) end\
\009\009\009elseif ly == liveErr.line then\
\009\009\009\009term.setBackgroundColor(colors[theme.editorErrorHighlight])\
\009\009\009else term.setBackgroundColor(colors[theme.editorLineNumbers]) end\
\009\009\009term.write(ln)\
\009\009end\
\009end\
\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function cursorLoc(x, y, force)\
\009local sx, sy = x - scrollx, y - scrolly\
\009local redraw = false\
\009if sx < 1 then\
\009\009scrollx = x - 1\
\009\009sx = 1\
\009\009redraw = true\
\009elseif sx > edw then\
\009\009scrollx = x - edw\
\009\009sx = edw\
\009\009redraw = true\
\009end if sy < 1 then\
\009\009scrolly = y - 1\
\009\009sy = 1\
\009\009redraw = true\
\009elseif sy > edh then\
\009\009scrolly = y - edh\
\009\009sy = edh\
\009\009redraw = true\
\009end if redraw or force then draw() end\
\009term.setCursorPos(sx + offx, sy + offy)\
end\
\
local function executeMenuItem(a, path)\
\009if type(a) == \"string\" and menuFunctions[a] then\
\009\009local opt, nl, gtln = menuFunctions[a](path, lines, y)\
\009\009if type(opt) == \"string\" then term.setCursorBlink(false) return opt end\
\009\009if type(nl) == \"table\" then\
\009\009\009if #lines < 1 then table.insert(lines, \"\") end\
\009\009\009y = math.min(y, #lines)\
\009\009\009x = math.min(x, lines[y]:len() + 1)\
\009\009\009lines = nl\
\009\009elseif type(nl) == \"string\" then\
\009\009\009if nl == \"go to\" and gtln then\
\009\009\009\009x, y = 1, math.min(#lines, gtln)\
\009\009\009\009cursorLoc(x, y)\
\009\009\009end\
\009\009end\
\009end\
\009term.setCursorBlink(true)\
\009draw()\
\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function edit(path)\
\009-- Variables\
\009x, y = 1, 1\
\009offx, offy = 0, 1\
\009scrollx, scrolly = 0, 0\
\009lines = loadFile(path)\
\009if not lines then return \"menu\" end\
\
\009-- Enable brainfuck\
\009if lines[1] == \"-- Syntax: Brainfuck\" then\
\009\009curLanguage = languages.brainfuck\
\009end\
\
\009-- Clocks\
\009local autosaveClock = os.clock()\
\009local scrollClock = os.clock() -- To prevent redraw flicker\
\009local liveErrorClock = os.clock()\
\009local hasScrolled = false\
\
\009-- Draw\
\009draw()\
\009term.setCursorPos(x + offx, y + offy)\
\009term.setCursorBlink(true)\
\009\
\009-- Main loop\
\009local tid = os.startTimer(3)\
\009while true do\
\009\009local e, key, cx, cy = os.pullEvent()\
\009\009if e == \"key\" and allowEditorEvent then\
\009\009\009if key == 200 and y > 1 then\
\009\009\009\009-- Up\
\009\009\009\009x, y = math.min(x, lines[y - 1]:len() + 1), y - 1\
\009\009\009\009drawLine(y, y + 1)\
\009\009\009\009cursorLoc(x, y)\
\009\009\009elseif key == 208 and y < #lines then\
\009\009\009\009-- Down\
\009\009\009\009x, y = math.min(x, lines[y + 1]:len() + 1), y + 1\
\009\009\009\009drawLine(y, y - 1)\
\009\009\009\009cursorLoc(x, y)\
\009\009\009elseif key == 203 and x > 1 then\
\009\009\009\009-- Left\
\009\009\009\009x = x - 1\
\009\009\009\009local force = false\
\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009cursorLoc(x, y, force)\
\009\009\009elseif key == 205 and x < lines[y]:len() + 1 then\
\009\009\009\009-- Right\
\009\009\009\009x = x + 1\
\009\009\009\009local force = false\
\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009cursorLoc(x, y, force)\
\009\009\009elseif (key == 28 or key == 156) and (displayCode and true or y + scrolly - 1 ==\
\009\009\009\009\009liveErr.line) then\
\009\009\009\009-- Enter\
\009\009\009\009local f = nil\
\009\009\009\009for _, v in pairs(standardsCompletions) do\
\009\009\009\009\009if lines[y]:find(v) then f = v end\
\009\009\009\009end\
\
\009\009\009\009local _, spaces = lines[y]:find(\"^[ ]+\")\
\009\009\009\009if not spaces then spaces = 0 end\
\009\009\009\009if f then\
\009\009\009\009\009table.insert(lines, y + 1, string.rep(\" \", spaces + 2))\
\009\009\009\009\009if not f:find(\"else\", 1, true) and not f:find(\"elseif\", 1, true) then\
\009\009\009\009\009\009table.insert(lines, y + 2, string.rep(\" \", spaces) .. \
\009\009\009\009\009\009\009(f:find(\"repeat\", 1, true) and \"until \" or f:find(\"{\", 1, true) and \"}\" or \
\009\009\009\009\009\009\009\"end\"))\
\009\009\009\009\009end\
\009\009\009\009\009x, y = spaces + 3, y + 1\
\009\009\009\009\009cursorLoc(x, y, true)\
\009\009\009\009else\
\009\009\009\009\009local oldLine = lines[y]\
\
\009\009\009\009\009lines[y] = lines[y]:sub(1, x - 1)\
\009\009\009\009\009table.insert(lines, y + 1, string.rep(\" \", spaces) .. oldLine:sub(x, -1))\
\
\009\009\009\009\009x, y = spaces + 1, y + 1\
\009\009\009\009\009cursorLoc(x, y, true)\
\009\009\009\009end\
\009\009\009elseif key == 14 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
\009\009\009\009-- Backspace\
\009\009\009\009if x > 1 then\
\009\009\009\009\009local f = false\
\009\009\009\009\009for k, v in pairs(liveCompletions) do\
\009\009\009\009\009\009if lines[y]:sub(x - 1, x - 1) == k then f = true end\
\009\009\009\009\009end\
\
\009\009\009\009\009lines[y] = lines[y]:sub(1, x - 2) .. lines[y]:sub(x + (f and 1 or 0), -1)\
\009\009\009\009\009drawLine(y)\
\009\009\009\009\009x = x - 1\
\009\009\009\009\009cursorLoc(x, y)\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009local prevLen = lines[y - 1]:len() + 1\
\009\009\009\009\009lines[y - 1] = lines[y - 1] .. lines[y]\
\009\009\009\009\009table.remove(lines, y)\
\009\009\009\009\009x, y = prevLen, y - 1\
\009\009\009\009\009cursorLoc(x, y, true)\
\009\009\009\009end\
\009\009\009elseif key == 199 then\
\009\009\009\009-- Home\
\009\009\009\009x = 1\
\009\009\009\009local force = false\
\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009cursorLoc(x, y, force)\
\009\009\009elseif key == 207 then\
\009\009\009\009-- End\
\009\009\009\009x = lines[y]:len() + 1\
\009\009\009\009local force = false\
\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009cursorLoc(x, y, force)\
\009\009\009elseif key == 211 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
\009\009\009\009-- Forward Delete\
\009\009\009\009if x < lines[y]:len() + 1 then\
\009\009\009\009\009lines[y] = lines[y]:sub(1, x - 1) .. lines[y]:sub(x + 1)\
\009\009\009\009\009local force = false\
\009\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009\009drawLine(y)\
\009\009\009\009\009cursorLoc(x, y, force)\
\009\009\009\009elseif y < #lines then\
\009\009\009\009\009lines[y] = lines[y] .. lines[y + 1]\
\009\009\009\009\009table.remove(lines, y + 1)\
\009\009\009\009\009draw()\
\009\009\009\009\009cursorLoc(x, y)\
\009\009\009\009end\
\009\009\009elseif key == 15 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
\009\009\009\009-- Tab\
\009\009\009\009lines[y] = string.rep(\" \", tabWidth) .. lines[y]\
\009\009\009\009x = x + 2\
\009\009\009\009local force = false\
\009\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009\009drawLine(y)\
\009\009\009\009cursorLoc(x, y, force)\
\009\009\009elseif key == 201 then\
\009\009\009\009-- Page up\
\009\009\009\009y = math.min(math.max(y - edh, 1), #lines)\
\009\009\009\009x = math.min(lines[y]:len() + 1, x)\
\009\009\009\009cursorLoc(x, y, true)\
\009\009\009elseif key == 209 then\
\009\009\009\009-- Page down\
\009\009\009\009y = math.min(math.max(y + edh, 1), #lines)\
\009\009\009\009x = math.min(lines[y]:len() + 1, x)\
\009\009\009\009cursorLoc(x, y, true)\
\009\009\009end\
\009\009elseif e == \"char\" and allowEditorEvent and (displayCode and true or \
\009\009\009\009y + scrolly - 1 == liveErr.line) then\
\009\009\009local shouldIgnore = false\
\009\009\009for k, v in pairs(liveCompletions) do\
\009\009\009\009if key == v and lines[y]:find(k, 1, true) and lines[y]:sub(x, x) == v then\
\009\009\009\009\009shouldIgnore = true\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009local addOne = false\
\009\009\009if not shouldIgnore then\
\009\009\009\009for k, v in pairs(liveCompletions) do\
\009\009\009\009\009if key == k and lines[y]:sub(x, x) ~= k then key = key .. v addOne = true end\
\009\009\009\009end\
\009\009\009\009lines[y] = lines[y]:sub(1, x - 1) .. key .. lines[y]:sub(x, -1)\
\009\009\009end\
\
\009\009\009x = x + (addOne and 1 or key:len())\
\009\009\009local force = false\
\009\009\009if y - scrolly + offy < offy + 1 then force = true end\
\009\009\009drawLine(y)\
\009\009\009cursorLoc(x, y, force)\
\009\009elseif e == \"mouse_click\" and key == 1 then\
\009\009\009if cy > 1 then\
\009\009\009\009if cx <= offx and cy - offy == liveErr.line - scrolly then\
\009\009\009\009\009displayCode = not displayCode\
\009\009\009\009\009drawLine(liveErr.line)\
\009\009\009\009else\
\009\009\009\009\009local oldy = y\
\009\009\009\009\009y = math.min(math.max(scrolly + cy - offy, 1), #lines)\
\009\009\009\009\009x = math.min(math.max(scrollx + cx - offx, 1), lines[y]:len() + 1)\
\009\009\009\009\009if oldy ~= y then drawLine(oldy, y) end\
\009\009\009\009\009cursorLoc(x, y)\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009local a = triggerMenu(cx, cy)\
\009\009\009\009if a then\
\009\009\009\009\009local opt = executeMenuItem(a, path)\
\009\009\009\009\009if opt then return opt end\
\009\009\009\009end\
\009\009\009end\
\009\009elseif e == \"shortcut\" then\
\009\009\009local a = shortcuts[key .. \" \" .. cx]\
\009\009\009if a then\
\009\009\009\009local parent = nil\
\009\009\009\009local curx = 0\
\009\009\009\009for i, mv in ipairs(menu) do\
\009\009\009\009\009for _, iv in pairs(mv) do\
\009\009\009\009\009\009if iv == a then\
\009\009\009\009\009\009\009parent = menu[i][1]\
\009\009\009\009\009\009\009break\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009if parent then break end\
\009\009\009\009\009curx = curx + mv[1]:len() + 3\
\009\009\009\009end\
\009\009\009\009local menux = curx + 2\
\
\009\009\009\009-- Flash menu item\
\009\009\009\009term.setCursorBlink(false)\
\009\009\009\009term.setCursorPos(menux, 1)\
\009\009\009\009term.setBackgroundColor(colors[theme.background])\
\009\009\009\009term.write(string.rep(\" \", parent:len() + 2))\
\009\009\009\009term.setCursorPos(menux + 1, 1)\
\009\009\009\009term.write(parent)\
\009\009\009\009sleep(0.1)\
\009\009\009\009drawMenu()\
\
\009\009\009\009-- Execute item\
\009\009\009\009local opt = executeMenuItem(a, path)\
\009\009\009\009if opt then return opt end\
\009\009\009end\
\009\009elseif e == \"mouse_scroll\" then\
\009\009\009if key == -1 and scrolly > 0 then\
\009\009\009\009scrolly = scrolly - 1\
\009\009\009\009if os.clock() - scrollClock > 0.0005 then\
\009\009\009\009\009draw()\
\009\009\009\009\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
\009\009\009\009end\
\009\009\009\009scrollClock = os.clock()\
\009\009\009\009hasScrolled = true\
\009\009\009elseif key == 1 and scrolly < #lines - edh then\
\009\009\009\009scrolly = scrolly + 1\
\009\009\009\009if os.clock() - scrollClock > 0.0005 then\
\009\009\009\009\009draw()\
\009\009\009\009\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
\009\009\009\009end\
\009\009\009\009scrollClock = os.clock()\
\009\009\009\009hasScrolled = true\
\009\009\009end\
\009\009elseif e == \"timer\" and key == tid then\
\009\009\009drawLine(y)\
\009\009\009tid = os.startTimer(3)\
\009\009end\
\
\009\009-- Draw\
\009\009if hasScrolled and os.clock() - scrollClock > 0.1 then\
\009\009\009draw()\
\009\009\009term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
\009\009\009hasScrolled = false\
\009\009end\
\
\009\009-- Autosave\
\009\009if os.clock() - autosaveClock > autosaveInterval then\
\009\009\009saveFile(path, lines)\
\009\009\009autosaveClock = os.clock()\
\009\009end\
\
\009\009-- Errors\
\009\009if os.clock() - liveErrorClock > 1 then\
\009\009\009local prevLiveErr = liveErr\
\009\009\009liveErr = curLanguage.parseError(nil)\
\009\009\009local code = \"\"\
\009\009\009for _, v in pairs(lines) do code = code .. v .. \"\\n\" end\
\
\009\009\009liveErr = curLanguage.getCompilerErrors(code)\
\009\009\009liveErr.line = math.min(liveErr.line - 2, #lines)\
\009\009\009if liveErr ~= prevLiveErr then draw() end\
\009\009\009liveErrorClock = os.clock()\
\009\009end\
\009end\
\
\009return \"menu\"\
end\
\
\
--  -------- Open File\
\
local function newFile()\
\009local wid = w - 13\
\
\009-- Get name\
\009title(\"Lua IDE - New File\")\
\009local name = centerRead(wid, \"/\")\
\009if not name or name == \"\" then return \"menu\" end\
\009name = \"/\" .. name\
\
\009-- Clear\
\009title(\"Lua IDE - New File\")\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.promptHighlight])\
\009for i = 8, 10 do\
\009\009term.setCursorPos(w/2 - wid/2, i)\
\009\009term.write(string.rep(\" \", wid))\
\009end\
\009term.setCursorPos(1, 9)\
\009if fs.isDir(name) then\
\009\009centerPrint(\"Cannot Edit a Directory!\")\
\009\009sleep(1.6)\
\009\009return \"menu\"\
\009elseif fs.exists(name) then\
\009\009centerPrint(\"File Already Exists!\")\
\009\009local opt = prompt({{\"Open\", w/2 - 9, 14}, {\"Cancel\", w/2 + 2, 14}}, \"horizontal\")\
\009\009if opt == \"Open\" then return \"edit\", name\
\009\009elseif opt == \"Cancel\" then return \"menu\" end\
\009else return \"edit\", name end\
end\
\
local function openFile()\
\009local wid = w - 13\
\
\009-- Get name\
\009title(\"Lua IDE - Open File\")\
\009local name = centerRead(wid, \"/\")\
\009if not name or name == \"\" then return \"menu\" end\
\009name = \"/\" .. name\
\
\009-- Clear\
\009title(\"Lua IDE - New File\")\
\009term.setTextColor(colors[theme.textColor])\
\009term.setBackgroundColor(colors[theme.promptHighlight])\
\009for i = 8, 10 do\
\009\009term.setCursorPos(w/2 - wid/2, i)\
\009\009term.write(string.rep(\" \", wid))\
\009end\
\009term.setCursorPos(1, 9)\
\009if fs.isDir(name) then\
\009\009centerPrint(\"Cannot Open a Directory!\")\
\009\009sleep(1.6)\
\009\009return \"menu\"\
\009elseif not fs.exists(name) then\
\009\009centerPrint(\"File Doesn't Exist!\")\
\009\009local opt = prompt({{\"Create\", w/2 - 11, 14}, {\"Cancel\", w/2 + 2, 14}}, \"horizontal\")\
\009\009if opt == \"Create\" then return \"edit\", name\
\009\009elseif opt == \"Cancel\" then return \"menu\" end\
\009else return \"edit\", name end\
end\
\
\
--  -------- Settings\
\
local function update()\
\009local function draw(status)\
\009\009title(\"LuaIDE - Update\")\
\009\009term.setBackgroundColor(colors[theme.prompt])\
\009\009term.setTextColor(colors[theme.textColor])\
\009\009for i = 8, 10 do\
\009\009\009term.setCursorPos(w/2 - (status:len() + 4), i)\
\009\009\009write(string.rep(\" \", status:len() + 4))\
\009\009end\
\009\009term.setCursorPos(w/2 - (status:len() + 4), 9)\
\009\009term.write(\" - \" .. status .. \" \")\
\
\009\009term.setBackgroundColor(colors[theme.errHighlight])\
\009\009for i = 8, 10 do\
\009\009\009term.setCursorPos(w/2 + 2, i)\
\009\009\009term.write(string.rep(\" \", 10))\
\009\009end\
\009\009term.setCursorPos(w/2 + 2, 9)\
\009\009term.write(\" > Cancel \")\
\009end\
\
\009if not http then\
\009\009draw(\"HTTP API Disabled!\")\
\009\009sleep(1.6)\
\009\009return \"settings\"\
\009end\
\
\009draw(\"Updating...\")\
\009local tID = os.startTimer(10)\
\009http.request(updateURL)\
\009while true do\
\009\009local e, but, x, y = os.pullEvent()\
\009\009if (e == \"key\" and but == 28) or\
\009\009\009\009(e == \"mouse_click\" and x >= w/2 + 2 and x <= w/2 + 12 and y == 9) then\
\009\009\009draw(\"Cancelled\")\
\009\009\009sleep(1.6)\
\009\009\009break\
\009\009elseif e == \"http_success\" and but == updateURL then\
\009\009\009local new = x.readAll()\
\009\009\009local curf = io.open(ideLocation, \"r\")\
\009\009\009local cur = curf:read(\"*a\")\
\009\009\009curf:close()\
\
\009\009\009if cur ~= new then\
\009\009\009\009draw(\"Update Found\")\
\009\009\009\009sleep(1.6)\
\009\009\009\009local f = io.open(ideLocation, \"w\")\
\009\009\009\009f:write(new)\
\009\009\009\009f:close()\
\
\009\009\009\009draw(\"Click to Exit\")\
\009\009\009\009while true do\
\009\009\009\009\009local e = os.pullEvent()\
\009\009\009\009\009if e == \"mouse_click\" or (not isAdvanced() and e == \"key\") then break end\
\009\009\009\009end\
\009\009\009\009return \"exit\"\
\009\009\009else\
\009\009\009\009draw(\"No Updates Found!\")\
\009\009\009\009sleep(1.6)\
\009\009\009\009break\
\009\009\009end\
\009\009elseif e == \"http_failure\" or (e == \"timer\" and but == tID) then\
\009\009\009draw(\"Update Failed!\")\
\009\009\009sleep(1.6)\
\009\009\009break\
\009\009end\
\009end\
\
\009return \"settings\"\
end\
\
local function changeTheme()\
\009title(\"LuaIDE - Theme\")\
\
\009if isAdvanced() then\
\009\009local disThemes = {\"Back\"}\
\009\009for _, v in pairs(availableThemes) do table.insert(disThemes, v[1]) end\
\009\009local t = scrollingPrompt(disThemes)\
\009\009local url = nil\
\009\009for _, v in pairs(availableThemes) do if v[1] == t then url = v[2] end end\
\
\009\009if not url then return \"settings\" end\
\009\009if t == \"Dawn (Default)\" then\
\009\009\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009\009\009term.setCursorPos(3, 3)\
\009\009\009term.clearLine()\
\009\009\009term.write(\"LuaIDE - Loaded Theme!\")\
\009\009\009sleep(1.6)\
\
\009\009\009fs.delete(themeLocation)\
\009\009\009theme = defaultTheme\
\009\009\009return \"menu\"\
\009\009end\
\
\009\009term.setBackgroundColor(colors[theme.backgroundHighlight])\
\009\009term.setCursorPos(3, 3)\
\009\009term.clearLine()\
\009\009term.write(\"LuaIDE - Downloading...\")\
\
\009\009fs.delete(\"/.LuaIDE_temp_theme_file\")\
\009\009download(url, \"/.LuaIDE_temp_theme_file\")\
\009\009local a = loadTheme(\"/.LuaIDE_temp_theme_file\")\
\
\009\009term.setCursorPos(3, 3)\
\009\009term.clearLine()\
\009\009if a then\
\009\009\009term.write(\"LuaIDE - Loaded Theme!\")\
\009\009\009fs.delete(themeLocation)\
\009\009\009fs.move(\"/.LuaIDE_temp_theme_file\", themeLocation)\
\009\009\009theme = a\
\009\009\009sleep(1.6)\
\009\009\009return \"menu\"\
\009\009end\
\009\009\
\009\009term.write(\"LuaIDE - Could Not Load Theme!\")\
\009\009fs.delete(\"/.LuaIDE_temp_theme_file\")\
\009\009sleep(1.6)\
\009\009return \"settings\"\
\009else\
\009\009term.setCursorPos(1, 8)\
\009\009centerPrint(\"Themes are not available on\")\
\009\009centerPrint(\"normal computers!\")\
\009end\
end\
\
local function settings()\
\009title(\"LuaIDE - Settings\")\
\
\009local opt = prompt({{\"Change Theme\", w/2 - 17, 8}, {\"Return to Menu\", w/2 - 22, 13},\
\009\009{\"Check for Updates\", w/2 + 2, 8}, {\"Exit IDE\", w/2 + 2, 13, bg = colors[theme.err], \
\009\009highlight = colors[theme.errHighlight]}}, \"vertical\", true)\
\009if opt == \"Change Theme\" then return changeTheme()\
\009elseif opt == \"Check for Updates\" then return update()\
\009elseif opt == \"Return to Menu\" then return \"menu\"\
\009elseif opt == \"Exit IDE\" then return \"exit\" end\
end\
\
\
--  -------- Menu\
\
local function menu()\
\009title(\"Welcome to LuaIDE \" .. version)\
\
\009local opt = prompt({{\"New File\", w/2 - 13, 8}, {\"Open File\", w/2 - 14, 13},\
\009\009{\"Settings\", w/2 + 2, 8}, {\"Exit IDE\", w/2 + 2, 13, bg = colors[theme.err],\
\009\009highlight = colors[theme.errHighlight]}}, \"vertical\", true)\
\009if opt == \"New File\" then return \"new\"\
\009elseif opt == \"Open File\" then return \"open\"\
\009elseif opt == \"Settings\" then return \"settings\"\
\009elseif opt == \"Exit IDE\" then return \"exit\" end\
end\
\
\
--  -------- Main\
\
local function main(arguments)\
\009local opt, data = \"menu\", nil\
\
\009-- Check arguments\
\009if type(arguments) == \"table\" and #arguments > 0 then\
\009\009local f = \"/\" .. shell.resolve(arguments[1])\
\009\009if fs.isDir(f) then print(\"Cannot edit a directory.\") end\
\009\009opt, data = \"edit\", f\
\009end\
\
\009-- Main run loop\
\009while true do\
\009\009-- Menu\
\009\009if opt == \"menu\" then opt = menu() end\
\
\009\009-- Other\
\009\009if opt == \"new\" then opt, data = newFile()\
\009\009elseif opt == \"open\" then opt, data = openFile()\
\009\009elseif opt == \"settings\" then opt = settings()\
\009\009end if opt == \"exit\" then break end\
\
\009\009-- Edit\
\009\009if opt == \"edit\" and data then opt = edit(data) end\
\009end\
end\
\
-- Load Theme\
if fs.exists(themeLocation) then theme = loadTheme(themeLocation) end\
if not theme and isAdvanced() then theme = defaultTheme\
elseif not theme then theme = normalTheme end\
\
-- Run\
local _, err = pcall(function()\
\009parallel.waitForAny(function() main(args) end, monitorKeyboardShortcuts)\
end)\
\
-- Catch errors\
if err and not err:find(\"Terminated\") then\
\009term.setCursorBlink(false)\
\009title(\"LuaIDE - Crash! D:\")\
\
\009term.setBackgroundColor(colors[theme.err])\
\009for i = 6, 8 do\
\009\009term.setCursorPos(5, i)\
\009\009term.write(string.rep(\" \", 36))\
\009end\
\009term.setCursorPos(6, 7)\
\009term.write(\"LuaIDE Has Crashed! D:\")\
\
\009term.setBackgroundColor(colors[theme.background])\
\009term.setCursorPos(2, 10)\
\009print(err)\
\
\009term.setBackgroundColor(colors[theme.prompt])\
\009local _, cy = term.getCursorPos()\
\009for i = cy + 1, cy + 4 do\
\009\009term.setCursorPos(5, i)\
\009\009term.write(string.rep(\" \", 36))\
\009end\
\009term.setCursorPos(6, cy + 2)\
\009term.write(\"Please report this error to\")\
\009term.setCursorPos(6, cy + 3)\
\009term.write(\"GravityScore! \")\
\009\
\009term.setBackgroundColor(colors[theme.background])\
\009if isAdvanced() then centerPrint(\"Click to Exit...\", h - 1)\
\009else centerPrint(\"Press Any Key to Exit...\", h - 1) end\
\009while true do\
\009\009local e = os.pullEvent()\
\009\009if e == \"mouse_click\" or (not isAdvanced() and e == \"key\") then break end\
\009end\
\
\009-- Prevent key from being shown\
\009os.queueEvent(event_distract)\
\009os.pullEvent()\
end\
\
-- Exit\
term.setBackgroundColor(colors.black)\
term.setTextColor(colors.white)\
term.clear()\
term.setCursorPos(1, 1)\
centerPrint(\"Thank You for Using Lua IDE \" .. version)\
centerPrint(\"Made by GravityScore\")",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/packman\
\009CATEGORY:    Binary\
\009SET:         Extra Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION: \
\009\009This program manages repositories and their programs\
\009\009\
\009All credits to lyqyd.\
]]--\
\
\
if lib.perm.permission.check(\"/bin\") == \"x\" then\
\009printError(\"User is not root, aborting...\")\
\009return\
end\
\
package = {}\
\
\
list = {}\
installed = {}\
installRoot = \"/\"\
local unpack = unpack or table.unpack\
\
local function postStatus(type, text)\
\009os.queueEvent(\"package_status\", type, text)\
\009while true do\
\009\009local event = {os.pullEvent(\"package_status\")}\
\009\009if event[1] == \"package_status\" then break end\
\009end\
end\
\
local function printInformation(text)\
\009postStatus(\"info\", text)\
end\
\
local function printWarning(text)\
\009postStatus(\"warning\", text)\
end\
\
local function printError(text)\
\009postStatus(\"error\", text)\
end\
\
local function findFileEntry(fileList, path)\
\009local entryFound = false\
\009for i = 1, #fileList do\
\009\009if fileList[i].path == path then\
\009\009\009entryFound = i\
\009\009\009break\
\009\009end\
\009end\
\009return entryFound\
end\
\
local function updateFileInfo(fileList, path, version)\
\009local entry = findFileEntry(fileList, path)\
\009if entry then\
\009\009fileList[entry].path = path\
\009\009fileList[entry].version = version\
\009else\
\009\009table.insert(fileList, {path = path, version = version})\
\009end\
end\
\
local transactionQueue = {}\
local currentPackage\
\
local Transaction = {\
\009writeFile = function(self)\
\009\009local path = fs.combine(installRoot, self.path)\
\009\009if fs.exists(path) then\
\009\009\009local handle = io.open(path, \"r\")\
\009\009\009if handle then\
\009\009\009\009self.backup = handle:read(\"*a\")\
\009\009\009\009handle:close()\
\009\009\009end\
\009\009end\
\009\009local handle = io.open(path, \"w\")\
\009\009if handle then\
\009\009\009printInformation(\"Writing file \"..path)\
\009\009\009handle:write(self.contents)\
\009\009\009handle:close()\
\009\009else\
\009\009\009return false\
\009\009end\
\009\009return true\
\009end,\
\009deleteFile = function(self)\
\009\009local path = fs.combine(installRoot, self.path)\
\009\009if fs.exists(path) then\
\009\009\009local handle = io.open(path, \"r\")\
\009\009\009if handle then\
\009\009\009\009self.backup = handle:read(\"*a\")\
\009\009\009\009handle:close()\
\009\009\009end\
\009\009end\
\009\009printInformation(\"Deleting file \"..path)\
\009\009fs.delete(path)\
\009\009return not fs.exists(path)\
\009end,\
\009makeDirectory = function(self)\
\009\009local path = fs.combine(installRoot, self.path)\
\009\009if not fs.exists(path) then\
\009\009\009printInformation(\"Creating directory \"..path)\
\009\009\009fs.makeDir(path)\
\009\009end\
\009\009return fs.isDir(path)\
\009end,\
\009removeDirectory = function(self)\
\009\009local path = fs.combine(installRoot, self.path)\
\009\009if fs.exists(path) and fs.isDir(path) and #(fs.list(path)) == 0 then\
\009\009\009printInformation(\"Removing directory \"..path)\
\009\009\009fs.delete(path)\
\009\009end\
\009\009return not fs.exists(path)\
\009end,\
\009updateInfo = function(self)\
\009\009newLine = self.path..(self.version and \";\"..self.version or \"\")\
\009\009local lineFound = false\
\009\009for i = 1, #self.contents do\
\009\009\009if self.path == string.match(self.contents[i], \"^([^;]+)\") then\
\009\009\009\009--found the right entry, modify correctly now.\
\009\009\009\009lineFound = true\
\009\009\009\009self.contents[i] = newLine\
\009\009\009\009updateFileInfo(installed[self.pack.fullName].files, self.path, self.version)\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009if not lineFound and newLine then\
\009\009\009--didn't find a matching line in the loop, add a new line at the end.\
\009\009\009table.insert(self.contents, newLine)\
\009\009end\
\009end,\
\009removeInfo = function(self)\
\009\009for i = 1, #self.contents do\
\009\009\009if self.path == string.match(self.contents[i], \"^([^;]+)\") then\
\009\009\009\009table.remove(self.contents, i)\
\009\009\009\009local entry = findFileEntry(installed[self.pack.fullName].files, self.path)\
\009\009\009\009if entry then\
\009\009\009\009\009table.remove(installed[self.pack.fullName].files, entry)\
\009\009\009\009end\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009end,\
}\
\
function Transaction.finish(self)\
\009if Transaction[self.type] then\
\009\009return Transaction[self.type](self)\
\009else\
\009\009return false\
\009end\
end\
\
function Transaction.rollback(self)\
\009if Transaction[self.type] then\
\009\009if self.type == \"writeFile\" then\
\009\009\009if self.backup ~= nil then\
\009\009\009\009self.contents = self.backup\
\009\009\009\009return Transaction.writeFile(self)\
\009\009\009else\
\009\009\009\009return Transaction.deleteFile(self)\
\009\009\009end\
\009\009elseif self.type == \"deleteFile\" then\
\009\009\009if self.backup ~= nil then\
\009\009\009\009self.contents = self.backup\
\009\009\009\009return Transaction.writeFile(self)\
\009\009\009end\
\009\009elseif self.type == \"makeDirectory\" then\
\009\009\009return Transaction.removeDirectory(self)\
\009\009elseif self.type == \"removeDirectory\" then\
\009\009\009return Transaction.makeDirectory(self)\
\009\009end\
\009else\
\009\009return false\
\009end\
end\
\
local tmeta = {__index = Transaction}\
\
local function newTransaction(pack, path, type, contents, version)\
\009local transaction = {\
\009\009pack = pack,\
\009\009path = path,\
\009\009type = type,\
\009\009contents = contents,\
\009\009version = version,\
\009\009backup = nil,\
\009}\
\
\009setmetatable(transaction, tmeta)\
\
\009return transaction\
end\
\
local TransQueue = {\
\009addFile = function(self, path, contents, version)\
\009\009table.insert(self.transactions, newTransaction(self.pack, path, \"writeFile\", contents, version))\
\009end,\
\009removeFile = function(self, path)\
\009\009table.insert(self.transactions, newTransaction(self.pack, path, \"deleteFile\"))\
\009end,\
\009makeDir = function(self, path)\
\009\009if string.match(path, \"(.-)/[^/]+$\") and not fs.exists(fs.combine(installRoot, string.match(path, \"(.-)/[^/]+$\"))) then\
\009\009\009self:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009\009end\
\009\009if not fs.exists(fs.combine(installRoot, path)) then\
\009\009\009table.insert(self.transactions, newTransaction(self.pack, path, \"makeDirectory\"))\
\009\009end\
\009end,\
\009removeDir = function(self, path)\
\009\009table.insert(self.transactions, newTransaction(self.pack, path, \"removeDirectory\"))\
\009end,\
\009env = function(self)\
\009\009return {\
\009\009\009addFile = function(path, contents, version)\
\009\009\009\009self:addFile(path, contents, version)\
\009\009\009end,\
\009\009\009removeFile = function(path)\
\009\009\009\009self:removeFile(path)\
\009\009\009end,\
\009\009\009makeDir = function(path)\
\009\009\009\009self:makeDir(path)\
\009\009\009end,\
\009\009\009removeDir = function(path)\
\009\009\009\009self:removeDir(path)\
\009\009\009end,\
\009\009}\
\009end,\
\009finish = function(self)\
\009\009local installedFile = fs.combine(fs.combine(installRoot, \"/etc/.installed\"), self.pack.fullName)\
\009\009local installedData = {}\
\009\009if installed[self.pack.fullName] and fs.exists(installedFile) then\
\009\009\009local handle = io.open(installedFile, \"r\")\
\009\009\009if handle then\
\009\009\009\009for line in handle:lines() do\
\009\009\009\009\009table.insert(installedData, line)\
\009\009\009\009end\
\009\009\009\009handle:close()\
\
\009\009\009\009--strip version number if present\
\009\009\009\009if #installedData >= 1 then\
\009\009\009\009\009table.remove(installedData, 1)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009\009--ensure installed table entry exists\
\009\009if not installed[self.pack.fullName] then\
\009\009\009installed[self.pack.fullName] = {\
\009\009\009\009version = self.pack.version,\
\009\009\009\009files = {},\
\009\009\009}\
\009\009\009if not installed[self.pack.name] then installed[self.pack.name] = {[self.pack.repo] = installed[self.pack.fullName]} end\
\009\009end\
\
\009\009local fileInfoUpdates = {}\
\
\009\009local lastTransaction = false\
\
\009\009for i = 1, #self.transactions do\
\009\009\009if not self.transactions[i]:finish() then\
\009\009\009\009--clean up already-processed transactions and exit\
\009\009\009\009printWarning(\"Transaction failed! Rolling back...\")\
\009\009\009\009for j = i, 1, -1 do\
\009\009\009\009\009self.transactions[i]:rollback()\
\009\009\009\009\009return false\
\009\009\009\009end\
\009\009\009end\
\009\009\009--construct new line (or nil to remove entry, if present)\
\009\009\009local newLine\
\009\009\009if self.transactions[i].type == \"writeFile\" then\
\009\009\009\009table.insert(fileInfoUpdates, newTransaction(self.pack, self.transactions[i].path, \"updateInfo\", installedData, self.transactions[i].version))\
\009\009\009elseif self.transactions[i].type == \"makeDirectory\" then\
\009\009\009\009table.insert(fileInfoUpdates, newTransaction(self.pack, self.transactions[i].path, \"updateInfo\", installedData))\
\009\009\009elseif self.transactions[i].type == \"deleteFile\" or self.transactions[i].type == \"removeDirectory\" then\
\009\009\009\009table.insert(fileInfoUpdates, newTransaction(self.pack, self.transactions[i].path, \"removeInfo\", installedData))\
\009\009\009end\
\009\009end\
\
\009\009--modify installed data to match the transactions succesfully executed.\
\009\009printInformation(\"Updating Database\")\
\009\009for i = 1, #fileInfoUpdates do\
\009\009\009fileInfoUpdates[i]:finish()\
\009\009end\
\
\009\009if self.removing and #installedData == 0 then\
\009\009\009fs.delete(installedFile)\
\
\009\009\009--remove entries from installed packages table if removing \
\009\009\009installed[self.pack.name][self.pack.repo] = nil\
\009\009\009local othersWithName = false\
\009\009\009for k, v in pairs(installed[self.pack.name]) do\
\009\009\009\009if v then\
\009\009\009\009\009othersWithName = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009\009if not othersWithName then\
\009\009\009\009installed[self.pack.name] = nil\
\009\009\009end\
\009\009\009installed[self.pack.fullName] = nil\
\009\009else\
\009\009\009--write out file again, if any content exists for it.\
\009\009\009table.insert(installedData, 1, tostring(self.pack.version))\
\009\009\009if not fs.exists(fs.combine(fs.combine(installRoot, \"/etc/.installed\"), self.pack.repo)) then fs.makeDir(fs.combine(fs.combine(installRoot, \"/etc/.installed\"), self.pack.repo)) end\
\009\009\009local handle = io.open(installedFile, \"w\")\
\009\009\009if handle then\
\009\009\009\009for k, v in ipairs(installedData) do\
\009\009\009\009\009handle:write(v..\"\\n\")\
\009\009\009\009end\
\009\009\009\009handle:close()\
\009\009\009end\
\009\009end\
\009\009return true\
\009end,\
}\
\
local queueMeta = {__index = TransQueue}\
\
function newTransactionQueue(packName, removing)\
\009local pack\
\009if list[packName] and list[packName].version then pack = list[packName] else return nil, \"No such package!\" end\
\009local queue = {\
\009\009pack = pack,\
\009\009removing = removing,\
\009\009transactions = {},\
\009}\
\
\009setmetatable(queue, queueMeta)\
\
\009return queue\
end\
\
local downloadTypes = {\
\009github = {\
\009\009author = true,\
\009\009repository = true,\
\009\009branch = true,\
\009},\
\009bitbucket = {\
\009\009author = true,\
\009\009repository = true,\
\009\009branch = true,\
\009},\
\009pastebin = {\
\009\009url = true,\
\009\009filename = true,\
\009},\
\009raw = {\
\009\009url = true,\
\009\009filename = true,\
\009},\
\009multi = {},\
\009grin = {\
\009\009author = true,\
\009\009repository = true,\
\009},\
\009meta = {},\
}\
\
local updateTypes = {\
\009github = \"incremental\",\
\009bitbucket = \"incremental\",\
\009grin = \"replace\",\
\009raw = \"overwrite\",\
\009multi = \"overwrite\",\
\009pastebin = \"overwrite\",\
\009meta = \"overwrite\",\
}\
\
local lookupFunctions = {}\
\
lookupFunctions.github = function(package)\
\009local function getDirectoryContents(path)\
\009\009local fType, fPath, fVer = {}, {}, {}\
\009\009local response = http.get(\"https://api.github.com/repos/\"..download.author..\"/\"..download.repository..\"/contents/\"..path..\"?ref=\"..download.branch)\
\009\009if response then\
\009\009\009response = response.readAll()\
\009\009\009if response ~= nil then\
\009\009\009\009for str in response:gmatch('\"type\":%s*\"(%w+)\",') do table.insert(fType, str) end\
\009\009\009\009for str in response:gmatch('\"path\":%s*\"([^\\\"]+)\",') do table.insert(fPath, str) end\
\009\009\009\009for str in response:gmatch('\"sha\":%s*\"([^\\\"]+)\",') do table.insert(fVer, str) end\
\009\009\009end\
\009\009else\
\009\009\009printWarning(\"Can't fetch repository information\")\
\009\009\009return nil\
\009\009end\
\009\009local directoryContents = {}\
\009\009for i=1, #fType do\
\009\009\009directoryContents[i] = {type = fType[i], path = fPath[i], version = fVer[i]}\
\009\009end\
\009\009return directoryContents\
\009end\
\009local function addDirectoryContents(path, contentsTable)\
\009\009local contents = getDirectoryContents(path)\
\009\009if not contents then return nil, \"no contents\" end\
\009\009for n, file in ipairs(contents) do\
\009\009\009if file.type == \"dir\" then\
\009\009\009\009addDirectoryContents(file.path, contentsTable)\
\009\009\009else\
\009\009\009\009table.insert(contentsTable, {path = file.path, version = file.version})\
\009\009\009end\
\009\009end\
\009\009return contentsTable\
\009end\
\009return addDirectoryContents(\"\", {})\
end\
\
lookupFunctions.bitbucket = function(package)\
\009local function getDirectoryContents(path)\
\009\009local directoryContents = {}\
\009\009local response = http.get(\"https://api.bitbucket.org/1.0/repositories/\"..download.author..\"/\"..download.repository..\"/src/\"..download.branch..path)\
\009\009if response then\
\009\009\009response = response.readAll()\
\009\009\009if response ~= nil then\
\009\009\009\009for str in string.gmatch(string.match(response, '\"directories\": %[(.-)%]'), '\"([^,\\\"]+)\"') do table.insert(directoryContents, {type = \"dir\", path = str}) end\
\009\009\009\009for str, ver in string.gmatch(string.match(response, '\"files\": %[(.-)%]'), '\"path\": \"([^\\\"]+)\".-\"revision\": \"([^\\\"]+)\"') do table.insert(directoryContents, {type = \"file\", path = str, version = ver}) end\
\009\009\009end\
\009\009else\
\009\009\009printWarning(\"Can't fetch repository information\")\
\009\009\009return nil\
\009\009end\
\009\009return directoryContents\
\009end\
\009local function addDirectoryContents(path, contentsTable)\
\009\009local contents = getDirectoryContents(path)\
\009\009for n, file in ipairs(contents) do\
\009\009\009if file.type == \"dir\" then\
\009\009\009\009addDirectoryContents(path..file.path..\"/\", contentsTable)\
\009\009\009else\
\009\009\009\009table.insert(contentsTable, {path = file.path, version = file.version})\
\009\009\009end\
\009\009end\
\009\009return contentsTable\
\009end\
\009return addDirectoryContents(\"/\", {})\
end\
\
-- Local function to download a url raw\
local function raw(url)\
\009printInformation(\"Fetching: \"..url)\
\009http.request(url)\
\009while true do\
\009\009local event = {os.pullEvent()}\
\009\009if event[1] == \"http_success\" then\
\009\009\009printInformation(\"Done!\")\
\009\009\009return event[3].readAll()\
\009\009elseif event[1] == \"http_failure\" then\
\009\009\009printWarning(\"Unable to fetch file \"..event[2])\
\009\009\009return false\
\009\009end\
\009end\
end\
\
local downloadFunctions = {}\
\
downloadFunctions.raw = function(pack, env, queue)\
\009-- Delegate to local raw\
\009local path = fs.combine(pack.target, pack.download.filename)\
\
\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009end\
\009local content = raw(pack.download.url)\
\009if content then\
\009\009queue:addFile(path, content)\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
\
downloadFunctions.multi = function(pack, env, queue)\
\009local files = pack.download.files\
\009for i = 1, #files do\
\009\009local path = fs.combine(pack.target, files[i].name)\
\
\009\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009\009end\
\009\009local content = raw(files[i].url)\
\009\009if content then\
\009\009\009queue:addFile(path, content)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
downloadFunctions.github = function(pack, env, queue)\
\009local contents = lookupFunctions.github(pack)\
\009if not contents then return nil, \"content fetch failure\" end\
\009local localTarget = pack.target or \"\"\
\009for num, file in ipairs(contents) do\
\009\009local path = fs.combine(localTarget, file.path)\
\009\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009\009end\
\009\009local content = raw(\"https://raw.github.com/\"..pack.download.author..\"/\"..pack.download.repository..\"/\"..pack.download.branch..\"/\"..file.path)\
\009\009if content then\
\009\009\009queue:addFile(path, content, file.version)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
downloadFunctions.bitbucket = function(pack, env, queue)\
\009local contents = lookupFunctions.bitbucket(pack)\
\009local localTarget = pack.target or \"\"\
\009for num, file in ipairs(contents) do\
\009\009local path = fs.combine(localTarget, file.path)\
\009\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009\009end\
\009\009local content = raw(\"https://bitbucket.org/\"..pack.download.author..\"/\"..pack.download.repository..\"/raw/\"..pack.download.branch..\"/\"..file.path)\
\009\009if content then\
\009\009\009queue:addFile(path, content, file.version)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
downloadFunctions.pastebin = function(pack, env, queue)\
\009local path = fs.combine(pack.target, pack.download.filename) \
\
\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009end\
\009local content = raw(\"http://pastebin.com/raw.php?i=\"..pack.download.url)\
\009if content then\
\009\009queue:addFile(path, content)\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
\
downloadFunctions.grin = function(pack, env, queue)\
\009local fullName = pack.repo..\"/\"..pack.name\
\009local status\
\009parallel.waitForAny(function()\
\009\009status = env.shell.run(\"pastebin run VuBNx3va -e -u\", pack.download.author, \"-r\", pack.download.repository, fs.combine(fs.combine(installRoot, pack.target), pack.name))\
\009end, function()\
\009\009while true do\
\009\009\009local e, msg = os.pullEvent(\"grin_install_status\")\
\009\009\009printInformation(msg)\
\009\009end\
\009end)\
\009return status\
end\
\
downloadFunctions.meta = function(pack, env, queue)\
\009return true\
end\
\
local function findInstalledVersionByPath(packName, path)\
\009for i, file in ipairs(installed[packName].files) do\
\009\009if file.path == path then return file.version end\
\009end\
end\
\
local new_fs = {}\
\
local Package = {\
\009install = function(self, env)\
\009\009local queue\
\009\009if downloadFunctions[self.download.type] then\
\009\009\009queue = newTransactionQueue(self.fullName)\
\009\009\009if not downloadFunctions[self.download.type](self, env, queue) then return false end\
\009\009else\
\009\009\009return false\
\009\009end\
\
\009\009if not queue:finish() then return false end\
\
\009\009--execute startup script, if present.\
\009\009if self.setup then\
\009\009\009local queue = newTransactionQueue(self.fullName)\
\009\009\009--packman key included solely for backwards compatibility, usage is deprecated in favor of pack.\
\009\009\009local setupArgs = {}\
\009\009\009for match in string.gmatch(self.setup, \"(%S+)\") do\
\009\009\009\009table.insert(setupArgs, match)\
\009\009\009end\
\009\009\009setupArgs[1] = fs.combine(fs.combine(installRoot, self.target), setupArgs[1])\
\009\009\009if not os.run({shell = env.shell, packman = queue:env(), pack = queue:env(), fs = new_fs}, unpack(setupArgs)) then\
\009\009\009\009--setup script threw an error.\
\009\009\009\009printWarning(\"Package \"..self.fullName..\" failed to install, removing\")\
\009\009\009\009return self:remove(env)\
\009\009\009end\
\
\009\009\009--this must be done a second time to finalize any changes made by the install script.\
\009\009\009return queue:finish()\
\009\009end\
\009\009return true\
\009end,\
\009remove = function(self, env)\
\009\009if not installed[self.fullName] then return false end\
\009\009local queue = newTransactionQueue(self.fullName, true)\
\
\009\009if self.cleanup then\
\009\009\009local queue = newTransactionQueue(self.fullName, true)\
\009\009\009local cleanupArgs = {}\
\009\009\009for match in string.gmatch(self.cleanup, \"(%S+)\") do\
\009\009\009\009table.insert(cleanupArgs, match)\
\009\009\009end\
\009\009\009cleanupArgs[1] = fs.combine(fs.combine(installRoot, self.target), cleanupArgs[1])\
\009\009\009os.run({shell = env.shell, packman = queue:env(), pack = queue:env(), fs = new_fs}, unpack(cleanupArgs))\
\009\009\009if not queue:finish() then return false end\
\009\009end\
\
\009\009local fileList = installed[self.fullName].files\
\009\009for i = #fileList, 1, -1 do\
\009\009\009if fs.exists(fs.combine(installRoot, fileList[i].path)) and fs.isDir(fs.combine(installRoot, fileList[i].path)) then\
\009\009\009\009queue:removeDir(fileList[i].path)\
\009\009\009else\
\009\009\009\009queue:removeFile(fileList[i].path)\
\009\009\009end\
\
\009\009end\
\
\009\009return queue:finish()\
\009end,\
\009upgrade = function(self, env)\
\009\009if not installed[self.fullName] then return false end\
\009\009local queue = newTransactionQueue(self.fullName)\
\009\009if updateTypes[self.download.type] == \"incremental\" then\
\009\009\009local updatedFiles = {}\
\009\009\009local contents = lookupFunctions[self.download.type](self)\
\009\009\009for num, file in ipairs(contents) do\
\009\009\009\009local path = fs.combine(self.target, file.path)\
\009\009\009\009if file.version ~= findInstalledVersionByPath(self.fullName, path) then\
\009\009\009\009\009if string.match(path, \"(.-)/[^/]+$\") then\
\009\009\009\009\009\009queue:makeDir(string.match(path, \"(.-)/[^/]+$\"))\
\009\009\009\009\009end\
\009\009\009\009\009if self.download.type == \"github\" then\
\009\009\009\009\009\009local content = raw(\"https://raw.github.com/\"..self.download.author..\"/\"..self.download.repository..\"/\"..self.download.branch..\"/\"..file.path)\
\009\009\009\009\009\009if content then\
\009\009\009\009\009\009\009queue:addFile(path, content, file.version)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009return false\
\009\009\009\009\009\009end\
\009\009\009\009\009elseif self.download.type == \"bitbucket\" then\
\009\009\009\009\009\009local content = raw(\"https://bitbucket.org/\"..self.download.author..\"/\"..self.download.repository..\"/raw/\"..self.download.branch..\"/\"..file.path)\
\009\009\009\009\009\009if content then\
\009\009\009\009\009\009\009queue:addFile(path, content, file.version)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009return false\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009updatedFiles[path] = true\
\009\009\009end\
\
\009\009\009for i, fileInfo in ipairs(installed[self.fullName].files) do\
\009\009\009\009if not updatedFiles[fileInfo.path] and fileInfo.version ~= installed[self.fullName].version then\
\009\009\009\009\009if not fs.isDir(fs.combine(installRoot, fileInfo.path)) or (fs.isDir(fs.combine(installRoot, fileInfo.path)) and #(fs.list(fs.combine(installRoot, fileInfo.path))) == 0) then\
\009\009\009\009\009\009queue:removeFile(fileInfo.path)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009\
\009\009\009return queue:finish()\
\009\009elseif updateTypes[self.download.type] == \"overwrite\" then\
\009\009\009if not downloadFunctions[self.download.type](self, env, queue) then return false end\
\009\009\009return queue:finish()\
\009\009elseif updateTypes[self.download.type] == \"replace\" then\
\009\009\009return self:remove(env) and self:install(env)\
\009\009end\
\009end,\
}\
\
local pmetatable = {__index = Package}\
\
function new(name, repo)\
\009local p = {\
\009\009name = name,\
\009\009repo = repo,\
\009\009fullName = repo..\"/\"..name,\
\009\009version = \"\",\
\009\009size = 0,\
\009\009category = {},\
\009\009dependencies = {},\
\009\009--installation folder target\
\009\009target = \"/bin\",\
\009\009setup = nil,\
\009\009remove = nil,\
\009\009download = {}\
\009}\
\
\009setmetatable(p, pmetatable)\
\
\009return p\
end\
\
function findDependencies(packageName, _dependencyTable)\
\009local dependencyTable = _dependencyTable or {}\
\009if list[packageName] then\
\009\009dependencyTable[packageName] = true\
\009\009for packName in pairs(list[packageName].dependencies) do\
\009\009\009packName = packName:lower()\
\009\009\009if packName ~= \"none\" and not dependencyTable[packName] then\
\009\009\009\009dependencyTable, errmsg = findDependencies(packName, dependencyTable)\
\009\009\009\009if not dependencyTable then return nil, errmsg end\
\009\009\009end\
\009\009end\
\009else\
\009\009return nil, packageName\
\009end\
\009return dependencyTable\
end\
\
if not fs.exists(\"/bin\") then fs.makeDir(\"/bin\") end\
--process package list\
local function addPacks(file)\
\009local packName = fs.getName(file)\
\009local state = \"\"\
\009local listHandle = io.open(file, \"r\")\
\009local entryTable\
\009local lineCount = 1\
\009if listHandle then\
\009\009for line in listHandle:lines() do\
\009\009\009if state == \"type\" then\
\009\009\009\009local allAttributes = true\
\009\009\009\009for attribute in pairs(downloadTypes[entryTable.download.type]) do\
\009\009\009\009\009if not entryTable.download[attribute] then\
\009\009\009\009\009\009allAttributes = false\
\009\009\009\009\009\009break\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009if allAttributes then\
\009\009\009\009\009state = \"main\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009local property,hasValue,value = string.match(line, \"^%s*([^=%s]+)%s*(=?)%s*(.-)%s*$\")\
\009\009\009hasValue=hasValue~=\"\" or nil\
\009\009\009if property == \"name\" and state == \"\" then\
\009\009\009\009if state == \"\" then\
\009\009\009\009\009entryTable = new(string.lower(value), packName)\
\009\009\009\009\009entryTable.target = \"/bin\"\
\009\009\009\009\009state = \"main\"\
\009\009\009\009else\
\009\009\009\009\009if state ~= \"dirty\" then\
\009\009\009\009\009\009printWarning(\"Unexpected 'name' at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009\009state = \"dirty\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif property == \"type\" then\
\009\009\009\009if state == \"main\" then\
\009\009\009\009\009entryTable.download.type = string.match(value, \"^(%S*)$\")\
\009\009\009\009\009if downloadFunctions[entryTable.download.type] then\
\009\009\009\009\009\009if entryTable.download.type == \"multi\" then\
\009\009\009\009\009\009\009entryTable.download.files = {}\
\009\009\009\009\009\009\009state = \"main\"\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009state = \"type\"\
\009\009\009\009\009\009end\
\009\009\009\009\009else\
\009\009\009\009\009\009if state ~= \"dirty\" then\
\009\009\009\009\009\009\009printWarning(\"Unknown Repository Format at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009\009\009state = \"dirty\"\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009if state ~= \"dirty\" then\
\009\009\009\009\009\009printWarning(\"Unexpected 'type' at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009\009state = \"dirty\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif property == \"file\" then\
\009\009\009\009if entryTable.download.type == \"multi\" then\
\009\009\009\009\009local fileTable = entryTable.download.files\
\009\009\009\009\009local name, url = string.match(value, \"(%S+)%s+(.*)\")\
\009\009\009\009\009fileTable[#fileTable + 1] = {name = name, url = url}\
\009\009\009\009else\
\009\009\009\009\009printWarning(\"Unexpected \"..property..\" at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009state = \"dirty\"\
\009\009\009\009end\
\009\009\009elseif property == \"target\" or property == \"setup\" or property == \"update\" or property == \"cleanup\" or property == \"version\" or property == \"size\" then\
\009\009\009\009if state == \"main\" then\
\009\009\009\009\009entryTable[property] = value\
\009\009\009\009else\
\009\009\009\009\009if state ~= \"dirty\" then\
\009\009\009\009\009\009printWarning(\"Unexpected \"..property..\" at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009\009state = \"dirty\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif property == \"dependencies\" or property == \"category\" then\
\009\009\009\009if state == \"main\" then\
\009\009\009\009\009for str in string.gmatch(value, \"(%S+)\") do\
\009\009\009\009\009\009entryTable[property][str] = true\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009if state ~= \"dirty\" then\
\009\009\009\009\009\009printWarning(\"Unexpected \"..property..\" at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009\009state = \"dirty\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif property == \"end\" then\
\009\009\009\009if state == \"dirty\" then\
\009\009\009\009\009state = \"\"\
\009\009\009\009elseif state == \"type\" then\
\009\009\009\009\009printWarning(\"Unexpected end at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009state = \"\"\
\009\009\009\009elseif state == \"main\" then\
\009\009\009\009\009--this line is the required entries for a valid repolist entry.\
\009\009\009\009\009if entryTable.download.type and #entryTable.version > 0 and (tonumber(entryTable.size) > 0 or entryTable.download.type == \"meta\") then\
\009\009\009\009\009\009local i\
\009\009\009\009\009\009for name in pairs(entryTable.dependencies) do\
\009\009\009\009\009\009\009i = true\
\009\009\009\009\009\009\009break\
\009\009\009\009\009\009end\
\009\009\009\009\009\009if i then\
\009\009\009\009\009\009\009list[packName..\"/\"..entryTable.name] = entryTable\
\009\009\009\009\009\009\009if list[entryTable.name] then\
\009\009\009\009\009\009\009\009list[entryTable.name][packName] = entryTable\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009list[entryTable.name] = {[packName] = entryTable}\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
\009\009\009\009\009else\
\009\009\009\009\009\009entryTable = nil\
\009\009\009\009\009end\
\009\009\009\009\009state = \"\"\
\009\009\009\009end\
\009\009\009elseif state == \"type\" then\
\009\009\009\009local propertyFound = false\
\009\009\009\009for prop in pairs(downloadTypes[entryTable.download.type]) do\
\009\009\009\009\009if property == prop then\
\009\009\009\009\009\009propertyFound = true\
\009\009\009\009\009\009break\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009if propertyFound then\
\009\009\009\009\009entryTable.download[property] = value\
\009\009\009\009else\
\009\009\009\009\009printWarning(\"Unexpected \"..property..\" at line \"..lineCount..\" in \"..file)\
\009\009\009\009\009state = \"dirty\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009lineCount = lineCount + 1\
\009\009end\
\009\009if state ~= \"\" then\
\009\009\009printWarning(\"Expected 'end' at line \"..lineCount..\" in \"..file)\
\009\009end\
\009\009listHandle:close()\
\009else\
\009\009printError(\"Could not open repository list!\")\
\009end\
end\
\
function load()\
\009for k, v in pairs(list) do\
\009\009list[k] = nil\
\009end\
\009if fs.exists(\"/etc/repositories\") then\
\009\009for _, file in ipairs(fs.list(\"/etc/repositories\")) do\
\009\009\009addPacks(fs.combine(\"/etc/repositories\", file))\
\009\009end\
\009end\
\
\009for k, v in pairs(installed) do\
\009\009installed[k] = nil\
\009end\
\009if fs.exists(fs.combine(installRoot, \"/etc/.installed\")) and fs.isDir(fs.combine(installRoot, \"/etc/.installed\")) then\
\009\009for _, repo in ipairs(fs.list(fs.combine(installRoot, \"/etc/.installed\"))) do\
\009\009\009for _, file in ipairs(fs.list(fs.combine(fs.combine(installRoot, \"/etc/.installed\"), repo))) do\
\009\009\009\009local name = repo..\"/\"..file\
\009\009\009\009local handle = io.open(fs.combine(fs.combine(fs.combine(installRoot, \"/etc/.installed\"), repo), file), \"r\")\
\009\009\009\009if handle then\
\009\009\009\009\009installed[name] = {files = {}}\
\009\009\009\009\009local packVersion\
\009\009\009\009\009for line in handle:lines() do\
\009\009\009\009\009\009if not packVersion then\
\009\009\009\009\009\009\009packVersion = line\
\009\009\009\009\009\009\009installed[name].version = packVersion\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009local path, version = string.match(line, \"([^;]+);(.*)\")\
\009\009\009\009\009\009\009if path and version then\
\009\009\009\009\009\009\009\009installed[name].files[#installed[name].files + 1] = {path = path, version = version}\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009installed[name].files[#installed[name].files + 1] = {path = line, version = packVersion}\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009handle:close()\
\009\009\009\009\009if installed[file] then\
\009\009\009\009\009\009installed[file][repo] = installed[name]\
\009\009\009\009\009else\
\009\009\009\009\009\009installed[file] = {[repo] = installed[name]}\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009printWarning(\"Couldn't open package db file: \"..file)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009for k, v in pairs(new_fs) do\
\009\009new_fs[k] = nil\
\009end\
\009do\
\009\009local root = installRoot\
\009\009--override fs api to use installRoot, recreated when loading to accomodate installRoot changes.\
\009\009local function fsWrap(name,f,n)\
\009\009\009return function(...)\
\009\009\009\009local args = { ... }\
\009\009\009\009for k,v in ipairs(args) do\
\009\009\009\009\009if n == nil or k <= n then\
\009\009\009\009\009\009args[k] = fs.combine(root, v)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009return f(unpack(args))\
\009\009\009end\
\009\009end\
\009\009for k,v in pairs(fs) do\
\009\009\009new_fs[k] = fsWrap(k,v,nil)\
\009\009end\
\009\009new_fs.open = fsWrap(\"open\",fs.open,1)\
\009\009new_fs.combine = fs.combine\
\009\009new_fs.getName = fs.getName\
\009\009new_fs.getDir = fs.getDir\
\009end\
end\
\
local versionNumber = 1.3\
local unpack = unpack or table.unpack\
\
\
local args = {...}\
\
local opwords = {\
\009install = true,\
\009remove = true,\
\009update = true,\
\009list = true,\
\009search = true,\
}\
\
local argwords = {\
\009fetch = true,\
\009force = true,\
\009target = 1,\
}\
\
if #args < 1 or (not opwords[args[1]] and not argwords[args[1]]) then\
\009io.write(\"Usage:\\n\")\
\009io.write(\"packman [options] install <package name[s]>\\n\")\
\009io.write(\"packman [options] update <package name[s]>\\n\")\
\009io.write(\"packman [options] remove <package name[s]>\\n\")\
\009io.write(\"packman [options] list [pattern]\\n\")\
\009io.write(\"packman [options] search [pattern]\\n\")\
\009io.write(\"\\n\")\
\009io.write(\"Options:\\n\")\
\009io.write(\"fetch\\n\")\
\009io.write(\"    Update repository and package lists before performing operations (can be used without an operation)\\n\")\
\009io.write(\"force\\n\")\
\009io.write(\"    Force yes answers when manipulating packages\\n\")\
\009io.write(\"target <directory>\\n\")\
\009io.write(\"    Set root directory to install packages in\\n\")\
\009return\
end\
\
local mode = \"\"\
local forced = false\
local target = \"/\"\
local fetch = false\
local argState = nil\
local argCount = 0\
local operation = {options = {}, arguments = {}}\
\
--lower all arguments\
for i = 1, #args do\
\009args[i] = string.lower(args[i])\
\009if argState == nil and args[i] == \"fetch\" then fetch = true end\
\009if argState == nil and args[i] == \"force\" then forced = true end\
\
\009if argwords[args[i]] and type(argwords[args[i]]) == \"number\" then\
\009\009operation.options[args[i]] = {}\
\009\009argState = args[i]\
\009\009argCount = argwords[args[i]]\
\009elseif opwords[args[i]] then\
\009\009mode = args[i]\
\009\009argState = \"arguments\"\
\009\009argCount = 0\
\009elseif argState and argCount > 0 then\
\009\009--option arguments\
\009\009table.insert(operation.options[argState], args[i])\
\009\009argCount = argCount - 1\
\009\009if argCount == 0 then argState = nil end\
\009elseif argState == \"arguments\" then\
\009\009--operation arguments\
\009\009table.insert(operation.arguments, args[i])\
\009end\
end\
\
if operation.options.target then\
\009target = operation.options.target[1]\
end\
\
local function resetScreen()\
\009term.setTextColor(colors.white)\
\009term.setBackgroundColor(colors.black)\
end\
\
local function printError(errorText)\
\009if term.isColor() then term.setTextColor(colors.red) end\
\009io.write(errorText..\"\\n\")\
\009term.setTextColor(colors.white)\
\009error()\
end\
\
local function printWarning(warningText)\
\009if term.isColor() then term.setTextColor(colors.yellow) end\
\009io.write(warningText..\"\\n\")\
\009term.setTextColor(colors.white)\
end\
\
local function printInformation(infoText)\
\009if term.isColor() then term.setTextColor(colors.lime) end\
\009io.write(infoText..\"\\n\")\
\009term.setTextColor(colors.white)\
end\
\
local function loadPackageAPI()\
\009if not package then if shell.resolveProgram(\"package\") then os.loadAPI(shell.resolveProgram(\"package\")) elseif fs.exists(\"etc/api/package\") then os.loadAPI(\"etc/api/package\") elseif not fetch then error(\"Could not load package API!\") end end\
\
\009if package then\
\009\009resetScreen()\
\009\009io.write(\"Loading database...\\n\")\
\009\009installRoot = target\
\
\009\009local co = coroutine.create(load)\
\009\009local event, filter, passback = {}\
\009\009while true do\
\009\009\009if (filter and (filter == event[1] or event[1] == \"terminate\")) or not filter then\
\009\009\009\009passback = {coroutine.resume(co, unpack(event))}\
\009\009\009end\
\009\009\009if passback[1] == false then printWarning(passback[2]) end\
\009\009\009if coroutine.status(co) == \"dead\" then break end\
\009\009\009filter = nil\
\009\009\009if passback and passback[1] and passback[2] then\
\009\009\009\009filter = passback[2]\
\009\009\009end\
\009\009\009event = {os.pullEventRaw()}\
\009\009\009if event[1] == \"package_status\" then\
\009\009\009\009if event[2] == \"info\" then\
\009\009\009\009\009printInformation(event[3])\
\009\009\009\009elseif event[2] == \"warning\" then\
\009\009\009\009\009printWarning(event[3])\
\009\009\009\009elseif event[2] == \"error\" then\
\009\009\009\009\009printError(event[3])\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
end\
\
loadPackageAPI()\
\
local categoryList = {}\
local categorySorted = {}\
\
if fetch then\
\009local queue\
\009if package and not pack then\
\009\009queue = newTransactionQueue(\"main/packman\")\
\009end\
\009io.write(\"Updating packman\\n\")\
\009local remoteHandle = http.get(\"https://raw.github.com/Piorjade/cLinux/master/bin/packman\")\
\009if remoteHandle then\
\009\009if pack then\
\009\009\009pack.addFile(shell.getRunningProgram(), remoteHandle.readAll())\
\009\009elseif queue then\
\009\009\009queue:addFile(shell.getRunningProgram(), remoteHandle.readAll())\
\009\009else\
\009\009\009local fileHandle = io.open(shell.getRunningProgram(), \"w\")\
\009\009\009if fileHandle then\
\009\009\009\009fileHandle:write(remoteHandle.readAll())\
\009\009\009\009fileHandle:close()\
\009\009\009else\
\009\009\009\009printWarning(\"Could not write file \"..shell.getRunningProgram())\
\009\009\009end\
\009\009end\
\009\009remoteHandle.close()\
\009else\
\009\009printWarning(\"Could not retrieve remote file.\")\
\009end\
\009io.write(\"Updating package API\\n\")\
\009remoteHandle = http.get(\"https://raw.github.com/Piorjade/cLinux/master/etc/api/package\")\
\009if remoteHandle then\
\009\009if pack then\
\009\009\009pack.makeDir(\"/etc/api\")\
\009\009\009pack.addFile(\"/etc/api/package\", remoteHandle.readAll())\
\009\009elseif queue then\
\009\009\009queue:makeDir(\"/etc/api\")\
\009\009\009queue:addFile(\"/etc/api/package\", remoteHandle.readAll())\
\009\009else\
\009\009\009if not fs.exists(\"/etc/api\") then fs.makeDir(\"/etc/api\") end\
\009\009\009local fileHandle = io.open(\"/etc/api/package\", \"w\")\
\009\009\009if fileHandle then\
\009\009\009\009fileHandle:write(remoteHandle.readAll())\
\009\009\009\009fileHandle:close()\
\009\009\009else\
\009\009\009\009printWarning(\"Could not write file /etc/api/package\")\
\009\009\009end\
\009\009end\
\009\009remoteHandle.close()\
\009else\
\009\009printWarning(\"Could not retrieve remote file.\")\
\009end\
\009io.write(\"Fetching Repository List\\n\")\
\009remoteHandle = http.get(\"http://pastebin.com/raw/m8wdq6Vn\")\
\009if remoteHandle then\
\009\009if pack then\
\009\009\009pack.makeDir(\"/etc\")\
\009\009\009pack.addFile(\"/etc/repolist\", remoteHandle.readAll())\
\009\009elseif queue then\
\009\009\009queue:makeDir(\"/etc\")\
\009\009\009queue:addFile(\"/etc/repolist\", remoteHandle.readAll())\
\009\009else\
\009\009\009local fileHandle = io.open(\"/etc/repolist\", \"w\")\
\009\009\009if fileHandle then\
\009\009\009\009fileHandle:write(remoteHandle.readAll())\
\009\009\009\009fileHandle:close()\
\009\009\009else\
\009\009\009\009printWarning(\"Could not write file /etc/repolist\")\
\009\009\009end\
\009\009end\
\009\009remoteHandle.close()\
\009else\
\009\009printWarning(\"could not retrieve remote file.\")\
\009end\
\009if fs.exists(\"/etc/repolist\") then\
\009\009if pack then\
\009\009\009pack.makeDir(\"/etc/repositories\")\
\009\009elseif queue then\
\009\009\009queue:makeDir(\"/etc/repositories\")\
\009\009else\
\009\009\009if not fs.exists(\"/etc/repositories\") then fs.makeDir(\"/etc/repositories\") end\
\009\009end\
\
\009\009local handle = io.open(\"/etc/repolist\", \"r\")\
\009\009if handle then\
\009\009\009for line in handle:lines() do\
\009\009\009\009local file, url = string.match(line, \"^(%S*)%s*(.*)\")\
\009\009\009\009if file and url then\
\009\009\009\009\009io.write(\"Fetching Repository: \"..file..\"\\n\")\
\009\009\009\009\009local remoteHandle = http.get(url)\
\009\009\009\009\009if remoteHandle then\
\009\009\009\009\009\009if pack then\
\009\009\009\009\009\009\009pack.addFile(fs.combine(\"/etc/repositories\", file), remoteHandle.readAll())\
\009\009\009\009\009\009elseif queue then\
\009\009\009\009\009\009\009queue:addFile(fs.combine(\"/etc/repositories\", file), remoteHandle.readAll())\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009local fileHandle = io.open(fs.combine(\"/etc/repositories\", file), \"w\")\
\009\009\009\009\009\009\009if fileHandle then\
\009\009\009\009\009\009\009\009fileHandle:write(remoteHandle.readAll())\
\009\009\009\009\009\009\009\009fileHandle:close()\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009printWarning(\"Could not write file: \"..fs.combine(\"/etc/repositories\", file))\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
\009\009\009\009\009\009remoteHandle.close()\
\009\009\009\009\009else\
\009\009\009\009\009\009printWarning(\"Could not retrieve remote file: \"..file)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009else\
\009\009\009printError(\"Failed to open repository list\")\
\009\009end\
\009end\
\
\009if queue then\
\009\009queue:finish()\
\009end\
\
\009fetch = false\
\
\009if #mode > 0 then\
\009\009--reload package API.\
\009\009os.unloadAPI(\"package\")\
\009\009loadPackageAPI()\
\009end\
end\
\
if #mode > 0 then\
\009for n, v in pairs(list) do\
\009\009if v.category then\
\009\009\009for category in pairs(v.category) do\
\009\009\009\009if not categoryList[category] then\
\009\009\009\009\009categoryList[category] = {[n] = true}\
\009\009\009\009\009table.insert(categorySorted, category)\
\009\009\009\009else\
\009\009\009\009\009categoryList[category][n] = true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009table.sort(categorySorted)\
\
\009local badPackages = {}\
\009--flesh out dependencies\
\009for pName, pData in pairs(list) do\
\009\009if pData.dependencies then\
\009\009\009dependencies, errmsg = findDependencies(pName, {})\
\009\009\009if not dependencies then\
\009\009\009\009--if dependencies could not be resolved, remove the \
\009\009\009\009printWarning(\"Could not resolve dependency on \"..errmsg..\" in package \"..pName)\
\009\009\009\009table.insert(badPackages, pName)\
\009\009\009else\
\009\009\009\009pData.dependencies = dependencies\
\009\009\009end\
\009\009end\
\009end\
\009--actual package removal and short-name lookup cleanup.\
\009for _, pack in pairs(badPackages) do\
\009\009local entry = list[pack]\
\009\009local name = entry.name\
\009\009local others, key = false\
\009\009for k, v in pairs(list[name]) do\
\009\009\009if v == entry then\
\009\009\009\009key = k\
\009\009\009else\
\009\009\009\009others = true\
\009\009\009end\
\009\009end\
\009\009if others then\
\009\009\009list[name][key] = nil\
\009\009else\
\009\009\009list[name] = nil\
\009\009end\
\009\009list[pack] = nil\
\009end\
end\
\
local function lookupPackage(name, installedOnly)\
\009if list[name] and not list[name].dependencies then\
\009\009local options = {}\
\009\009if installedOnly and installed[name] then\
\009\009\009for name, pack in pairs(installed[name]) do\
\009\009\009\009table.insert(options, name)\
\009\009\009end\
\009\009elseif installedOnly then\
\009\009\009--using installedOnly, but no packages of that name are installed.\
\009\009\009return false\
\009\009else\
\009\009\009for name, pack in pairs(list[name]) do\
\009\009\009\009table.insert(options, name)\
\009\009\009end\
\009\009end\
\009\009if #options > 1 then\
\009\009\009io.write(\"Package \"..name..\" is ambiguous.\\n\")\
\009\009\009for i = 1, #options do\
\009\009\009\009write(tostring(i)..\": \"..options[i]..\"  \")\
\009\009\009end\
\009\009\009io.write(\"\\n\")\
\009\009\009io.write(\"Select option: \\n\")\
\009\009\009local selection = io.read()\
\009\009\009if tonumber(selection) and options[tonumber(selection)] then\
\009\009\009\009return options[tonumber(selection)]..\"/\"..name\
\009\009\009end\
\009\009elseif #options == 1 then\
\009\009\009return options[1]..\"/\"..name\
\009\009else\
\009\009\009return false\
\009\009end\
\009elseif list[name] then\
\009\009--since it must have a dependencies table, the name is already fully unique.\
\009\009return name\
\009else\
\009\009return false\
\009end\
end\
\
local function raw_package_operation(name, funcName)\
\009local pack = list[name]\
\009if not pack then return nil, \"No such package\" end\
\009local co = coroutine.create(function() return pack[funcName](pack, getfenv()) end)\
\009local event, filter, passback = {}\
\009while true do\
\009\009if (filter and (filter == event[1] or event[1] == \"terminate\")) or not filter then\
\009\009\009passback = {coroutine.resume(co, unpack(event))}\
\009\009end\
\009\009if passback[1] == false then printWarning(passback[2]) end\
\009\009if coroutine.status(co) == \"dead\" then return unpack(passback, 2) end\
\009\009filter = nil\
\009\009if passback and passback[1] and passback[2] then\
\009\009\009filter = passback[2]\
\009\009end\
\009\009event = {os.pullEventRaw()}\
\009\009if event[1] == \"package_status\" then\
\009\009\009if event[2] == \"info\" then\
\009\009\009\009printInformation(event[3])\
\009\009\009elseif event[2] == \"warning\" then\
\009\009\009\009printWarning(event[3])\
\009\009\009elseif event[2] == \"error\" then\
\009\009\009\009printError(event[3])\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function install(name)\
\009return raw_package_operation(name, \"install\")\
end\
\
local function remove(name)\
\009return raw_package_operation(name, \"remove\")\
end\
\
local function upgrade(name)\
\009return raw_package_operation(name, \"upgrade\")\
end\
\
if mode == \"install\" then\
\009if #operation.arguments >= 1 then\
\009\009local installList = {}\
\009\009for packageNumber, packageName in ipairs(operation.arguments) do\
\009\009\009local result = lookupPackage(packageName)\
\009\009\009if not result then\
\009\009\009\009printWarning(\"Could not install package \"..packageName..\".\")\
\009\009\009else\
\009\009\009\009for k,v in pairs(list[result].dependencies) do\
\009\009\009\009\009if not installed[k] then\
\009\009\009\009\009\009installList[k] = true\
\009\009\009\009\009else\
\009\009\009\009\009\009if k == result then\
\009\009\009\009\009\009\009printInformation(\"Package \"..k..\" already installed\")\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009printInformation(\"Dependency \"..k..\" already installed\")\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009local installString = \"\"\
\009\009for k, v in pairs(installList) do\
\009\009\009installString = installString..k..\" \"\
\009\009end\
\009\009if #installString > 0 then\
\009\009\009if not forced then\
\009\009\009\009io.write(\"The following packages will be installed: \"..installString..\"\\n\")\
\009\009\009\009io.write(\"Continue? (Y/n)\\n\")\
\009\009\009\009local input = io.read()\
\009\009\009\009if string.sub(input:lower(), 1, 1) == \"n\" then\
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009end\
\009\009\009for packageName in pairs(installList) do\
\009\009\009\009if not install(packageName) then\
\009\009\009\009\009printWarning(\"Could not \"..mode..\" package \"..packageName)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
elseif mode == \"update\" then\
\009local updateList = {}\
\009local installList = {}\
\009if #operation.arguments >= 1 then\
\009\009for _, name in ipairs(operation.arguments) do\
\009\009\009local result = lookupPackage(name, true)\
\009\009\009if result then\
\009\009\009\009table.insert(updateList, result)\
\009\009\009end\
\009\009end\
\009else\
\009\009for k, v in pairs(installed) do\
\009\009\009if v.files then\
\009\009\009\009--filters out the disambiguation entries.\
\009\009\009\009table.insert(updateList, k)\
\009\009\009\009for name, info in pairs(list[k].dependencies) do\
\009\009\009\009\009if not installed[name] then\
\009\009\009\009\009\009installList[name] = true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009local installString = \"\"\
\009for k, v in pairs(installList) do\
\009\009installString = installString..k..\" \"\
\009end\
\009if not forced then\
\009\009for i = #updateList, 1, -1 do\
\009\009\009if installed[updateList[i]].version == list[updateList[i]].version then\
\009\009\009\009table.remove(updateList, i)\
\009\009\009end\
\009\009end\
\009end\
\009if #updateList > 0 or #installString > 0 then\
\009\009local updateString = \"\"\
\009\009for i = 1, #updateList do\
\009\009\009updateString = updateString..updateList[i]..\" \"\
\009\009end\
\009\009if not forced then\
\009\009\009io.write(\"The following packages will be updated: \"..updateString..\"\\n\")\
\009\009\009if #installString > 0 then\
\009\009\009\009io.write(\"The following packages will also be installed: \"..installString..\"\\n\")\
\009\009\009end\
\009\009\009io.write(\"Continue? (Y/n)\\n\")\
\009\009\009local input = io.read()\
\009\009\009if string.sub(input:lower(), 1, 1) == \"n\" then\
\009\009\009\009return true\
\009\009\009end\
\009\009end\
\009\009local failureCount = 0\
\009\009for packageName in pairs(installList) do\
\009\009\009if not install(packageName) then\
\009\009\009\009printWarning(\"Could not install package \"..packageName)\
\009\009\009end\
\009\009end\
\009\009for _, packageName in pairs(updateList) do\
\009\009\009if not upgrade(packageName) then\
\009\009\009\009printWarning(\"Package \"..packageName..\" failed to update.\")\
\009\009\009\009failureCount = failureCount + 1\
\009\009\009end\
\009\009end\
\009\009if failureCount > 0 then\
\009\009\009printWarning(failureCount..\" packages failed to update.\")\
\009\009else\
\009\009\009printInformation(\"Update complete!\")\
\009\009end\
\009else\
\009\009io.write(\"Nothing to do!\\n\")\
\009\009return true\
\009end\
elseif mode == \"remove\" then\
\009if #operation.arguments >= 1 then\
\009\009local packageList = {}\
\009\009for _, name in ipairs(operation.arguments) do\
\009\009\009local result = lookupPackage(name, true)\
\009\009\009if result then\
\009\009\009\009table.insert(packageList, result)\
\009\009\009end\
\009\009end\
\009\009dependeesList = {}\
\009\009--find packages which depend on the packages we are removing.\
\009\009for pName, pData in pairs(installed) do\
\009\009\009if pData.version then\
\009\009\009\009if not packageList[pName] then\
\009\009\009\009\009for dName in pairs(list[pName].dependencies) do\
\009\009\009\009\009\009for _, packName in pairs(packageList) do\
\009\009\009\009\009\009\009if packName == dName then\
\009\009\009\009\009\009\009\009dependeesList[pName] = true\
\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009end\
\009\009\009\009\009\009if dependeesList[pName] then\
\009\009\009\009\009\009\009break\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009local removeString = \"\"\
\009\009local dependeesString = \"\"\
\009\009for i = 1, #packageList do\
\009\009\009removeString = removeString..packageList[i]..\" \"\
\009\009\009if dependeesList[packageList[i]] then\
\009\009\009\009dependeesList[packageList[i]] = nil\
\009\009\009end\
\009\009end\
\009\009for dName in pairs(dependeesList) do\
\009\009\009dependeesString = dependeesString..dName..\" \"\
\009\009end\
\009\009if #removeString > 0 then\
\009\009\009if not forced then\
\009\009\009\009io.write(\"The following packages will be removed: \"..removeString..\"\\n\")\
\009\009\009\009if #dependeesString > 0 then\
\009\009\009\009\009io.write(\"The following packages will also be removed due to missing dependencies: \"..dependeesString..\"\\n\")\
\009\009\009\009end\
\009\009\009\009io.write(\"Continue? (y/N)\\n\")\
\009\009\009\009local input = io.read()\
\009\009\009\009if string.sub(input:lower(), 1, 1) ~= \"y\" then\
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009end\
\009\009\009for pName in pairs(dependeesList) do\
\009\009\009\009printInformation(\"Removing \"..pName)\
\009\009\009\009remove(pName)\
\009\009\009end\
\009\009\009for _, pName in pairs(packageList) do\
\009\009\009\009printInformation(\"Removing \"..pName)\
\009\009\009\009remove(pName)\
\009\009\009end\
\009\009else\
\009\009\009io.write(\"Nothing to do!\\n\")\
\009\009end\
\009end\
elseif mode == \"list\" then\
\009--list all installed packages\
\009local match = \".*\"\
\009if #operation.arguments == 1 then\
\009\009--list with matching.\
\009\009match = operation.arguments[1]\
\009end\
\009for name, info in pairs(installed) do\
\009\009if info.version then\
\009\009\009if string.match(name, match) then\
\009\009\009\009io.write(name..\" \"..info.version..\"\\n\")\
\009\009\009end\
\009\009end\
\009end\
elseif mode == \"search\" then\
\009--search all available packages\
\009local match = \".*\"\
\009if #operation.arguments == 1 then\
\009\009--search using a match\
\009\009match = operation.arguments[1]\
\009end\
\009for name, info in pairs(list) do\
\009\009if info.version then\
\009\009\009if string.match(name, match) then\
\009\009\009\009io.write((installed[name] and \"I \" or \"A \" )..name..\" \"..info.version..\"\\n\")\
\009\009\009end\
\009\009end\
\009end\
end",
      "if lib.perm.permission.check(\"/bin\") == \"x\" or not lib.perm then\
\009printError(\"User is not root, aborting...\")\
\009return\
end\
\
--[[ /gitget\
GitHub downloading utility for CC.\
Developed by apemanzilla.\
 \
This requires ElvishJerricco's JSON parsing API.\
Direct link: http://pastebin.com/raw.php?i=4nRg9CHU\
]]--\
\
-- Edit these variables to use preset mode.\
-- Whether to download the files asynchronously (huge speed benefits, will also retry failed files)\
-- If false will download the files one by one and use the old output (List each file name as it's downloaded) instead of the progress bar\
local async = true\
\
-- Whether to write to the terminal as files are downloaded\
-- Note that unless checked for this will not affect pre-set start/done code below\
local silent = false\
\
local preset = {\
\009-- The GitHub account name\
\009user = \"Piorjade\",\
\009-- The GitHub repository name\
\009repo = \"cLinux\",\
\009\
\009-- The branch or commit tree to download (defaults to 'master')\
\009branch = nil,\
\009\
\009-- The local folder to save all the files to (defaults to '/')\
\009path = nil,\
\009\
\009-- Function to run before starting the download\
\009start = function()\
\009\009if not silent then print(\"Downloading files from GitHub...\") end\
\009end,\
\009\
\009-- Function to run when the download completes\
\009done = function()\
\009\009if not silent then print(\"Done\") end\
\009end\
}\
\
-- Leave the rest of the program alone.\
local args = {...}\
\
args[1] = preset.user or args[1]\
args[2] = preset.repo or args[2]\
args[3] = preset.branch or args[3] or \"master\"\
args[4] = preset.path or args[4] or \"\"\
 \
if #args < 2 then\
\009\009print(\"Usage:\\n\"..((shell and shell.getRunningProgram()) or \"gitget\")..\" <user> <repo> [branch/tree] [path]\") error()\
end\
 \
local function save(data,file)\
\009local file = shell.resolve(file:gsub(\"%%20\",\" \"))\
\009if not (fs.exists(string.sub(file,1,#file - #fs.getName(file))) and fs.isDir(string.sub(file,1,#file - #fs.getName(file)))) then\
\009\009if fs.exists(string.sub(file,1,#file - #fs.getName(file))) then fs.delete(string.sub(file,1,#file - #fs.getName(file))) end\
\009\009fs.makeDir(string.sub(file,1,#file - #fs.getName(file)))\
\009end\
\009local f = fs.open(file,\"w\")\
\009f.write(data)\
\009f.close()\
end\
 \
local function download(url, file)\
\009save(http.get(url).readAll(),file)\
end\
\
if not json then\
\009download(\"http://pastebin.com/raw.php?i=4nRg9CHU\",\"/json\")\
\009os.loadAPI(\"json\")\
end\
 \
preset.start()\
local data = json.decode(http.get(\"https://api.github.com/repos/\"..args[1]..\"/\"..args[2]..\"/git/trees/\"..args[3]..\"?recursive=1\").readAll())\
if data.message and data.message:find(\"API rate limit exceeded\") then error(\"Out of API calls, try again later\") end\
if data.message and data.message == \"Not found\" then error(\"Invalid repository\",2) else\
\009for k,v in pairs(data.tree) do\
\009\009-- Make directories\
\009\009if v.type == \"tree\" then\
\009\009\009fs.makeDir(fs.combine(args[4],v.path))\
\009\009\009if not hide_progress then\
\009\009\009end\
\009\009end\
\009end\
\009local drawProgress\
\009if async and not silent then\
\009\009local _, y = term.getCursorPos()\
\009\009local wide, _ = term.getSize()\
\009\009term.setCursorPos(1, y)\
\009\009term.write(\"[\")\
\009\009term.setCursorPos(wide - 6, y)\
\009\009term.write(\"]\")\
\009\009drawProgress = function(done, max)\
\009\009\009local value = done / max\
\009\009\009term.setCursorPos(2,y)\
\009\009\009term.write((\"=\"):rep(math.floor(value * (wide - 8))))\
\009\009\009local percent = math.floor(value * 100) .. \"%\"\
\009\009\009term.setCursorPos(wide - percent:len(),y)\
\009\009\009term.write(percent)\
\009\009end\
\009end\
\009local filecount = 0\
\009local downloaded = 0\
\009local paths = {}\
\009local failed = {}\
\009for k,v in pairs(data.tree) do\
\009\009-- Send all HTTP requests (async)\
\009\009if v.type == \"blob\" then\
\009\009\009v.path = v.path:gsub(\"%s\",\"%%20\")\
\009\009\009local url = \"https://raw.github.com/\"..args[1]..\"/\"..args[2]..\"/\"..args[3]..\"/\"..v.path,fs.combine(args[4],v.path)\
\009\009\009if async then\
\009\009\009\009http.request(url)\
\009\009\009\009paths[url] = fs.combine(args[4],v.path)\
\009\009\009\009filecount = filecount + 1\
\009\009\009else\
\009\009\009\009download(url, fs.combine(args[4], v.path))\
\009\009\009\009if not silent then print(fs.combine(args[4], v.path)) end\
\009\009\009end\
\009\009end\
\009end\
\009while downloaded < filecount do\
\009\009local e, a, b = os.pullEvent()\
\009\009if e == \"http_success\" then\
\009\009\009save(b.readAll(),paths[a])\
\009\009\009downloaded = downloaded + 1\
\009\009\009if not silent then drawProgress(downloaded,filecount) end\
\009\009elseif e == \"http_failure\" then\
\009\009\009-- Retry in 3 seconds\
\009\009\009failed[os.startTimer(3)] = a\
\009\009elseif e == \"timer\" and failed[a] then\
\009\009\009http.request(failed[a])\
\009\009end\
\009end\
end\
preset.done()",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/ls\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This program lists every folder/file in the current directory\
\009\009and prints them in their color (folders = blue, files = lime)\
]]--\
\
local function listFiles(dir)\
\009local maxX, maxY = term.getSize()\
\009if dir == nil or dir == \"\" then\
\009\009dir = shell.dir()\
\009end\
\009local i, j = string.find(dir, \"/\", #dir)\
\009if i then\
\009\009dir = dir\
\009else\
\009\009dir = dir..\"/\"\
\009end\
\009local files = {}\
\009local folders = {}\
\009local raw = {}\
\
\009raw = fs.list(dir)\
\009for _, a in ipairs(raw) do\
\009\009local c, d = string.find(a, \"[.]\")\
\009\009if c ~= 1 or c == nil then\
\009\009\009if fs.isDir(dir..a) then\
\009\009\009\009table.insert(folders, a)\
\009\009\009else\
\009\009\009\009table.insert(files, a)\
\009\009\009end\
\009\009end\
\009end\
\009local col = term.getTextColor()\
\009if #folders > 0 then\
\009\009term.setTextColor(colors.blue)\
\009\009local c = 1\
\009\009local x, y = term.getCursorPos()\
\009\009for _, folder in ipairs(folders) do\
\009\009\009local h, j = term.getCursorPos()\
\009\009\009local k = folder..\" \"\
\009\009\009if c < 8 and h+#k <= maxX then\
\009\009\009\009term.setTextColor(colors.blue)\
\009\009\009\009term.write(folder..\" \")\
\009\009\009\009c = c+1\
\009\009\009elseif c == 8 and h+#k <= maxX then\
\009\009\009\009term.setTextColor(colors.blue)\
\009\009\009\009term.write(folder)\
\009\009\009\009c = 1\
\009\009\009\009local x, y = term.getCursorPos()\
\009\009\009\009if _ < #folders then\
\009\009\009\009\009if y+1 ~= maxY+1 then\
\009\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009\009else\
\009\009\009\009\009\009term.scroll(1)\
\009\009\009\009\009\009term.setCursorPos(1, maxY)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009c = 1\
\009\009\009\009local x, y = term.getCursorPos()\
\009\009\009\009if y+1 ~= maxY+1 then\
\009\009\009\009\009term.setTextColor(colors.blue)\
\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009\009term.write(folder..\" \")\
\009\009\009\009\009c = c+1\
\009\009\009\009else\
\009\009\009\009\009term.setTextColor(colors.blue)\
\009\009\009\009\009term.scroll(1)\
\009\009\009\009\009term.setCursorPos(1, maxY)\
\009\009\009\009\009term.write(folder..\" \")\
\009\009\009\009\009c = c+1\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009local x, y = term.getCursorPos()\
\009\009if y+1 ~= maxY+1 then\
\009\009\009term.setCursorPos(1, y+1)\
\009\009else\
\009\009\009term.scroll(1)\
\009\009\009term.setCursorPos(1, maxY)\
\009\009end\
\009end\
\009if #files > 0 then\
\009\009term.setTextColor(colors.lime)\
\009\009c = 1\
\009\009local x, y = term.getCursorPos()\
\009\009--[[if y+1 ~= 20 then\
\009\009\009term.setCursorPos(1, y+1)\
\009\009else\
\009\009\009term.scroll(1)\
\009\009\009term.setCursorPos(1, 19)\
\009\009end]]\
\009\009for _, file in ipairs(files) do\
\009\009\009local h, j = term.getCursorPos()\
\009\009\009local k = file..\" \"\
\009\009\009if c < 8 and h+#k <= maxX then\
\009\009\009\009term.write(file..\" \")\
\009\009\009\009c = c+1\
\009\009\009elseif c == 8 and h+#k <= maxX then\
\009\009\009\009term.write(file)\
\009\009\009\009c = 1\
\009\009\009\009local x, y = term.getCursorPos()\
\009\009\009\009if _ < #files then\
\009\009\009\009\009if y+1 ~= maxY+1 then\
\009\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009\009else\
\009\009\009\009\009\009term.scroll(1)\
\009\009\009\009\009\009term.setCursorPos(1, maxY)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009c = 1\
\009\009\009\009local x, y = term.getCursorPos()\
\009\009\009\009if y+1 ~= maxY+1 then\
\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009\009term.write(file..\" \")\
\009\009\009\009\009c = c+1\
\009\009\009\009else\
\009\009\009\009\009term.scroll(1)\
\009\009\009\009\009term.setCursorPos(1, maxY)\
\009\009\009\009\009term.write(file..\" \")\
\009\009\009\009\009c = c+1\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009local x, y = term.getCursorPos()\
\009\009if y+1 ~= 20 then\
\009\009\009term.setCursorPos(1, y+1)\
\009\009else\
\009\009\009term.scroll(1)\
\009\009\009term.setCursorPos(1, maxY)\
\009\009end\
\009end\
\009term.setTextColor(col)\
\
end\
\
local tArgs = {...}\
\
if #tArgs > 1 then\
\009print(\"Usage:\")\
\009print(\"\009\009ls <path>\")\
else\
\009listFiles(tArgs[1])\
end",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/rm\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION: \
\009\009This program deletes a specified file in the specified path / in the\
\009\009current directory.\
]]--\
\
local function del(d)\
\009local r = false\
\009local currentDir = shell.dir()..\"/\"\
\009local falseDir = false\
\009local inhome = true\
\009local currentUsr = lib.perm.permission.getCurrentUser()\
\009if currentUsr ~= \"root\" then\
\009\009r = false\
\009else\
\009\009r = true\
\009end\
\009local a, b = string.find(d, \"//\")\
\009local i, j = string.find(d, \"~\")\
\009if a or i ~= nil and i == j then\
\009\009falseDir = true\
\009end\
\009local a, b = string.find(currentDir, \"/usr/\"..currentUsr..\"/home/\")\
\009if r == false and a == nil then\
\009\009inhome = false\
\009end\
\009\
\009if falseDir == false then\
\009\009\
\009\009local path = currentDir..d\
\009\009local a, b = string.find(d, \"/\")\
\009\009if a == 1 then\
\009\009\009path = d\
\009\009end\
\009\009local a, b = string.find(d, \"[..]/\")\
\009\009if a then\
\009\009\009--d = string.gsub(d, \"/\", \"\", 1)\
\009\009\009local col = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"Invalid Path.\")\
\009\009\009term.setTextColor(col)\
\009\009\009return\
\009\009end\
\009\009if not fs.exists(path) then\
\009\009\009local col = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"Folder/File does not exist.\")\
\009\009\009term.setTextColor(col)\
\009\009\009return\
\009\009end\
\009\009local a = fs.delete(path)\
\009\009if a == \"noPermission\" then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"You have no privileges, try 'sudo'.\")\
\009\009\009term.setTextColor(c)\
\009\009else\
\009\009\009return true\
\009\009end\
\009elseif falseDir == true then\
\009\009local col = term.getTextColor()\
\009\009term.setTextColor(colors.red)\
\009\009print(\"Invalid path!\")\
\009\009term.setTextColor(col)\
\009\009return false\
\009else\
\009\009print(\"User not found.\")\
\009\009return false\
\009end\
end\
local tArgs = {...}\
\
if #tArgs < 1 or #tArgs > 1 then\
\009print(\"Usage:\")\
\009print(\"\009\009rm <path>\")\
else\
\009del(tArgs[1])\
end",
      "-- Get file to edit\
local tArgs = { ... }\
if #tArgs == 0 then\
\009print( \"Usage: edit <path>\" )\
\009return\
end\
\
-- Error checking\
local sPath = shell.resolve( tArgs[1] )\
local bReadOnly = fs.isReadOnly( sPath )\
if fs.exists( sPath ) and fs.isDir( sPath ) then\
\009print( \"Cannot edit a directory.\" )\
\009return\
end\
\
local x,y = 1,1\
local w,h = term.getSize()\
local scrollX, scrollY = 0,0\
\
local tLines = {}\
local bRunning = true\
\
-- Colours\
local highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour\
if term.isColour() then\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.yellow\
\009keywordColour = colours.yellow\
\009commentColour = colours.green\
\009stringColour = colours.red\
else\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.white\
\009keywordColour = colours.white\
\009commentColour = colours.white\
\009stringColour = colours.white\
end\
\
-- Menus\
local bMenu = false\
local nMenuItem = 1\
local tMenuItems = {}\
if not bReadOnly then\
    table.insert( tMenuItems, \"Save\" )\
end\
if shell.openTab then\
    table.insert( tMenuItems, \"Run\" )\
end\
if peripheral.find( \"printer\" ) then\
    table.insert( tMenuItems, \"Print\" )\
end\
table.insert( tMenuItems, \"Exit\" )\
\
local sStatus = \"Press Ctrl to access menu\"\
if string.len( sStatus ) > w - 5 then\
    sStatus = \"Press Ctrl for menu\"\
end\
\
local function load( _sPath )\
\009tLines = {}\
\009if fs.exists( _sPath ) then\
\009\009local file = io.open( _sPath, \"r\" )\
\009\009local sLine = file:read()\
\009\009while sLine do\
\009\009\009table.insert( tLines, sLine )\
\009\009\009sLine = file:read()\
\009\009end\
\009\009file:close()\
\009end\
\009\
\009if #tLines == 0 then\
\009\009table.insert( tLines, \"\" )\
\009end\
end\
\
local function save( _sPath )\
\009-- Create intervening folder\
\009local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len() )\
\009if not fs.exists( sDir ) then\
\009\009fs.makeDir( sDir )\
\009end\
\
\009-- Save\
\009local file = nil\
\009local function innerSave()\
\009\009file = fs.open( _sPath, \"w\" )\
\009\009if file then\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009file.write( sLine .. \"\\n\" )\
\009\009\009end\
\009\009else\
\009\009\009error( \"Failed to open \".._sPath )\
\009\009end\
\009end\
\009\
\009local ok, err = pcall( innerSave )\
\009if file then \
\009\009file.close()\
\009end\
\009return ok, err\
end\
\
local tKeywords = {\
\009[\"and\"] = true,\
\009[\"break\"] = true,\
\009[\"do\"] = true,\
\009[\"else\"] = true,\
\009[\"elseif\"] = true,\
\009[\"end\"] = true,\
\009[\"false\"] = true,\
\009[\"for\"] = true,\
\009[\"function\"] = true,\
\009[\"if\"] = true,\
\009[\"in\"] = true,\
\009[\"local\"] = true,\
\009[\"nil\"] = true,\
\009[\"not\"] = true,\
\009[\"or\"] = true,\
\009[\"repeat\"] = true,\
\009[\"return\"] = true,\
\009[\"then\"] = true,\
\009[\"true\"] = true,\
\009[\"until\"]= true,\
\009[\"while\"] = true,\
}\
\
local function tryWrite( sLine, regex, colour )\
\009local match = string.match( sLine, regex )\
\009if match then\
\009\009if type(colour) == \"number\" then\
\009\009\009term.setTextColour( colour )\
\009\009else\
\009\009\009term.setTextColour( colour(match) )\
\009\009end\
\009\009term.write( match )\
\009\009term.setTextColour( textColour )\
\009\009return string.sub( sLine, string.len(match) + 1 )\
\009end\
\009return nil\
end\
\
local function writeHighlighted( sLine )\
\009while string.len(sLine) > 0 do\009\
\009\009sLine = \
\009\009\009tryWrite( sLine, \"^%-%-%[%[.-%]%]\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^%-%-.*\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^\\\"\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\\".-[^\\\\]\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'.-[^\\\\]\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^%[%[.-%]%]\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^[%w_]+\", function( match )\
\009\009\009\009if tKeywords[ match ] then\
\009\009\009\009\009return keywordColour\
\009\009\009\009end\
\009\009\009\009return textColour\
\009\009\009end ) or\
\009\009\009tryWrite( sLine, \"^[^%w_]\", textColour )\
\009end\
end\
\
local tCompletions\
local nCompletion\
\
local tCompleteEnv = _ENV\
local function complete( sLine )\
\009if settings.get( \"edit.autocomplete\" ) then\
\009    local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.]+$\" )\
\009    if nStartPos then\
\009        sLine = string.sub( sLine, nStartPos )\
\009    end\
\009    if #sLine > 0 then\
\009        return textutils.complete( sLine, tCompleteEnv )\
\009    end\
\009end\
    return nil\
end\
\
local function recomplete()\
    local sLine = tLines[y]\
    if not bMenu and not bReadOnly and x == string.len(sLine) + 1 then\
        tCompletions = complete( sLine )\
        if tCompletions and #tCompletions > 0 then\
            nCompletion = 1\
        else\
            nCompletion = nil\
        end\
    else\
        tCompletions = nil\
        nCompletion = nil\
    end\
end\
\
local function writeCompletion( sLine )\
    if nCompletion then\
        local sCompletion = tCompletions[ nCompletion ]\
        term.setTextColor( colours.white )\
        term.setBackgroundColor( colours.grey )\
        term.write( sCompletion )\
        term.setTextColor( textColour )\
        term.setBackgroundColor( bgColour )\
    end\
end\
\
local function redrawText()\
    local cursorX, cursorY = x, y\
\009for y=1,h-1 do\
\009\009term.setCursorPos( 1 - scrollX, y )\
\009\009term.clearLine()\
\
\009\009local sLine = tLines[ y + scrollY ]\
\009\009if sLine ~= nil then\
\009\009\009writeHighlighted( sLine )\
            if cursorY == y and cursorX == #sLine + 1 then\
                writeCompletion()\
            end\
\009\009end\
\009end\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local function redrawLine(_nY)\
\009local sLine = tLines[_nY]\
\009if sLine then\
        term.setCursorPos( 1 - scrollX, _nY - scrollY )\
        term.clearLine()\
        writeHighlighted( sLine )\
        if _nY == y and x == #sLine + 1 then\
            writeCompletion()\
        end\
        term.setCursorPos( x - scrollX, _nY - scrollY )\
    end\
end\
\
local function redrawMenu()\
    -- Clear line\
    term.setCursorPos( 1, h )\
\009term.clearLine()\
\
    -- Draw line numbers\
    term.setCursorPos( w - string.len( \"Ln \"..y ) + 1, h )\
    term.setTextColour( highlightColour )\
    term.write( \"Ln \" )\
    term.setTextColour( textColour )\
    term.write( y )\
\
    term.setCursorPos( 1, h )\
\009if bMenu then\
        -- Draw menu\
\009\009term.setTextColour( textColour )\
\009\009for nItem,sItem in pairs( tMenuItems ) do\
\009\009\009if nItem == nMenuItem then\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"[\" )\
\009\009\009\009term.setTextColour( textColour )\
\009\009\009\009term.write( sItem )\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"]\" )\
        \009\009term.setTextColour( textColour )\
\009\009\009else\
\009\009\009\009term.write( \" \"..sItem..\" \" )\
\009\009\009end\
\009\009end\
    else\
        -- Draw status\
        term.setTextColour( highlightColour )\
        term.write( sStatus )\
        term.setTextColour( textColour )\
    end\
\
\009-- Reset cursor\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local tMenuFuncs = { \
\009Save = function()\
\009\009if bReadOnly then\
\009\009\009sStatus = \"Access denied\"\
\009\009else\
\009\009\009local ok, err = save( sPath )\
\009\009\009if ok then\
\009\009\009\009sStatus=\"Saved to \"..sPath\
\009\009\009else\
\009\009\009\009sStatus=\"Error saving to \"..sPath\
\009\009\009end\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Print = function()\
\009\009local printer = peripheral.find( \"printer\" )\
\009\009if not printer then\
\009\009\009sStatus = \"No printer attached\"\
\009\009\009return\
\009\009end\
\
\009\009local nPage = 0\
\009\009local sName = fs.getName( sPath )\
\009\009if printer.getInkLevel() < 1 then\
\009\009\009sStatus = \"Printer out of ink\"\
\009\009\009return\
\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009sStatus = \"Printer out of paper\"\
\009\009\009return\
\009\009end\
\
\009\009local screenTerminal = term.current()\
\009\009local printerTerminal = {\
\009\009\009getCursorPos = printer.getCursorPos,\
\009\009\009setCursorPos = printer.setCursorPos,\
\009\009\009getSize = printer.getPageSize,\
\009\009\009write = printer.write,\
\009\009}\
\009\009printerTerminal.scroll = function()\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\009\009\009\
\009\009\009end\
\009\009\009\
\009\009\009while not printer.newPage()\009do\
\009\009\009\009if printer.getInkLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of ink, please refill\"\
\009\009\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of paper, please refill\"\
\009\009\009\009else\
\009\009\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009\009end\
\009\
\009\009\009\009term.redirect( screenTerminal )\
\009\009\009\009redrawMenu()\
\009\009\009\009term.redirect( printerTerminal )\
\009\009\009\009\
\009\009\009\009local timer = os.startTimer(0.5)\
\009\009\009\009sleep(0.5)\
\009\009\009end\
\
\009\009\009nPage = nPage + 1\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName )\
\009\009\009else\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\
\009\009\009end\
\009\009end\
\009\009\
\009\009bMenu = false\
\009\009term.redirect( printerTerminal )\
\009\009local ok, error = pcall( function()\
\009\009\009term.scroll()\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009print( sLine )\
\009\009\009end\
\009\009end )\
        term.redirect( screenTerminal )\
\009\009if not ok then\
\009\009\009print( error )\
\009\009end\
\009\009\
\009\009while not printer.endPage() do\
\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009redrawMenu()\
\009\009\009sleep( 0.5 )\
\009\009end\
\009\009bMenu = true\
\009\009\009\
\009\009if nPage > 1 then\
\009\009\009sStatus = \"Printed \"..nPage..\" Pages\"\
\009\009else\
\009\009\009sStatus = \"Printed 1 Page\"\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Exit = function()\
\009\009bRunning = false\
\009end,\
\009Run = function()\
\009    local sTempPath = \"/.temp\"\
        local ok, err = save( sTempPath )\
        if ok then\
            local nTask = shell.openTab( sTempPath )\
            if nTask then\
                shell.switchTab( nTask )\
            else\
                sStatus=\"Error starting Task\"\
            end\
            fs.delete( sTempPath )\
        else\
            sStatus=\"Error saving to \"..sTempPath\
        end\
\009\009redrawMenu()\
    end\
}\
\
local function doMenuItem( _n )\
\009tMenuFuncs[tMenuItems[_n]]()\
\009if bMenu then\
\009\009bMenu = false\
\009\009term.setCursorBlink( true )\
\009end\
\009redrawMenu()\
end\
\
local function setCursor( newX, newY )\
    local oldX, oldY = x, y\
    x, y = newX, newY\
\009local screenX = x - scrollX\
\009local screenY = y - scrollY\
\009\
\009local bRedraw = false\
\009if screenX < 1 then\
\009\009scrollX = x - 1\
\009\009screenX = 1\
\009\009bRedraw = true\
\009elseif screenX > w then\
\009\009scrollX = x - w\
\009\009screenX = w\
\009\009bRedraw = true\
\009end\
\009\
\009if screenY < 1 then\
\009\009scrollY = y - 1\
\009\009screenY = 1\
\009\009bRedraw = true\
\009elseif screenY > h-1 then\
\009\009scrollY = y - (h-1)\
\009\009screenY = h-1\
\009\009bRedraw = true\
\009end\
\
\009recomplete()\
\009if bRedraw then\
\009\009redrawText()\
\009elseif y ~= oldY then\
\009    redrawLine( oldY )\
\009    redrawLine( y )\
\009else\
\009    redrawLine( y )\
\009end\
\009term.setCursorPos( screenX, screenY )\
\
\009redrawMenu()\
end\
\
-- Actual program functionality begins\
load(sPath)\
\
term.setBackgroundColour( bgColour )\
term.clear()\
term.setCursorPos(x,y)\
term.setCursorBlink( true )\
\
recomplete()\
redrawText()\
redrawMenu()\
\
local function acceptCompletion()\
    if nCompletion then\
        -- Append the completion\
        local sCompletion = tCompletions[ nCompletion ]\
        tLines[y] = tLines[y] .. sCompletion\
        setCursor( x + string.len( sCompletion ), y )\
    end\
end\
\
-- Handle input\
while bRunning do\
\009local sEvent, param, param2, param3 = os.pullEvent()\
\009if sEvent == \"key\" then\
\009    local oldX, oldY = x, y\
\009\009if param == keys.up then\
\009\009\009-- Up\
\009\009\009if not bMenu then\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion - 1\
                    if nCompletion < 1 then\
                        nCompletion = #tCompletions\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009setCursor(\
\009\009\009\009\009    math.min( x, string.len( tLines[y - 1] ) + 1 ),\
\009\009\009\009\009    y - 1\
\009\009\009\009\009)\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.down then\
\009\009\009-- Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor down\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion + 1\
                    if nCompletion > #tCompletions then\
                        nCompletion = 1\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y < #tLines then\
\009\009\009\009    -- Move cursor down\
\009\009\009\009\009setCursor(\
                        math.min( x, string.len( tLines[y + 1] ) + 1 ),\
                        y + 1\
                    )\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.tab then\
\009\009\009-- Tab\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    if nCompletion and x == string.len(tLines[y]) + 1 then\
\009\009\009        -- Accept autocomplete\
                    acceptCompletion()\
                else\
                    -- Indent line\
                    local sLine = tLines[y]\
                    tLines[y] = string.sub(sLine,1,x-1) .. \"  \" .. string.sub(sLine,x)\
                    setCursor( x + 2, y )\
                end\
\009\009\009end\
\
\009\009elseif param == keys.pageUp then\
\009\009\009-- Page Up\
\009\009\009if not bMenu then\
\009\009\009\009-- Move up a page\
\009\009\009\009local newY\
\009\009\009\009if y - (h - 1) >= 1 then\
\009\009\009\009\009newY = y - (h - 1)\
\009\009\009\009else\
\009\009\009\009    newY = 1\
\009\009\009\009end\
                setCursor(\
\009\009\009\009    math.min( x, string.len( tLines[newY] ) + 1 ),\
\009\009\009\009    newY\
\009\009\009\009)\
\009\009\009end\
\
\009\009elseif param == keys.pageDown then\
\009\009\009-- Page Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move down a page\
\009\009\009\009local newY\
\009\009\009\009if y + (h - 1) <= #tLines then\
\009\009\009\009\009newY = y + (h - 1)\
\009\009\009\009else\
\009\009\009\009\009newY = #tLines\
\009\009\009\009end\
\009\009\009\009local newX = math.min( x, string.len( tLines[newY] ) + 1 )\
\009\009\009\009setCursor( newX, newY )\
\009\009\009end\
\
\009\009elseif param == keys.home then\
\009\009\009-- Home\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the beginning\
\009\009\009\009if x > 1 then\
                    setCursor(1,y)\
                end\
\009\009\009end\
\
\009\009elseif param == keys[\"end\"] then\
\009\009\009-- End\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the end\
\009\009\009\009local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
    \009\009\009\009setCursor( nLimit, y )\
    \009\009    end\
\009\009\009end\
\
\009\009elseif param == keys.left then\
\009\009\009-- Left\
\009\009\009if not bMenu then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Move cursor left\
    \009\009\009\009setCursor( x - 1, y )\
\009\009\009\009elseif x==1 and y>1 then\
    \009\009\009\009setCursor( string.len( tLines[y-1] ) + 1, y - 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu left\
\009\009\009\009nMenuItem = nMenuItem - 1\
\009\009\009\009if nMenuItem < 1 then\
\009\009\009\009\009nMenuItem = #tMenuItems\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.right then\
\009\009\009-- Right\
\009\009\009if not bMenu then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009-- Move cursor right\
\009\009\009\009\009setCursor( x + 1, y )\
\009\009\009    elseif nCompletion and x == string.len(tLines[y]) + 1 then\
                    -- Accept autocomplete\
                    acceptCompletion()\
\009\009\009\009elseif x==nLimit and y<#tLines then\
\009\009\009\009    -- Go to next line\
\009\009\009\009    setCursor( 1, y + 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu right\
\009\009\009\009nMenuItem = nMenuItem + 1\
\009\009\009\009if nMenuItem > #tMenuItems then\
\009\009\009\009\009nMenuItem = 1\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.delete then\
\009\009\009-- Delete\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawLine(y)\
\009\009\009\009elseif y<#tLines then\
\009\009\009\009\009tLines[y] = tLines[y] .. tLines[y+1]\
\009\009\009\009\009table.remove( tLines, y+1 )\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.backspace then\
\009\009\009-- Backspace\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Remove character\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)\
\009\009\009        setCursor( x - 1, y )\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Remove newline\
\009\009\009\009\009local sPrevLen = string.len( tLines[y-1] )\
\009\009\009\009\009tLines[y-1] = tLines[y-1] .. tLines[y]\
\009\009\009\009\009table.remove( tLines, y )\
\009\009\009\009\009setCursor( sPrevLen + 1, y - 1 )\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.enter then\
\009\009\009-- Enter\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009-- Newline\
\009\009\009\009local sLine = tLines[y]\
\009\009\009\009local _,spaces=string.find(sLine,\"^[ ]+\")\
\009\009\009\009if not spaces then\
\009\009\009\009\009spaces=0\
\009\009\009\009end\
\009\009\009\009tLines[y] = string.sub(sLine,1,x-1)\
\009\009\009\009table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )\
\009\009\009\009setCursor( spaces + 1, y + 1 )\
\009\009\009\009redrawText()\
\
\009\009\009elseif bMenu then\
\009\009\009\009-- Menu selection\
\009\009\009\009doMenuItem( nMenuItem )\
\
\009\009\009end\
\
\009\009elseif param == keys.leftCtrl or param == keys.rightCtrl or param == keys.rightAlt then\
\009\009\009-- Menu toggle\
\009\009\009bMenu = not bMenu\
\009\009\009if bMenu then\
\009\009\009\009term.setCursorBlink( false )\
\009\009\009else\
\009\009\009\009term.setCursorBlink( true )\
\009\009\009end\
\009\009\009redrawMenu()\
\
\009\009end\
\009\009\
\009elseif sEvent == \"char\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + 1, y )\
\
\009\009elseif bMenu then\
\009\009\009-- Select menu items\
\009\009\009for n,sMenuItem in ipairs( tMenuItems ) do\
\009\009\009\009if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then\
\009\009\009\009\009doMenuItem( n )\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"paste\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + string.len( param ), y )\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_click\" then\
\009\009if not bMenu then\
\009\009\009if param == 1 then\
\009\009\009\009-- Left click\
\009\009\009\009local cx,cy = param2, param3\
\009\009\009\009if cy < h then\
\009\009\009\009\009local newY = math.min( math.max( scrollY + cy, 1 ), #tLines )\
\009\009\009\009\009local newX = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[newY] ) + 1 )\
\009\009\009\009\009setCursor( newX, newY )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_scroll\" then\
\009\009if not bMenu then\
\009\009\009if param == -1 then\
\009\009\009\009-- Scroll up\
\009\009\009\009if scrollY > 0 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009scrollY = scrollY - 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\
\009\009\009elseif param == 1 then\
\009\009\009\009-- Scroll down\
\009\009\009\009local nMaxScroll = #tLines - (h-1)\
\009\009\009\009if scrollY < nMaxScroll then\
\009\009\009\009\009-- Move cursor down\
\009\009\009\009\009scrollY = scrollY + 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\009\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"term_resize\" then\
\009    w,h = term.getSize()\
        setCursor( x, y )\
        redrawMenu()\
        redrawText()\
\
\009end\
end\
\
-- Cleanup\
term.clear()\
term.setCursorBlink( false )\
term.setCursorPos( 1, 1 )",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/ps\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION: \
\009\009This program lists every running process with their\
\009\009corresponding UID and their name (RedNet and Shell are both named function blah)\
]]--\
\
print(\"UID | Name/Path\")\
local tasks = thread.getList()\
for _, a in pairs(tasks) do\
\009if not a.dead then\
\009\009term.write(tostring(a.uid)..\" | \")\
\009\009print(tostring(a.file))\
\009end\
end",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/mkdir\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This program creates a folder in the specified path or\
\009\009in the current directory.\
]]--\
\
local function m(d)\
\009local currentDir = shell.dir()\
\009local r = false\
\009local falseDir = false\
\009local inhome = true\
\009local currentUsr = lib.perm.permission.getCurrentUser()\
\009if currentUsr ~= \"root\" then\
\009\009r = false\
\009else\
\009\009r = true\
\009end\
\009local a, b = string.find(d, \"//\")\
\009local i, j = string.find(d, \"~\")\
\009if a or i ~= nil and i == j then\
\009\009falseDir = true\
\009end\
\009local a, b = string.find(currentDir, \"/home/\"..currentUsr..\"/\")\
\009if r == false and a == nil then\
\009\009inhome = false\
\009end\
\
\009if falseDir == false then\
\
\
\009\009local path = currentDir..\"/\"..d\
\009\009local a, b = string.find(d, \"/\")\
\009\009if a == 1 then\
\009\009\009path = d\
\009\009end\
\009\009local a, b = string.find(path, \"%../\")\
\009\009if a then\
\009\009\009--d = string.gsub(d, \"/\", \"\", 1)\
\009\009\009local col = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"Invalid Path.\")\
\009\009\009term.setTextColor(col)\
\009\009\009return\
\009\009end\
\009\009local a = fs.makeDir(path)\
\009\009if a == \"noPermission\" then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"You have no privileges, try 'sudo'.\")\
\009\009\009term.setTextColor(c)\
\009\009elseif a == \"error\" then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009print(\"An error occured.\")\
\009\009\009term.setTextColor(c)\
\009\009else\
\009\009\009return true\
\009\009end\
\009elseif falseDir == true then\
\009\009local col = term.getTextColor()\
\009\009term.setTextColor(colors.red)\
\009\009print(\"Invalid path!\")\
\009\009term.setTextColor(col)\
\009\009return false\
\009else\
\009\009print(\"User not found.\")\
\009\009return false\
\009end\
end\
\
\
local tArgs = {...}\
\
if #tArgs < 1 or #tArgs > 1 then\
\009print(\"Usage:\")\
\009print(\"\009\009mkdir <folderName>\")\
else\
\009m(tArgs[1])\
end",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/clear\
\009CATEGORY:    Binary\
\009SET:         Core Binary\
\009VERSION:     01:alpha0\
\009DESCRIPTION: \
\009\009This program clears the screen.\
]]--\
\
term.setCursorPos(1,1)\
term.setBackgroundColor(colors.black)\
term.clear()",
      "--[[\
\009Configuration file for the\
\009cLinux GRUB menu.\
]]\
\
{\
\009list = {\009\009\009\009--This contains the paths to every image you want to boot. (they need to be in /boot/)\
\009\009\"clinux.i\",\
\009\009\"CraftOS\",\
\009},\
\009command = {\009\009\009--The default command, which the command is booted with (Please in same order as above)\
\009\009\"\",\
\009\009\"\",\
\009},\
\009default = 1\
}",
      "{\
  ['dir'] = \"/bin/ls\"\
}",
      "{\
\009mainBg = 1,\
\009mainFg = 32768,\
\009middleBg = 1,\
\009middleFg = 32768,\
\009pathBg = 1,\
\009userBg = 1,\
\009userFg = 16384,\
}",
      "--[[\
\009cLinux: Ran out of lores... already\
\009Made by Piorjade, daelvn\
\
\009NAME:        /sys/thread.l\
\009CATEGORY:    library\
\009SET:         Core Libraries I\
\009VERSION:     09:beta2\
\009DESCRIPTION:\
\009\009Manages coroutines of a GIVEN tasklist\
\009\009The tasklist should look like the following:\
\
\009\009mytasklist = {\
\009\009\009last_uid = 0,\
\009\009\009somethingInFG = false,\
\009\009\009list = {},\
\009\009}\
\
\
\
\009\009Almost every function needs the tasklist to work.\
]]--\
\
--Define thread table (containing the main functions)\
local thread = {}\
--Function to create a new thread\
function thread.new(p, env, name, tasklist, tArgs, logfunc)\
\009if not p then return end\
\009if not env then return end\
\009if not name then\
\009\009name = tostring(p)\
\009end\
\009--load p as function, if it's a path (string)\
\009if type(p) ~= \"function\" then\
\009\009if type(p) == \"string\" then\
\009\009\009p, err = loadfile(p)\
\009\009\009if not p then\
\009\009\009\009return false, err\
\009\009\009end\
\009\009else\
\009\009\009return false, \"function expected, got \"..type(p)\
\009\009end\
  end\
\009local uid = tasklist.last_uid+1\
\009tasklist.last_uid = tasklist.last_uid+1\
\009--define self, containing important functions and variables\
\009local self = {}\
\009--set self.function as p, with a new environment\
\009setfenv(p, env)\
\009local tAPIsLoading = {}\
\009function env.os.loadAPI( _sPath )\
\009\009\009print(\"Loading \".._sPath)\
\009\009\009sleep(2)\
\009    local sName = fs.getName( _sPath )\
\009    if tAPIsLoading[sName] == true then\
\009        printError( \"API \"..sName..\" is already being loaded\" )\
\009        return false\
\009    end\
\009    tAPIsLoading[sName] = true\
\
\009    local tEnv = {}\
\009    setmetatable( tEnv, { __index = _G } )\
\009    local fnAPI, err = loadfile( _sPath, tEnv )\
\009    if fnAPI then\
\009        local ok, err = pcall( fnAPI )\
\009        if not ok then\
\009            printError( err )\
\009            tAPIsLoading[sName] = nil\
\009            return false\
\009        end\
\009    else\
\009        printError( err )\
\009        tAPIsLoading[sName] = nil\
\009        return false\
\009    end\
\
\009    local tAPI = {}\
\009    for k,v in pairs( tEnv ) do\
\009        if k ~= \"_ENV\" then\
\009            tAPI[k] =  v\
\009        end\
\009    end\
\009    tAPIsLoading[sName] = nil\
\009\009\009env[sName] = tAPI\
\009\009\009_G[sName] = tAPI\
\009    return true\
\009end\
\009self.func = p\
\009self.task = coroutine.create(self.func)\
\009self.dead = false\
\009self.name = name\
\009self.background = true\
\
\
\
\009--get the current user and save his data\
\009if logfunc ~= nil then\
\009\009self.userName, self.userPassword = logfunc.name, logfunc.password\
\009end\
\
\009self.uid = uid\
\009self.filter = nil\
\009--resume/start the coroutine (function/file)\
\009--saveArgs is to store the arguments and execute the program after resume is being called the 2nd time\
\009function self.resume(args)\
\009\009local fst = args\
\009\009if self.startArgs ~= nil then\
\009\009\009fst = self.startArgs\
\009\009\009self.startArgs = nil\
\009\009end\
\009\009local stat = coroutine.status(self.task)\
\009\009if stat == \"dead\" then self.dead = true end\
\009\009if not self.dead and self.filter == nil or not self.dead and self.filter == fst[1] then\
\009\009\009if self.userName ~= nil then\
\009\009\009\009lib.perm.permission.saveOld()\
\009\009\009\009lib.perm.permission.login(self.userName, self.userPassword, true)\
\009\009\009end\
\009\009\009local ok, err = coroutine.resume(self.task, table.unpack(fst))\
\009\009\009if self.userName ~= nil then\
\009\009\009\009lib.perm.permission.reLog()\
\009\009\009end\
\009\009\009if ok then\
\009\009\009\009local stat = coroutine.status(self.task)\
\009\009\009\009if stat == \"dead\" then\
\009\009\009\009\009self.dead = true\
\009\009\009\009else\
\009\009\009\009\009self.filter = err\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return false, err\
\009\009\009end\
\009\009elseif self.dead then\
\009\009\009return false, \"is dead\"\
\009\009end\
\009end\
\009if tArgs ~= nil then\
\009\009env['startArgs'] = tArgs\
\009\009self.startArgs = tArgs\
\009end\
\009--insert self into tasks\
\009table.insert(tasklist.list, self)\
\009return true, uid\
end\
--resume a specific task (by given name)\
function thread.resume(name, tasklist, ...)\
\009for uid, v in ipairs(tasklist.list) do\
\009\009if v.name == name then\
\009\009\009local targs = {...}\
\009\009\009local ok, err = tasklist.list[uid].resume(table.unpack(targs))\
\009\009\009if not ok then\
\009\009\009\009return false, err\
\009\009\009else\
\009\009\009\009return true\
\009\009\009end\
\009\009\009break\
\009\009end\
\009end\
\
end\
\
--search thread by name and return status\
function thread.getStatus(name, tasklist)\
\009for k, v in ipairs(tasklist.list) do\
\009\009if v.name == name then\
\009\009\009if v.dead then\
\009\009\009\009return \"dead\"\
\009\009\009else\
\009\009\009\009return \"yielding\"\
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
--kill a task, in the given tasklist of course, with the UID as number\
\
function thread.kill(tasklist, uid)\
\009--check if the uid is a string, convert to number\
\009if type(uid) == \"string\" then uid = tonumber(uid) end\
\009if uid == nil then return end\
\009for k, v in pairs(tasklist.list) do\
\009\009if v.uid == uid then\
\009\009\009tasklist.list[k] = nil\
\009\009\009return true\
\009\009end\
\009end\
\009return nil\
end\
\
--resume all tasks, with optionally given arguments/events\
function thread.resumeAll(tasklist, tArgs)\
\009for k, v in ipairs(tasklist.list) do\
\009\009if not v.dead then\
\009\009\009if _G.shell then\
\009\009\009\009_G.shell.getRunningProgram = function()\
\009\009\009\009\009return v.name\
\009\009\009\009end\
\009\009\009end\
\009\009\009if not tasklist.somethingInFG then\
\009\009\009\009local ok, err = v.resume(tArgs)\
\009\009\009\009if ok == false then\
\009\009\009\009\009cLinuxPrintError(v.name, err)\
\009\009\009\009\009--return false\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009if v.background == false then\
\009\009\009\009\009local ok, err = v.resume(tArgs)\
\009\009\009\009\009if ok == false then\
\009\009\009\009\009\009cLinuxPrintError(v.name, err)\
\009\009\009\009\009\009--return false\
\009\009\009\009\009end\
\009\009\009\009\009local ok = thread.getStatus(v.name, tasklist)\
\009\009\009\009\009if ok == \"dead\" then\
\009\009\009\009\009\009v.background = true\
\009\009\009\009\009\009tasklist.somethingInFG = false\
\009\009\009\009\009\009table.remove(tasklist.list, k)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
end\
\
\
_put(\"thread\", thread)",
      "90d9c7e4bb977d074e8d665b09ac6463929e5060acf132f788e5053568376d0c",
      "{\
  test = \"e0b6a59f093659fd6bb24a0fb3dc68287a50ec8791dccb9fef9970bf0813f4ff\",\
}",
      "\
\
--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /sys/perm.l\
\009CATEGORY:    Library\
\009SET:         Core Library\
\009VERSION:     02:alpha6\
\009DESCRIPTION:\
\009\009This script manages users and their permissions.\
\009\009Most of these functions are selfexplaining.\
]]--\
\
local old = {}\
old['fs'] = fs\
local sha = os.loadAPI(\"/lib/sha.l\")\
local forbidden = {\"/boot\", \"/vit\", \"/bin\", \"/startup\", \"/sys\"}\
local perm = {}\
local name = \"\"\
local password = \"\"\
local oldname = \"\"\
local oldpassword = password\
local _users = nil\
\
\
--Initiate system\
if _users == nil then\
\009_users = {}\
\009if fs.exists(\"/sys/usrData\") then\
\009\009local file = old.fs.open(\"/sys/usrData\", \"r\")\
\009\009local inhalt = file.readAll()\
\009\009_users = textutils.unserialize(inhalt)\
\009\009file.close()\
\009else\
\009\009local file = old.fs.open(\"/sys/usrData\", \"w\")\
\009\009file.write(textutils.serialize(_users))\
\009\009file.close()\
\009end\
end\
\
--Hash a password with the given salt and return the hashed password, open for all programs\
function hashPw(p, salt)\
\009local str = pbkdf2(p, salt, 10):toHex()\
\009return tostring(str)\
end\
\
_put('hashPw', hashPw)\
\
local usrs = {}\
\
--Return the list of every registered user\
function usrs.getList()\
\009local inhalt = {}\
\009for k, v in pairs(_users) do\
\009\009table.insert(inhalt, k)\
\009end\
\009return inhalt\
end\
\
--set the current user\
local function setUsr(n, p)\
\009name = n\
\009password = p\
end\
\
\
--self explaining\
function usrs.addUser(nm, pw)\
\009if _users[nm] or nm == \"root\" or fs.exists(\"/home/\"..nm) then return false, \"exists\" end\
\009local i = usrs.getList()\
\009local oldname = name\
\009local oldpw = password\
\009if #i < 1 then\
\009\009--first run\
\009\009local n = \"root\"\
\009\009local file = fs.open(\"/sys/.rootpw\", \"r\")\
\009\009local p = file.readLine()\
\009\009file.close()\
\009\009setUsr(n, p)\
\009end\
\009pw = hashPw(pw, nm)\
\009_users[nm] = pw\
\009local file = old.fs.open(\"/sys/usrData\", \"w\")\
\009file.write(textutils.serialize(_users))\
\009file.close()\
\009old.fs.makeDir(\"/home/\"..nm)\
\009setUsr(oldname, oldpw)\
\009return true\
end\
\
function usrs.checkRootPw(p)\
\009local file = old.fs.open(\"/sys/.rootpw\", \"r\")\
\009local pw = file.readLine()\
\009file.close()\
\009if p == pw then\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
\
function usrs.removeUser(name, rpw)\
\009if name == nil or rpw == nil or name == \"root\" then return end\
\009if _users[name] then\
\009\009local rpw = hashPw(rpw, \"root\")\
\009\009local a = perm.checkRootPw(rpw)\
\009\009if a == false then\
\009\009\009return false\
\009\009elseif a == true then\
\009\009\009old.fs.delete(\"/home/\"..name)\
\009\009\009_users[name] = nil\
\009\009\009local file = old.fs.open(\"/sys/usrData\", \"w\")\
\009\009\009file.write(textutils.serialize(_users))\
\009\009\009file.close()\
\009\009end\
\009else\
\009\009return nil\
\009end\
end\
\
function usrs.changePw(name, oldPw, newPw)\
\009if #name < 1 or #oldPw < 1 or #newPw < 1 then return nil end\
\009if _users[name] and name ~= \"root\" then\
\009\009local oldPw = hashPw(oldPw, name)\
\009\009if oldPw == _users[name] then\
\009\009\009local nPw = hashPw(newPw, name)\
\009\009\009_users[name] = nPw\
\009\009\009local file = old.fs.open(\"/sys/usrData\", \"w\")\
\009\009\009file.write(textutils.serialize(_users))\
\009\009\009file.close()\
\009\009\009return true\
\009\009else\
\009\009\009return false, \"Wrong password.\"\
\009\009end\
\009elseif name == \"root\" then\
\009\009local oldPw = hashPw(oldPw, name)\
\009\009local newPw = hashPw(newPw, name)\
\009\009if usrs.checkRootPw(oldPw) then\
\009\009\009local file = old.fs.open(\"/sys/.rootpw\", \"w\")\
\009\009\009file.writeLine(newPw)\
\009\009\009file.close()\
\009\009else\
\009\009\009return false, \"Wrong password.\"\
\009\009end\
\009else\
\009\009return nil, \"User does not exist.\"\
\009end\
end\
\
function usrs.changeName(oldname, newname, pw)\
\009if oldname and newname and pw then\
\009\009if #oldname < 1 or #newname < 1 or #pw < 1 then return nil end\
\009\009if fs.exists(\"/home/\"..newname) or _users[newname] then return \"exists\" end\
\009\009if _users[oldname] and oldname ~= \"root\" then\
\009\009\009local ps = hashPw(pw, oldname)\
\009\009\009if ps == _users[oldname] then\
\009\009\009\009_users[newname] = hashPw(pw, newname)\
\009\009\009\009_users[oldname] = nil\
\009\009\009\009if fs.exists(\"/home/\"..oldname) then\
\009\009\009\009\009fs.move(\"/home/\"..oldname, \"/home/\"..newname)\
\009\009\009\009else\
\009\009\009\009\009fs.makeDir(\"/home/\"..newname)\
\009\009\009\009end\
\009\009\009\009local file = old.fs.open(\"/sys/usrData\", \"w\")\
\009\009\009\009file.write(textutils.serialize(_users))\
\009\009\009\009file.close()\
\009\009\009\009return true\
\009\009\009else\
\009\009\009\009return false, \"Wrong Password\"\
\009\009\009end\
\009\009elseif oldname == \"root\" then\
\009\009\009return false, \"Can't change root\"\
\009\009else\
\009\009\009return nil, \"User doesn't exist\"\
\009\009end\
\009end\
end\
\
local permission = {}\
\
function permission.check(f)\
\009if folder == f and name ~= \"root\" then return \"x\" end\009--Not finished\
\009local found = false\
\009for each, folder in ipairs(forbidden) do\
\009\009local i, j = string.find(f, folder)\
\009\009if i == 1 and name ~= \"root\" then\
\009\009\009found = true\
\009\009\009break\
\009\009else\
\009\009\009found = false\
\009\009end\
\009end\
\009if found then\
\009\009return \"x\"\
\009else\
\009\009return \"w\"\
\009end\
\009return nil\
end\
\
function permission.saveOld()\
\009oldname = name\
\009oldpassword = password\
\009return\
end\
\
function permission.login(n, p, nohash)\
\009if n == nil or p == nil then return nil end\
\009if not nohash then\
\009\009p = hashPw(p, n)\
\009end\
\009local file = old.fs.open(\"/sys/usrData\", \"r\")\
\009local inhalt = file.readAll()\
\009file.close()\
\009inhalt = textutils.unserialize(inhalt)\
\009if n ~= \"root\" and inhalt[n] then\
\009\009if p == inhalt[n] then\
\009\009\009name = n\
\009\009\009password = p\
\009\009\009return true\
\009\009else\
\009\009\009return false\
\009\009end\
\009elseif n == \"root\" then\
\009\009local file = old.fs.open(\"/sys/.rootpw\", \"r\")\
\009\009local rpw = file.readLine()\
\009\009file.close()\
\009\009if p == rpw then\
\009\009\009name = \"root\"\
\009\009\009password = p\
\009\009\009return true\
\009\009else\
\009\009\009return false\
\009\009end\
\009elseif inhalt[n] == nil then\
\009\009return nil\
\009end\
end\
\
function permission.reLog()\
\009if oldname then\
\009\009name = oldname\
\009\009password = oldpassword\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
\
function permission.getCurrentUser()\
\009return name, password\
end\
\
perm['permission'] = permission\
perm['usrs'] = usrs\
perm['hashPw'] = hashPw\
_putLib('perm', perm)",
      "--[[\
\009cLinux: Ran out of lores... already\
\009Made by Piorjade, daelvn\
\
\009NAME:        /sys/sThread.l\
\009CATEGORY:    library\
\009SET:         Native Libraries I\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009Manages the coroutines, used in shell. (mainly services)\
\
\009\009PLEASE USE /lib/thread.l FOR YOUR PROGRAMS, WAY BETTER\
]]--\
\
\
\
sThread = {}\
\
local errors = {\
\009ok = \"noError\",\
\009err = nil,\
}\
local started = {}\
local windows = {}\
local last_uid = 0\
local mainwindow = nil\
local mainuid = nil\
local lastx, lasty = 1, 1\
\
function sThread.getStatus(tasklist, uid)\
\009if tasklist[uid] then\
\009\009return tasklist[uid].status\
\009else\
\009\009return nil\
\009end\
end\
\
\
function sThread.new(file, uid, fg, width, height, parent, main, lx, ly, args) --fg is a boolean if the process should show term drawing\
\009if fg == nil then\
\009\009fg = true\
\009end\
\009if main == nil then\
\009\009main = false\009\009--main indicates if that thread is the core window, for example the commandline\
\009end\
\009uid = uid or last_uid + 1\
\009last_uid = last_uid + 1\
\009extra = extra or {}\
\009local self = {}\
\009self.main = false\
\009self.lastx, self.lasty = 1, 1\
\009if width ~= nil then\
\009\009if parent == nil then\
\009\009\009parent = mainwindow\
\009\009end\
\009\009self.window = window.create(parent, 1, 1, width, height, fg)\
\009\009self.window.clear()\
\009end\
\009if main == true then\
\009\009self.main = true\
\009\009mainuid = uid\
\009\009mainwindow = self.window\
\009\009if lx ~= nil then\
\009\009\009self.lastx = lx\
\009\009else\
\009\009\009self.lastx = 1\
\009\009end\
\009\009if ly ~= nil then\
\009\009\009self.lasty = ly\
\009\009else\
\009\009\009self.lasty = 1\
\009\009end\
\009\009lastx = self.lastx\
\009\009lasty = self.lasty\
\009else\
\009\009self.main = false\
\009end\
\
\009self.uid = uid\
\009local function _copy(a, b)\
\009\009for k, v in pairs(a) do\
\009\009\009b[k] = v\
\009\009end\
\009\009for k, v in pairs(_G.lib) do\
\009\009\009b['lib'][k] = v\
\009\009end\
\009end\
\009self.env = {}\
\
\009_copy(_G, self.env)\
\009blacklist = {'rawget', 'rawset', 'dofile', 'sThread','old'}\009--things that shouldn't get added, and extras\
\009for k, v in ipairs(blacklist) do self.env[v] = nil end\
\009setmetatable(self.env, {__index = _G.lib})\
\009if not fs.exists(file) then\
\009\009return false, \"File not found.\"\
\009end\
\009self.task, err = loadfile(file)\
\
\009if not self.task then\
\009\009return false, err\
\009end\
\009--setfenv(self.task, self.env)\
\009self.thread = coroutine.create(self.task)\
\009self.file = tostring(file)\
\009self.filter = nil\
\009self.error = nil\
\009self.dead = false\
\009self.status = \"suspended\"\
\009self.queue = {}\
\009if args then\
\009\009self.args = args\
\009else\
\009\009self.args = nil\
\009end\
\009self.resume = function(...)\
\009\009local fst = {}\
\009\009if not self.args then\
\009\009\009fst = {...}\
\009\009else\
\009\009\009fst = {unpack(self.args)}\
\009\009\009self.args = nil\
\009\009end\
\009\009if not self.dead then\
\009\009\009ok, err = coroutine.resume(self.thread, unpack(fst))\
\009\009\009self.lastx, self.lasty = term.getCursorPos()\
\009\009\009if self.main == true then\
\009\009\009\009lastx = self.lastx\
\009\009\009\009lasty = self.lasty\
\009\009\009end\
\009\009\009if ok then\
\009\009\009\009self.filter = err\
\009\009\009\009self.status = coroutine.status(self.thread)\
\009\009\009\009if self.status == \"dead\" then self.dead = true end\
\009\009\009\009return ok, err\
\009\009\009else\
\009\009\009\009self.status = coroutine.status(self.thread)\
\009\009\009\009if self.status == \"dead\" then self.dead = true end\
\009\009\009\009return ok, err\
\009\009\009end\
\009\009else\
\009\009\009return false, \"is dead\"\
\009\009end\
\009\009--end\
\009end\
\009started[self.uid] = self\
\009self.next = started\
\009return self\
end\
\
function sThread.queue(process, event, parameters)\
\009process.queue[#process.queue+1] = {event = event, parameters = parameters}\
\009return true\
end\
\
function sThread.kill(process)\
\009process.dead = true\
\009process.status = \"dead\"\
end\
\
function sThread.killAll(tasklist)\
\009if not flag.STATE_SHUTDOWN or not flag.STATE_RESTART then return false end\
\009for uid, task in pairs(tasklist) do\
\009\009\009sThread.kill(task)\
\009end\
end\
\
function sThread.getError()\
\009if errors.ok ~= \"noError\" then\
\009\009local oldok, olderr = errors.ok, errors.err\
\009\009errors.ok, errors.err = \"noError\", nil\
\009\009return oldok, olderr\
\009else\
\009\009return \"noError\"\
\009end\
end\
\
function sThread.runAll(tasklist)\
\009evt = {\"key\", keys.l}\
\009while true do\
\009\009if #tasklist < 1 then\
\009\009\009break\
\009\009end\
\009\009for uid, task in ipairs(tasklist) do\
\009\009\009if task.dead then\
\009\009\009\009table.remove(tasklist, uid)\
\009\009\009\009last_uid = #tasklist\
\009\009\009else\
\009\009\009\009ok, err = task.resume(unpack(evt))\
\009\009\009\009if ok == nil or ok == true then\
\
\009\009\009\009else\
\009\009\009\009\009errors.ok = ok\
\009\009\009\009\009errors.err = err\
\009\009\009\009\009table.remove(tasklist, uid)\
\009\009\009\009\009last_uid = #tasklist\
\009\009\009\009\009--[[if uid == 1 then\
\009\009\009\009\009\009flag.STATE_DEAD = true\
\009\009\009\009\009\009return false, ok\
\009\009\009\009\009end]]\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009if #tasklist < 1 then\
\009\009\009break\
\009\009end\
\009\009evt = {os.pullEventRaw()}\
\009end\
\009return\
end\
\
_put('sThread', sThread)",
      "\
CHANNEL_BROADCAST = 65535\
CHANNEL_REPEAT = 65533\
\
local tReceivedMessages = {}\
local tReceivedMessageTimeouts = {}\
local tHostnames = {}\
\
function open( sModem )\
\009if type( sModem ) ~= \"string\" then\
\009\009error( \"expected string\", 2 )\
\009end\
\009if peripheral.getType( sModem ) ~= \"modem\" then\009\
\009\009error( \"No such modem: \"..sModem, 2 )\
\009end\
\009peripheral.call( sModem, \"open\", os.getComputerID() )\
\009peripheral.call( sModem, \"open\", CHANNEL_BROADCAST )\
end\
\
function close( sModem )\
    if sModem then\
        -- Close a specific modem\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) ~= \"modem\" then\
            error( \"No such modem: \"..sModem, 2 )\
        end\
        peripheral.call( sModem, \"close\", os.getComputerID() )\
        peripheral.call( sModem, \"close\", CHANNEL_BROADCAST )\
    else\
        -- Close all modems\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                close( sModem )\
            end\
        end\
    end\
end\
\
function isOpen( sModem )\
    if sModem then\
        -- Check if a specific modem is open\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) == \"modem\" then\
            return peripheral.call( sModem, \"isOpen\", os.getComputerID() ) and peripheral.call( sModem, \"isOpen\", CHANNEL_BROADCAST )\
        end\
    else\
        -- Check if any modem is open\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                return true\
            end\
        end\
    end\
\009return false\
end\
\
function send( nRecipient, message, sProtocol )\
    -- Generate a (probably) unique message ID\
    -- We could do other things to guarantee uniqueness, but we really don't need to\
    -- Store it to ensure we don't get our own messages back\
    local nMessageID = math.random( 1, 2147483647 )\
    tReceivedMessages[ nMessageID ] = true\
    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\
    -- Create the message\
    local nReplyChannel = os.getComputerID()\
    local tMessage = {\
        nMessageID = nMessageID,\
        nRecipient = nRecipient,\
        message = message,\
        sProtocol = sProtocol,\
    }\
\
    if nRecipient == os.getComputerID() then\
        -- Loopback to ourselves\
        os.queueEvent( \"rednet_message\", nReplyChannel, message, sProtocol )\
\
    else\
        -- Send on all open modems, to the target and to repeaters\
        local sent = false\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                peripheral.call( sModem, \"transmit\", nRecipient, nReplyChannel, tMessage );\
                peripheral.call( sModem, \"transmit\", CHANNEL_REPEAT, nReplyChannel, tMessage );\
                sent = true\
            end\
        end\
    end\
end\
\
function broadcast( message, sProtocol )\
\009send( CHANNEL_BROADCAST, message, sProtocol )\
end\
\
function receive( sProtocolFilter, nTimeout )\
    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility\
    if type(sProtocolFilter) == \"number\" and nTimeout == nil then\
        sProtocolFilter, nTimeout = nil, sProtocolFilter\
    end\
\
    -- Start the timer\
\009local timer = nil\
\009local sFilter = nil\
\009if nTimeout then\
\009\009timer = os.startTimer( nTimeout )\
\009\009sFilter = nil\
\009else\
\009\009sFilter = \"rednet_message\"\
\009end\
\
\009-- Wait for events\
\009while true do\
\009\009local sEvent, p1, p2, p3 = os.pullEvent( sFilter )\
\009\009if sEvent == \"rednet_message\" then\
\009\009    -- Return the first matching rednet_message\
\009\009\009local nSenderID, message, sProtocol = p1, p2, p3\
\009\009\009if sProtocolFilter == nil or sProtocol == sProtocolFilter then\
    \009\009\009return nSenderID, message, sProtocol\
    \009    end\
\009\009elseif sEvent == \"timer\" then\
\009\009    -- Return nil if we timeout\
\009\009    if p1 == timer then\
    \009\009\009return nil\
    \009\009end\
\009\009end\
\009end\
end\
\
function host( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" or type( sHostname ) ~= \"string\" then\
        error( \"expected string, string\", 2 )\
    end\
    if sHostname == \"localhost\" then\
        error( \"Reserved hostname\", 2 )\
    end\
    if tHostnames[ sProtocol ] ~= sHostname then\
        if lookup( sProtocol, sHostname ) ~= nil then\
            error( \"Hostname in use\", 2 )\
        end\
        tHostnames[ sProtocol ] = sHostname\
    end\
end\
\
function unhost( sProtocol )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
    tHostnames[ sProtocol ] = nil\
end\
\
function lookup( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
\
    -- Build list of host IDs\
    local tResults = nil\
    if sHostname == nil then\
        tResults = {}\
    end\
\
    -- Check localhost first\
    if tHostnames[ sProtocol ] then\
        if sHostname == nil then\
            table.insert( tResults, os.getComputerID() )\
        elseif sHostname == \"localhost\" or sHostname == tHostnames[ sProtocol ] then\
            return os.getComputerID()\
        end\
    end\
\
    if not isOpen() then\
        if tResults then\
            return table.unpack( tResults )\
        end\
        return nil\
    end\
\
    -- Broadcast a lookup packet\
    broadcast( {\
        sType = \"lookup\",\
        sProtocol = sProtocol,\
        sHostname = sHostname,\
    }, \"dns\" )\
\
    -- Start a timer\
    local timer = os.startTimer( 2 )\
\
    -- Wait for events\
    while true do\
        local event, p1, p2, p3 = os.pullEvent()\
        if event == \"rednet_message\" then\
            -- Got a rednet message, check if it's the response to our request\
            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3\
            if sMessageProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup response\" then\
                if tMessage.sProtocol == sProtocol then\
                    if sHostname == nil then\
                        table.insert( tResults, nSenderID )\
                    elseif tMessage.sHostname == sHostname then\
                        return nSenderID\
                    end\
                end\
            end\
        else\
            -- Got a timer event, check it's the end of our timeout\
            if p1 == timer then\
                break\
            end\
        end\
    end\
    if tResults then\
        return table.unpack( tResults )\
    end\
    return nil\
end\
\
local bRunning = false\
function run()\
\009if bRunning then\
\009\009error( \"rednet is already running\", 2 )\
\009end\
\009bRunning = true\
\009\
\009while bRunning do\
\009\009local sEvent, p1, p2, p3, p4 = os.pullEventRaw()\
\009\009if sEvent == \"modem_message\" then\
\009\009\009-- Got a modem message, process it and add it to the rednet event queue\
    \009\009local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4\
\009\009    if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then\
    \009\009\009if type( tMessage ) == \"table\" and tMessage.nMessageID then\
\009    \009\009\009if not tReceivedMessages[ tMessage.nMessageID ] then\
\009\009    \009\009\009tReceivedMessages[ tMessage.nMessageID ] = true\
                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\009\009\009    \009\009os.queueEvent( \"rednet_message\", nReplyChannel, tMessage.message, tMessage.sProtocol )\
\009\009\009\009    end\
\009\009\009    end\
\009\009\009end\
\
\009\009elseif sEvent == \"rednet_message\" then\
\009\009    -- Got a rednet message (queued from above), respond to dns lookup\
\009\009    local nSenderID, tMessage, sProtocol = p1, p2, p3\
\009\009    if sProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup\" then\
\009\009        local sHostname = tHostnames[ tMessage.sProtocol ]\
\009\009        if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then\
\009\009            rednet.send( nSenderID, {\
\009\009                sType = \"lookup response\",\
\009\009                sHostname = sHostname,\
\009\009                sProtocol = tMessage.sProtocol,\
\009\009            }, \"dns\" )\
\009\009        end\
\009\009    end\
\
\009\009elseif sEvent == \"timer\" then\
            -- Got a timer event, use it to clear the event queue\
            local nTimer = p1\
            local nMessage = tReceivedMessageTimeouts[ nTimer ]\
            if nMessage then\
                tReceivedMessageTimeouts[ nTimer ] = nil\
                tReceivedMessages[ nMessage ] = nil\
            end\
\009\009end\
\009end\
end",
      "\
--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /bin/shell\
\009CATEGORY:    boot\
\009SET:         Boot III\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This script is ran after /boot/load\
\009\009and starts the basic services up.\
]]--\
--[[local ok = perm.permission.login(\"patrick\", \"\")\
if not ok then\
\009print(\"login failed\")\
\009sleep(1)\
else\
\009print(\"login success\")\
\009sleep(1)\
end]]\
local tasks = {}\
local curPath = \"/\"\
local maintask = 0\
local thread = sThread\
term.setCursorPos(1,1)\
term.setBackgroundColor(colors.black)\
term.setTextColor(colors.white)\
term.clear()\
--_put('os', lib.os)\
\
--[[\
\009\009\009\009\009\009##EXPERIMENTAL##\
\009\009\009\009PLEASE REPORT BUGS IN THE FORUM POST\
\
\009\009\009\009\009--Shell API dummies--\
\009\009\009\009\009(simulate shell functions)\
]]\
shell = {}\
function shell.run(path, ...)\
\009if not string.find(path, \"/\", 1, 1) then\
\009\009path = \"/bin/\"..path\
\009end\
\009local tArgs = {...}\
\009local c = path\
\009local counter = 1\
\009repeat\
\009\009local i, j = string.find(c, \" \")\
\009\009if i then\
\009\009\009if counter == 1 then\
\009\009\009\009path = string.sub(c, 1, i-1)\
\009\009\009\009c = string.sub(c, j+1)\
\009\009\009\009counter = counter+1\
\009\009\009else\
\009\009\009\009local arg = string.sub(c, 1, i-1)\
\009\009\009\009if not arg then\
\009\009\009\009\009printError(\"Fatal Error.\")\
\009\009\009\009\009return false\
\009\009\009\009end\
\009\009\009\009c = string.sub(c, j+1)\
\009\009\009\009if not a then\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009\009table.insert(tArgs, arg)\
\009\009\009\009counter = counter+1\
\009\009\009end\
\009\009elseif counter > 1 then\
\009\009\009table.insert(tArgs, c)\
\009\009end\
\009until i == nil\
\009local function _copy(a, b)\
\009\009for k, v in pairs(a) do\
\009\009\009b[k] = v\
\009\009end\
\009\009for k, v in pairs(b['lib']) do\
\009\009\009b[k] = v\
\009\009end\
\009end\
\009local env = {}\
\009_copy(_G, env)\
\009blacklist = {'rawget', 'rawset', 'dofile', 'flag'}\009--things that shouldn't get added, and extras\
\009for k, v in ipairs(blacklist) do env[v] = nil end\
\009return os.run(env, path, unpack(tArgs))\
end\
function shell.exit()\
\009flag.STATE_SHUTDOWN = true\
\009thread.killAll(tasks)\
\009return\
end\
function shell.dir()\
\009return curPath\
end\
function shell.setDir(p)\
\009if fs.exists(p) and fs.isDir(p) then\
\009\009local i, j = string.find(p, \"/\", 1, 1)\
\009\009if not string.find(p, \"/\", #p) then p = p..\"/\" end\
\009\009if i then\
\009\009\009curPath = p\
\009\009else\
\009\009\009curPath = \"/\"..p\
\009\009end\
\009\009return\
\009elseif fs.exists(curPath..p) and fs.isDir(curPath..\"/\"..p) then\
\009\009curPath = curPath..p\
\009\009if not string.find(curPath, \"/\", #curPath) then curPath = curPath..\"/\" end\
\009\009return\
\009elseif fs.exists(p) == false or fs.isDir(p) == false then\
\009\009return false\
\009end\
end\
function shell.path()\
\009local str = \"\"\
\009for _, a in pairs(tasks) do\
\009\009str = str..\":\".._\
\009end\
\009return str\
end\
function shell.setPath()\
\009return nil\
end\
function shell.resolve(p)\
\009if string.find(p, \"/\", 1, 1) then\
\009\009return p\
\009else\
\009\009return curPath..\"/\"..p\
\009end\
end\
function shell.resolveProgram(p)\
\009if fs.exists(\"/bin/\"..p) then\
\009\009return \"/bin/\"..p\
\009else\
\009\009return nil\
\009end\
end\
function shell.aliases()\
\009return nil\
end\
function shell.setAlias()\
\009return nil\
end\
function shell.clearAlias()\
\009return nil\
end\
function shell.programs(hidden)\
\009local a = fs.list(\"/bin/\")\
\009local x = fs.list(shell.dir())\
\009for _, b in ipairs(x) do\
\009\009table.insert(a, b)\
\009end\
\009if hidden then\
\009\009return a\
\009else\
\009\009for _, b in ipairs(a) do\
\009\009\009local i = string.sub(b, 1, 1)\
\009\009\009if i == \".\" then\
\009\009\009\009table.remove(a, _)\
\009\009\009end\
\009\009end\
\009\009return a\
\009end\
end\
\
function shell.openTab()\
\009return nil\
end\
function shell.switchTab()\
\009return nil\
end\
local function tokenise( ... )\
    local sLine = table.concat( { ... }, \" \" )\
\009local tWords = {}\
    local bQuoted = false\
    for match in string.gmatch( sLine .. \"\\\"\", \"(.-)\\\"\" ) do\
        if bQuoted then\
            table.insert( tWords, match )\
        else\
            for m in string.gmatch( match, \"[^ \\t]+\" ) do\
                table.insert( tWords, m )\
            end\
        end\
        bQuoted = not bQuoted\
    end\
    return tWords\
end\
local tCompletionInfo = {}\
local function completeProgramArgument( sProgram, nArgument, sPart, tPreviousParts )\
    local tInfo = tCompletionInfo[ sProgram ]\
    if tInfo then\
        return tInfo.fnComplete( shell, nArgument, sPart, tPreviousParts )\
    end\
    return nil\
end\
local function completeProgram( sLine )\
\009if #sLine > 0 and string.sub( sLine, 1, 1 ) == \"/\" then\
\009    -- Add programs from the root\
\009    return fs.complete( sLine, \"\", true, false )\
\
    else\
        local tResults = {}\
        local tSeen = {}\
\
        -- Add aliases\
\
        -- Add programs from the path\
        local tPrograms = shell.programs()\
        for n=1,#tPrograms do\
            local sProgram = tPrograms[n]\
            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then\
                local sResult = string.sub( sProgram, #sLine + 1 )\
                if not tSeen[ sResult ] then\
                    table.insert( tResults, sResult )\
                    tSeen[ sResult ] = true\
                end\
            end\
        end\
\
        -- Sort and return\
        table.sort( tResults )\
        return tResults\
    end\
end\
\
function shell.complete(sLine)\
\009if #sLine > 0 then\
        local tWords = tokenise( sLine )\
        local nIndex = #tWords\
        if string.sub( sLine, #sLine, #sLine ) == \" \" then\
            nIndex = nIndex + 1\
        end\
        if nIndex == 1 then\
            local sBit = tWords[1] or \"\"\
            local sPath = shell.resolveProgram( sBit )\
            if tCompletionInfo[ sPath ] then\
                return { \" \" }\
            else\
                local tResults = completeProgram( sBit )\
                for n=1,#tResults do\
                    local sResult = tResults[n]\
                    local sPath = shell.resolveProgram( sBit .. sResult )\
                    if tCompletionInfo[ sPath ] then\
                        tResults[n] = sResult .. \" \"\
                    end\
                end\
                return tResults\
            end\
\
        elseif nIndex > 1 then\
            local sPath = shell.resolveProgram( tWords[1] )\
            local sPart = tWords[nIndex] or \"\"\
            local tPreviousParts = tWords\
            tPreviousParts[nIndex] = nil\
            return completeProgramArgument( sPath , nIndex - 1, sPart, tPreviousParts )\
\
        end\
    end\
\009return nil\
end\
\
\
function shell.setCompletionFunction( sProgram, fnComplete )\
    tCompletionInfo[ sProgram ] = {\
        fnComplete = fnComplete\
    }\
end\
\
function shell.getCompletionInfo()\
\009return tCompletionInfo\
end\
function shell.getRunningProgram(threadlist)\009\009--if you make your service, you NEED to specify a table with names of your running programs\
\009return threadlist[#threadlist]\
end\
\
function shell.startServ(k, args)\
\009local n, err = thread.new(k, nil, nil, nil, nil, nil, nil, nil, nil, args)\
\009if not n then\
\009\009return false, err\
\009else\
\009\009tasks = n.next\
\009\009return true\
\009end\
end\
function shell.stopServ(name)\
\
\009for _, a in ipairs(tasks) do\
\009\009if a.file == tostring(name) then\
\009\009\009thread.kill(a)\
\009\009\009return true\
\009\009end\
\009end\
\009return false\
end\
\
_G['shell'] = shell\
\
function printError(str)\
\009local c = term.getTextColor()\
\009term.setTextColor(colors.red)\
\009print(str)\
\009term.setTextColor(c)\
end\
\
local services = lib.serv.giveList()\
\
if flag.text == true then\
\009services = {\
\009  [ \"/sys/cmdbak\" ] = \"core\",\
\009  [ \"/sys/redn\" ] = false,\
\009}\
end\
\
\
\
for _, a in pairs(services) do\
\009if a == true then\
\009\009if _ == \"/sys/cmdbak\" then\
\009\009\009_ = _\
\009\009elseif string.find(_, \"/\", 1, 1) then\
\009\009\009_ = _\
\009\009else\
\009\009\009_ = \"/etc/services.d/\".._\
\009\009end\
\009\009local n, err = thread.new(_, nil, nil, nil, nil, nil, nil, nil, nil)\
\009\009if not n then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009term.write(\"[SERVICE] \")\
\009\009\009term.setTextColor(c)\
\009\009\009print(_..\" failed. \"..err)\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.green)\
\009\009\009term.write(\"[SERVICE] \")\
\009\009\009term.setTextColor(c)\
\009\009\009print(_..\" started.\")\
\009\009\009tasks = n.next\
\009\009\009sleep(0.5)\
\009\009end\
\009elseif a == \"core\" then\
\009\009if not string.find(_, \"/\", 1, 1) then\
\009\009\009_ = \"/etc/services.d/\".._\
\009\009end\
\009\009local x, y = term.getCursorPos()\
\009\009x = 1\
\009\009y = y+1\
\009\009local par = term.current()\
\009\009local n, err = thread.new(_, nil, nil, 51, 19, par, true, x, y)\
\009\009if not n then\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.red)\
\009\009\009term.write(\"[SERVICE] \")\
\009\009\009term.setTextColor(c)\
\009\009\009print(_..\" failed. \"..err)\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009local c = term.getTextColor()\
\009\009\009term.setTextColor(colors.green)\
\009\009\009term.write(\"[SERVICE] \")\
\009\009\009term.setTextColor(c)\
\009\009\009print(_..\" started as core.\")\
\009\009\009maintask = n.uid\
\009\009\009tasks = n.next\
\009\009\009sleep(0.5)\
\
\009\009end\
\009end\
end\
\
\
\
while true do\
\009local ok, err = pcall(thread.runAll, tasks)\
\009if not ok then\
\009\009flag.STATE_CRASHED = err\
\009end\
\009local ok, err = thread.getError()\
\009if ok ~= \"noError\" then\
\009\009printError(err)\
\009end\
\009if #tasks < 1 or tasks[maintask].dead then\
\009\009flag.STATE_DEAD = true\
\009end\
\009--[[term.write(\"#\")\
\009local e = read()\
\009if fs.exists(e) and #e > 0 then\
\009\009local f, err = thread.new(e)\
\009\009if not f then\
\009\009\009printError(err)\
\009\009else\
\009\009\009tasks = f.next\
\009\009end\
\009elseif fs.exists(e) == false and #e > 0 then\
\009\009print(\"Command not found.\")\
\009end]]\
end",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /lib/fs.l\
\009CATEGORY:    Library\
\009SET:         Core Library\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009Manages files & folders.\
\009\009Most of these functions are selfexplaining.\
]]--\
local old = {}\
old['fs'] = fs\
local _fs = {}\
local forbidden = {\"/boot\", \"/vit\", \"/bin\", \"/startup\", \"/sys\"}\
\
\
function _fs.scanFs(p)\
\009local root = {}\
\009local rt = old.fs.list(p or \"/\")\
\009for _, a in ipairs(rt) do\
\009\009if old.fs.isDir(p..a) then\
\009\009\009root[p..a] = true\
\009\009\009root[p..a]['$dir'] = true\
\009\009\009local tree = _fs.scanFs(p..a)\
\009\009\009table.insert(root[p..a], tree)\
\009\009else\
\009\009\009root[p..a] = true\
\009\009\009root[p..a]['$dir'] = false\
\009\009\009root[p..a]['owner'] = \"user\"\
\009\009\009for _, folder in ipairs(forbidden) do\
\009\009\009\009local i, j = string.find(p, folder)\
\009\009\009\009if i == 1 and j == i then\
\009\009\009\009\009root[p..a]['owner'] = \"root\"\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009return root\
end\
\
function _fs.getPrefix(a)\
\009str = string.reverse(a)\
\009i, j = string.find(str, \"/\")\
\009if i == 1 and j == 1 then\
\009\009local prefix = string.sub(str, 2)\
\009\009prefix = string.reverse(prefix)\
\009\009prefix, suffix = getPrefix(prefix)\
\009\009return prefix, suffix\
\009elseif i > 1 then\
\009\009local strS = string.sub(str, 1, i-1)\
\009\009local strP = string.sub(str, i, #str)\
\009\009return strP, strS\
\009end\
end\
\
function _fs.makeDir(p)\
\009local i, j = string.find(p, \"[..]/\")\
\
\009if i then\
\009\009return \"error\"\
\009end\
\
\009local i, j = string.find(p, \"//\")\
\
\009if i then\
\009\009return\009\"error\"\
\009end\
\
\009local i, j = string.find(p, \"/\")\
\009if i == 1 and j == i then\
\009\009p = p\
\009else\
\009\009local cPath = shell.dir()\
\009\009p = cPath..\"/\"..p\
\009end\
\009local wx = lib.perm.permission.check(p)\
\009if wx == \"w\" then\
\009\009return old.fs.makeDir(p)\
\009elseif wx == \"x\" then\
\009\009return \"noPermission\"\
\009else\
\009\009return\009\"error\"\
\009end\
end\
\
function _fs.open(p, mode)\
\009if string.find(p, \"/rom/\", 1, 5) or string.find(p, \"rom/\", 1, 4) then\
\009\009return nil\
\009end\
\009if mode == \"w\" or mode == \"a\" or mode == \"bw\" then\
\009\009local ok = lib.perm.permission.check(p)\
\009\009if ok ~= \"w\" then\
\009\009\009return nil\
\009\009elseif ok == \"w\" then\
\009\009\009return old.fs.open(p, mode)\
\009\009end\
\009elseif mode == \"r\" or mode == \"br\" then\
\009\009return old.fs.open(p, mode)\
\009end\
end\
\
_fs.list = old.fs.list\
_fs.exists = old.fs.exists\
_fs.isDir = old.fs.isDir\
\
function _fs.isReadOnly(p)\
\009for _, a in ipairs(forbidden) do\
\009\009local i, j = string.find(p, a)\
\009\009if i == 1 then\
\009\009\009return true\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
end\
\
_fs.getName = old.fs.getName\
_fs.getDrive = old.fs.getDrive\
_fs.getSize = old.fs.getSize\
_fs.getFreeSpace = old.fs.getFreeSpace\
\
function _fs.move(from, to)\
\009local m = lib.perm.permission.check(from)\
\
\009if m == \"w\" then\
\009\009local m = lib.perm.permission.check(to)\
\009\009if m == \"w\" then\
\009\009\009return old.fs.move(from, to)\
\009\009else\
\009\009\009return \"noPermission\"\
\009\009end\
\009else\
\009\009return \"noPermission\"\
\009end\
end\
\
function _fs.copy(from, to)\
\009local m = lib.perm.permission.check(to)\
\009if m == \"w\" then\
\009\009return old.fs.copy(from, to)\
\009else\
\009\009return \"noPermission\"\
\009end\
end\
\
function _fs.delete(p)\
\009local m = lib.perm.permission.check(p)\
\009if m == \"w\" then\
\009\009return old.fs.delete(p)\
\009elseif m == \"x\" then\
\009\009return \"noPermission\"\
\009else\
\
\009end\
end\
\
_fs.combine = function(a, b)\
\009return \"/\"..old.fs.combine(a, b)\
end\
_fs.find = old.fs.find\
_fs.getDir = old.fs.getDir\
_fs.complete = old.fs.complete\
\
_put('fs', _fs)",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /sys/commandline\
\009CATEGORY:    boot\
\009SET:         Boot III\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This script is the commandline and is run as a service.\
]]--\
--variables and tables\
tasks = {\
\009list = {},\
\009last_uid = 0,\
\009somethingInFG = false,\
}\
\
_CONTROL = {\
\009colors = {\
\009\009mainBg = colors.black,\
\009\009mainFg = colors.white,\
\009\009userBg = colors.black,\
\009\009userFg = colors.yellow,\
\009\009middleBg = colors.black,\
\009\009middleFg = colors.white,\
\009\009pathBg = colors.black,\
\009\009pathFg = colors.blue,\
\009}\
}\
\
local errors = {\
\009ok = \"noError\",\
\009err = nil,\
}\
local started = {}\
local windows = {}\
local last_uid = 0\
local mainwindow = nil\
local mainuid = nil\
local lastx = 1\
local lasty = 1\
local foreground = {}\
local sudo = false\
local sudopw = \"\"\
--functions\
\
\
\
function readPw()\
\009--[[\
\009\009\009\009\009\009\009Basically the read function,\
\009\009\009\009\009\009\009without writing any character on the screen.\
\
\009\009\009\009\009\009\009(like in a linux terminal)\
\009]]\
\
\009local str = \"\"\
\009term.setCursorBlink(true)\
\009repeat\
\009\009local _, k = os.pullEventRaw()\
\009\009if _ == \"char\" then\
\009\009\009str = str..k\
\009\009elseif _ == \"key\" and k == keys.backspace and #str > 0 then\
\009\009\009str = string.sub(str, 1, #str-1)\
\009\009end\
\009until _ == \"key\" and k == keys.enter\
\009print(\"\")\
\009term.setCursorBlink(false)\
\009return str\
end\
_put('readPw', readPw)\
\
\
\
\
local function login()\
--[[\
\009\009\009\009\009\009login and register script\
]]\
\009--attempt to get the list of users, located in (\"/sys/usrData\")\
\009local t = lib.perm.usrs.getList()\
\009if #t < 1 then\
\009\009--If the userlist is empty\
\009\009print(\"Register a user.\")\
\009\009term.write(\"Name: \")\
\009\009local tmpUsr = \"\"\
\009\009local tmpPw = \"\"\
\009\009repeat\
\009\009\009--read input for username, repeat if nothing was entered or the user entered \"root\"\
\009\009\009tmpUsr = read()\
\009\009\009if tmpUsr == \"root\" then\
\009\009\009\009print(\"Please use another name.\")\
\009\009\009\009term.write(\"Name: \")\
\009\009\009\009tmpUsr = \"\"\
\009\009\009end\
\009\009\009if #tmpUsr < 1 then\
\009\009\009\009print(\"Please enter a name.\")\
\009\009\009\009term.write(\"Name: \")\
\009\009\009end\
\009\009until #tmpUsr > 0\
\009\009term.write(\"Password: \")\
\009\009repeat\
\009\009\009--read input for password, repeat if nothing was entered\
\009\009\009tmpPw = readPw()\
\009\009\009if #tmpPw < 1 then\
\009\009\009\009print(\"Please enter a password.\")\
\009\009\009\009term.write(\"Password: \")\
\009\009\009end\
\009\009until #tmpPw > 0\
\009\009local ok = lib.perm.usrs.addUser(tmpUsr, tmpPw)\
\009\009--attempt to create the user, restarts login script if something goes wrong\
\009\009if ok then\
\009\009\009print(\"Successfully created!\")\
\009\009\009term.setCursorPos(1,1)\
\009\009\009term.setBackgroundColor(colors.black)\
\009\009\009term.clear()\
\009\009\009fs.makeDir(\"/home/root\")\
\009\009\009login()\
\009\009else\
\009\009\009print(\"Error...\")\
\009\009\009sleep(2)\
\009\009\009login()\
\009\009end\
\009elseif #t > 0 then\
\009\009--If the userlist isn't empty\
\009\009print(\"Login with an existing user.\")\
\009\009term.write(\"Name: \")\
\009\009local tmpUsr = \"\"\
\009\009local tmpPw = \"\"\
\009\009repeat\
\009\009\009--read input for username, repeat if nothing was entered\
\009\009\009tmpUsr = read()\
\009\009\009if #tmpUsr < 1 then\
\009\009\009\009print(\"Please enter a name.\")\
\009\009\009\009term.write(\"Name: \")\
\009\009\009end\
\009\009until #tmpUsr > 0\
\009\009term.write(\"Password: \")\
\009\009repeat\
\009\009\009--read input for password, repeat if nothing was entered\
\009\009\009tmpPw = readPw()\
\009\009\009if #tmpPw < 1 then\
\009\009\009\009print(\"Please enter a password.\")\
\009\009\009\009term.write(\"Password: \")\
\009\009\009end\
\009\009until #tmpPw > 0\
\009\009local ok = lib.perm.permission.login(tmpUsr, tmpPw)\
\009\009--attempt to log in, prints error if the input is false or something goes wrong\
\009\009if ok == false then\
\009\009\009print(\"Oops, that didn't work, let's try again.\")\
\009\009\009login()\
\009\009elseif ok == true then\
\009\009\009return\
\009\009elseif ok == nil then\
\009\009\009print(\"User doesn't exist.\")\
\009\009\009login()\
\009\009end\
\009else\
\009\009--if perm didn't return the list, it restarts the script\
\009\009print(\"Error with userlist.\")\
\009\009sleep(2)\
\009\009login()\
\009end\
end\
\
\
\
local function readcmd( _sReplaceChar, _tHistory, _fnComplete )\009\009--Modified read(), just to print the current user and path at the front\
    term.setCursorBlink( true )\
\
    local sLine = \"\"\
    local nHistoryPos\
    local nPos = 0\
    if _sReplaceChar then\
        _sReplaceChar = string.sub( _sReplaceChar, 1, 1 )\
    end\
\
    local tCompletions\
    local nCompletion\
    local function recomplete()\
        if _fnComplete and nPos == string.len(sLine) then\
            tCompletions = _fnComplete( sLine )\
            if tCompletions and #tCompletions > 0 then\
                nCompletion = 1\
            else\
                nCompletion = nil\
            end\
        else\
            tCompletions = nil\
            nCompletion = nil\
        end\
    end\
\
    local function uncomplete()\
        tCompletions = nil\
        nCompletion = nil\
    end\
\
    local w = term.getSize()\
    local sx = term.getCursorPos()\
\
\009local function rdfirst()\
\009\009local x, y = term.getCursorPos()\
\009\009term.setCursorPos(1, y)\
\009\009local cPath = shell.dir()\
\009\009term.setBackgroundColor(_CONTROL.colors.userBg)\
\009\009term.setTextColor(_CONTROL.colors.userFg)\
\009\009term.write(lib.perm.permission.getCurrentUser())\
\009\009term.setBackgroundColor(_CONTROL.colors.middleBg)\
\009\009term.setTextColor(_CONTROL.colors.middleFg)\
\009\009term.write(\"@\")\
\009\009term.setBackgroundColor(_CONTROL.colors.pathBg)\
\009\009term.setTextColor(_CONTROL.colors.pathFg)\
\009\009local cUser = lib.perm.permission.getCurrentUser()\
\009\009local i, j = string.find(cPath, \"/home/\"..cUser..\"/\")\
\009\009if i==1 then\
\009\009\009cPath = \"~/\"..string.sub(cPath, j+1, #cPath)\
\009\009end\
\009\009term.write(cPath..\"> \")\
\009\009local all = lib.perm.permission.getCurrentUser()..\"@\"..cPath..\"> \"\
\009\009term.setBackgroundColor(_CONTROL.colors.mainBg)\
\009\009term.setTextColor(_CONTROL.colors.mainFg)\
\009\009local nx, ny = term.getCursorPos()\
\009\009term.setCursorPos(x, y)\
\009\009sx = nx\
\009end\
\
    local function redraw( _bClear )\
\009\009term.redirect(oldTerm)\
\009\009term.clearLine()\
\009\009rdfirst()\
\
\
\
        local nScroll = 0\
        if sx + nPos >= w then\
            nScroll = (sx + nPos) - w\
        end\
\
\
\
\
\
\
\
        local cx,cy = term.getCursorPos()\
        term.setCursorPos( sx, cy )\
        local sReplace = (_bClear and \" \") or _sReplaceChar\
        if sReplace then\
            term.write( string.rep( sReplace, math.max( string.len(sLine) - nScroll, 0 ) ) )\
        else\
            term.write( string.sub( sLine, nScroll + 1 ) )\
        end\
\
        if nCompletion then\
            local sCompletion = tCompletions[ nCompletion ]\
            local oldText, oldBg\
            if not _bClear then\
                oldText = term.getTextColor()\
                oldBg = term.getBackgroundColor()\
                term.setTextColor( colors.white )\
                term.setBackgroundColor( colors.gray )\
            end\
            if sReplace then\
\
                term.write( string.rep( sReplace, string.len( sCompletion ) ) )\
            else\
\
                term.write( sCompletion )\
            end\
            if not _bClear then\
                term.setTextColor( oldText )\
                term.setBackgroundColor( oldBg )\
            end\
        end\
\
        term.setCursorPos( sx + nPos - nScroll, cy )\
    end\
\
    local function clear()\
\
        redraw( true )\
    end\
\
    recomplete()\
    redraw()\
\
\
\
\
    local function acceptCompletion()\
        if nCompletion then\
            -- Clear\
            clear()\
\
            -- Find the common prefix of all the other suggestions which start with the same letter as the current one\
            local sCompletion = tCompletions[ nCompletion ]\
            sLine = sLine .. sCompletion\
            nPos = string.len( sLine )\
\
            -- Redraw\
            recomplete()\
            redraw()\
        end\
    end\
\
    while true do\
\009\009\009\009term.setCursorBlink( true )\
        local sEvent, param = os.pullEventRaw()\
\
\009\009redraw()\
\009\009if sEvent == \"char\" then\
            -- Typed key\
            clear()\
            sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )\
            nPos = nPos + 1\
            recomplete()\
            redraw()\
\
        elseif sEvent == \"paste\" then\
            -- Pasted text\
            clear()\
            sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )\
            nPos = nPos + string.len( param )\
            recomplete()\
            redraw()\
\
        elseif sEvent == \"key\" then\
            if param == keys.enter then\
                -- Enter\
                if nCompletion then\
                    clear()\
                    uncomplete()\
                    redraw()\
                end\
\009\009\009\009\009\009\009\009term.setCursorBlink(false)\
                break\
\
            elseif param == keys.left then\
                -- Left\
                if nPos > 0 then\
                    clear()\
                    nPos = nPos - 1\
                    recomplete()\
                    redraw()\
                end\
\
            elseif param == keys.right then\
                -- Right\
                if nPos < string.len(sLine) then\
                    -- Move right\
                    clear()\
                    nPos = nPos + 1\
                    recomplete()\
                    redraw()\
                else\
                    -- Accept autocomplete\
                    acceptCompletion()\
                end\
\
            elseif param == keys.up or param == keys.down then\
                -- Up or down\
                if nCompletion then\
                    -- Cycle completions\
                    clear()\
                    if param == keys.up then\
                        nCompletion = nCompletion - 1\
                        if nCompletion < 1 then\
                            nCompletion = #tCompletions\
                        end\
                    elseif param == keys.down then\
                        nCompletion = nCompletion + 1\
                        if nCompletion > #tCompletions then\
                            nCompletion = 1\
                        end\
                    end\
                    redraw()\
\
                elseif _tHistory then\
                    -- Cycle history\
                    clear()\
                    if param == keys.up then\
                        -- Up\
                        if nHistoryPos == nil then\
                            if #_tHistory > 0 then\
                                nHistoryPos = #_tHistory\
                            end\
                        elseif nHistoryPos > 1 then\
                            nHistoryPos = nHistoryPos - 1\
                        end\
                    else\
                        -- Down\
                        if nHistoryPos == #_tHistory then\
                            nHistoryPos = nil\
                        elseif nHistoryPos ~= nil then\
                            nHistoryPos = nHistoryPos + 1\
                        end\
                    end\
                    if nHistoryPos then\
                        sLine = _tHistory[nHistoryPos]\
                        nPos = string.len( sLine )\
                    else\
                        sLine = \"\"\
                        nPos = 0\
                    end\
                    uncomplete()\
                    redraw()\
\
                end\
\
            elseif param == keys.backspace then\
                -- Backspace\
                if nPos > 0 then\
                    clear()\
                    sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )\
                    nPos = nPos - 1\
                    recomplete()\
                    redraw()\
                end\
\
            elseif param == keys.home then\
                -- Home\
                if nPos > 0 then\
                    clear()\
                    nPos = 0\
                    recomplete()\
                    redraw()\
                end\
\
            elseif param == keys.delete then\
                -- Delete\
                if nPos < string.len(sLine) then\
                    clear()\
                    sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )\
                    recomplete()\
                    redraw()\
                end\
\
            elseif param == keys[\"end\"] then\
                -- End\
                if nPos < string.len(sLine ) then\
                    clear()\
                    nPos = string.len(sLine)\
                    recomplete()\
                    redraw()\
                end\
\
            elseif param == keys.tab then\
                -- Tab (accept autocomplete)\
                acceptCompletion()\
\
            end\
\
        elseif sEvent == \"term_resize\" then\
            -- Terminal resized\
            w = term.getSize()\
            redraw()\
\
        end\
    end\
\
    local cx, cy = term.getCursorPos()\
    term.setCursorBlink( false )\
    term.setCursorPos( w + 1, cy )\
    print()\
\
    return sLine\
end\
\
local function cmd()\
\009local _aliases = {}\
--[[\
\009Basically the whole terminal\
]]\
\
\
\
\
\009--Get the name of the logged in user and set the directory\
\009local cUser = lib.perm.permission.getCurrentUser()\
\009shell.setDir(\"/home/\"..cUser)\
\
\009--read .bashcol\
\009if fs.exists(\"/home/\"..cUser..\"/.bashcol\") then\
\009\009local file, err = fs.open(\"/home/\"..cUser..\"/.bashcol\", \"r\")\
\009\009if not file then\
\009\009\009cLinuxPrintError(\".bashcol\", err)\
\009\009else\
\009\009\009local t = file.readAll()\
\009\009\009t = textutils.unserialize(t)\
\009\009\009file.close()\
\009\009\009for each, color in pairs(t) do\
\009\009\009\009_CONTROL.colors[each] = color\
\009\009\009end\
\009\009end\
\009end\
\
\009--set aliases\
\009if fs.exists(\"/home/\"..cUser..\"/.aliases\") then\
\009\009local file, err = fs.open(\"/home/\"..cUser..\"/.aliases\", \"r\")\
\009\009if not file then\
\009\009\009cLinuxPrintError(\".aliases\", err)\
\009\009else\
\009\009\009local t = file.readAll()\
\009\009\009t = textutils.unserialize(t)\
\009\009\009file.close()\
\009\009\009for each, alias in pairs(t) do\
\009\009\009\009_aliases[each] = alias\
\009\009\009end\
\009\009end\
\009end\
\
\009while true do\
\009\009--start commandline loop\
\
\009\009--Print the current user and the path (example: test@/bin> _ )\
\009\009local cPath = shell.dir()\
\009\009oldTerm = term.current()\
\009\009term.setBackgroundColor(_CONTROL.colors.userBg)\
\009\009term.setTextColor(_CONTROL.colors.userFg)\
\009\009term.write(lib.perm.permission.getCurrentUser())\
\009\009term.setBackgroundColor(_CONTROL.colors.middleBg)\
\009\009term.setTextColor(_CONTROL.colors.middleFg)\
\009\009term.write(\"@\")\
\009\009term.setBackgroundColor(_CONTROL.colors.pathBg)\
\009\009term.setTextColor(_CONTROL.colors.pathFg)\
\
\009\009--if the user is in his home directory, write ~ instead\
\009\009local i, j = string.find(cPath, \"/home/\"..lib.perm.permission.getCurrentUser()..\"/\")\
\009\009if i == 1 then\
\009\009\009cPath = \"~/\"..string.sub(cPath, j+1)\
\009\009end\
\009\009term.write(cPath..\"> \")\
\009\009term.setBackgroundColor(_CONTROL.colors.mainBg)\
\009\009term.setTextColor(_CONTROL.colors.mainFg)\
\
\009\009--Start reading the command\
\009\009local e = readcmd( nil, {}, shell.complete )\
\
\009\009--Start searching for 'sudo' and 'bg', also check if the user put false directories in\
\009\009local corruptPath = false\
\009\009local corruptMessage = \"\"\
\009\009local bg = false\
\
\
\009\009function sd()\
\009\009\009--'sudo', ask for root password\
\009\009\009term.write(\"Enter root password: \")\
\009\009\009local p = readPw()\
\009\009\009p = lib.perm.hashPw(p, \"root\")\
\009\009\009local ok = lib.perm.usrs.checkRootPw(p)\
\009\009\009if not ok then\
\009\009\009\009printError(\"Wrong password.\")\
\009\009\009elseif ok == true then\
\009\009\009\009sudopw = p\
\009\009\009\009sudo = true\
\009\009\009end\
\009\009end\
\
\009\009--Search for 'sudo', if yes, start sd()\
\009\009local i, j = string.find(e, \"sudo \")\
\009\009if i == 1 then\
\009\009\009e = string.sub(e, 6)\
\009\009\009local i, j = string.find(e, \" \")\
\009\009\009local c = \"\"\
\009\009\009if i then\
\009\009\009\009c = string.sub(e, 1, i-1)\
\009\009\009end\
\009\009\009if fs.exists(c) or fs.exists(shell.dir()..\"/\"..c) or fs.exists(\"/bin/\"..c) then\
\009\009\009\009sd()\
\009\009\009\009if e == nil then\
\009\009\009\009\009e = \"\"\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009\009--Search for 'bg', if yes, remove 'bg ' from the input and set bg to true\
\009\009local i, j = string.find(e, \"bg \")\
\009\009if i == 1 then\
\009\009\009e = string.sub(e, 4)\
\009\009\009bg = true\
\009\009\009if e == nil then\
\009\009\009\009e = \"\"\
\009\009\009end\
\009\009end\
\
\
\009\009--filter out every argument after the command\
\009\009local args = {}\
\009\009local oe = e\
\009\009local arg = \"\"\
\009\009local i, j = string.find(e, \" \")\
\009\009if i == nil then\
\009\009\009e = e\
\009\009else\
\009\009\009arg = string.sub(e, j+1, #e)\
\009\009\009e = string.sub(e, 1, i-1)\
\
\009\009end\
\
\009\009if arg == nil or arg == \"\" then\
\009\009\009arg = \"\"\
\009\009else\
\009\009\009repeat\
\009\009\009\009local i, j = string.find(arg, \" \")\
\009\009\009\009if i ~= nil then\
\009\009\009\009\009local a = string.sub(arg, 1, i-1)\
\009\009\009\009\009local x, y = string.find(a, \"~/\")\
\009\009\009\009\009if x == 1 and y == 2 then\
\009\009\009\009\009\009local c = string.sub(a, 3, #a)\
\009\009\009\009\009\009a = \"/home/\"..lib.perm.permission.getCurrentUser()..\"/\"..c\
\009\009\009\009\009end\
\009\009\009\009\009table.insert(args, a)\
\009\009\009\009\009arg = string.sub(arg, j+1, #arg)\
\009\009\009\009else\
\009\009\009\009\009local i, j = string.find(arg, \"~/\")\
\009\009\009\009\009if i == 1 and j == 2 then\
\009\009\009\009\009\009local c = string.sub(arg, 3, #arg)\
\009\009\009\009\009\009arg = \"/home/\"..lib.perm.permission.getCurrentUser()..\"/\"..c\
\009\009\009\009\009end\
\009\009\009\009\009table.insert(args, arg)\
\009\009\009\009end\
\009\009\009until i == nil\
\009\009end\
\
\
\009\009--built-in commands\
\009\009local maincommands = {\
\009\009\009\"kill\",\
\009\009\009\"service\",\
\009\009\009\"ps\"\
\009\009}\
\
\009\009function kill(uid)\
\009\009\009--Function to kill a thread\
\009\009\009if tonumber(uid) == 1 then\
\009\009\009\009cLinuxPrintError(\"Core\",\"You can't kill that.\")\
\009\009\009\009return\
\009\009\009end\
\
\009\009\009local ok = thread.kill(tasks, uid)\
\
\009\009\009if ok then\
\009\009\009\009print(\"Success!\")\
\009\009\009elseif ok == false then\
\009\009\009\009print(\"This shouldn't happen.\")\
\009\009\009elseif ok == nil then\
\009\009\009\009print(\"Process not found.\")\
\009\009\009end\
\009\009end\
\
\
\009\009function sv(...)\
\009\009\009--service manager (start, stop, enable and disable services)\
\009\009\009local tArgs = {...}\
\009\009\009local jArgs = {}\
\009\009\009for _, a in ipairs(tArgs) do\
\009\009\009\009if _ > 2 then\
\009\009\009\009\009table.insert(jArgs, a)\
\009\009\009\009end\
\009\009\009end\
\009\009\009local command = tArgs[1]\
\009\009\009local p = tArgs[2]\
\009\009\009if command == \"start\" then\
\009\009\009\009local ok, err = shell.startServ(p, jArgs)\
\009\009\009\009if not ok then\
\009\009\009\009\009printError(err)\
\009\009\009\009else\
\009\009\009\009\009print(\"Successfully started!\")\
\009\009\009\009end\
\009\009\009elseif command == \"stop\" then\
\009\009\009\009local ok = shell.stopServ(p)\
\009\009\009\009if not ok then\
\009\009\009\009\009printError(\"Service not found.\")\
\009\009\009\009else\
\009\009\009\009\009print(\"Stopped.\")\
\009\009\009\009end\
\009\009\009elseif command == \"enable\" then\
\009\009\009\009local ok, err = lib.serv.set(p, true)\
\009\009\009\009if not ok then\
\009\009\009\009\009printError(err)\
\009\009\009\009else\
\009\009\009\009\009print(\"Successfully enabled! You need to restart.\")\
\009\009\009\009end\
\009\009\009elseif command == \"disable\" then\
\009\009\009\009local ok, err = lib.serv.set(p, false)\
\009\009\009\009if not ok then\
\009\009\009\009\009printError(err)\
\009\009\009\009else\
\009\009\009\009\009print(\"Successfully disabled! You need to restart.\")\
\009\009\009\009end\
\009\009\009elseif command == \"core\" then\
\009\009\009\009local ok, err = lib.serv.set(p, \"core\")\
\009\009\009\009if not ok then\
\009\009\009\009\009printError(err)\
\009\009\009\009else\
\009\009\009\009\009print(\"Successfully set as core! You need to restart.\")\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009print(\"Usage: service <start|stop|enable|disable|core> <name/path> [args]\")\
\009\009\009end\
\009\009end\
\
\
\009\009--check if the user put a built-in command in\
\009\009local m = false\
\009\009for _, a in ipairs(maincommands) do\
\009\009\009if a == e then\
\009\009\009\009m = true\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\
\009\009--replace the command with alias\
\009\009if _aliases[e] then\
\009\009\009e = _aliases[e]\
\009\009end\
\009\009--Start checking for false directory input\
\009\009local cPath = shell.dir()\
\009\009local i, j = string.find(e, \"/\")\
\009\009if i == 1 and j == i or m then\
\009\009\009e = e\
\009\009else\
\009\009\009if not fs.exists(\"/bin/\"..e) then\
\009\009\009\009e = cPath..\"/\"..e\
\009\009\009end\
\009\009end\
\009\009local i, j = string.find(e, \"//\")\
\009\009if i then\
\009\009\009corruptPath = true\
\009\009\009corruptMessage = \"Invalid path.\"\
\009\009end\
\009\009local i, j = string.find(e, \"%.%.\")\
\009\009if i and #e > 2 then\
\009\009\009corruptPath = true\
\009\009\009corruptMessage = \"Invalid path.\"\
\009\009end\
\009\009for _, a in ipairs(args) do\
\009\009\009local i, j = string.find(a, \"//\")\
\009\009\009if i then\
\009\009\009\009corruptPath = true\
\009\009\009\009corruptMessage = \"Invalid path.\"\
\009\009\009end\
\009\009\009local i, j = string.find(a, \"%.%.\")\
\009\009\009if i and #a > 2 then\
\009\009\009\009corruptPath = true\
\009\009\009\009corruptMessage = \"Invalid path.\"\
\009\009\009end\
\009\009end\
\
\009\009local newEnv = {}\
\009\009for k, v in pairs(_G) do\
\009\009\009newEnv[k] = v\
\009\009end\
\009\009newEnv['_G'] = newEnv\
\009\009setmetatable(newEnv, {})\
\
\
\
\009\009--Start executing commands\
\009\009if not corruptPath then\
\009\009\009local dat = {\
\009\009\009\009name = \"\",\
\009\009\009\009password = \"\",\
\009\009\009}\
\009\009\009if sudo then\
\009\009\009\009dat.name  = \"root\"\
\009\009\009\009dat.password = sudopw\
\009\009\009else\
\009\009\009\009dat.name, dat.password = lib.perm.permission.getCurrentUser\
\009\009\009end\
\009\009\009if fs.exists(e) and #e > 0 and not m then\
\009\009\009\009--if the user put a full path in and it exists\
\009\009\009\009if bg == false then\
\009\009\009\009\009--Start in foreground mode\
\009\009\009\009\009local f, err = loadfile(e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, e, tasks, args, dat)\
\009\009\009\009\009\009if not f then\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009for _, a in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if a.name == e then\
\009\009\009\009\009\009\009\009\009a.background = false\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009tasks.somethingInFG = true\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009elseif bg == true then\
\009\009\009\009\009--start in background mode\
\009\009\009\009\009local f, err = loadfile(e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, e, tasks, args, dat)\
\009\009\009\009\009\009if f then\
\009\009\009\009\009\009\009for _, v in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if v.name == e then\
\009\009\009\009\009\009\009\009\009v.background = true\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif fs.exists(shell.dir()..\"/\"..e) and #e > 0 and not m then\
\009\009\009\009--if the file exists in the current directory\
\009\009\009\009if bg == false then\
\009\009\009\009\009--start in foreground mode\
\009\009\009\009\009local f, err = loadfile(shell.dir()..\"/\"..e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\009\009\009\009\009\009--f(unpack(args))\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, shell.dir()..\"/\"..e, tasks, args, dat)\
\009\009\009\009\009\009if not f then\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009for _, a in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if a.name == shell.dir()..\"/\"..e then\
\009\009\009\009\009\009\009\009\009a.background = false\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009tasks.somethingInFG = true\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009elseif bg == true then\
\009\009\009\009\009--start in background mode\
\009\009\009\009\009local f, err = loadfile(shell.dir()..\"/\"..e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, shell.dir()..\"/\"..e, tasks, args, dat)\
\009\009\009\009\009\009if f then\
\009\009\009\009\009\009\009for _, v in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if v.name == shell.dir()..\"/\"..e then\
\009\009\009\009\009\009\009\009\009v.background = true\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif fs.exists(\"/bin/\"..e) and #e > 0 and not m then\
\009\009\009\009--if the file exists in /bin/\
\009\009\009\009if bg == false then\
\009\009\009\009\009--start in foreground mode\
\009\009\009\009\009local f, err = loadfile(\"/bin/\"..e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\009\009\009\009\009\009--f(unpack(args))\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, \"/bin/\"..e, tasks, args, dat)\
\009\009\009\009\009\009if not f then\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009for _, a in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if a.name == \"/bin/\"..e then\
\009\009\009\009\009\009\009\009\009a.background = false\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009tasks.somethingInFG = true\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009elseif bg == true then\
\
\009\009\009\009\009--start in background mode, if NOT sudo! sudo would mess things up\
\009\009\009\009\009local f, err = loadfile(\"/bin/\"..e)\
\009\009\009\009\009if not f then\
\009\009\009\009\009\009printError(err)\
\009\009\009\009\009else\
\009\009\009\009\009\009local f, err = thread.new(f, newEnv, \"/bin/\"..e, tasks, args, dat)\
\009\009\009\009\009\009if f then\
\009\009\009\009\009\009\009for _, v in ipairs(tasks.list) do\
\009\009\009\009\009\009\009\009if v.name == \"/bin/\"..e then\
\009\009\009\009\009\009\009\009\009v.background = true\
\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009printError(err)\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif m then\
\009\009\009\009--if the user entered a built-in command\
\009\009\009\009if e == \"kill\" then\
\009\009\009\009\009--check for arguments and start kill()\
\009\009\009\009\009if #args ~= 1 then\
\009\009\009\009\009\009print(\"Usage: kill <UID>\")\
\009\009\009\009\009else\
\009\009\009\009\009\009kill(args[1])\
\009\009\009\009\009end\
\009\009\009\009elseif e == \"service\" then\
\009\009\009\009\009--check for arguments and start sv()\
\009\009\009\009\009if #args ~= 2 then\
\009\009\009\009\009\009print(\"Usage: service <start|stop|enable|disable> <name/path> [args]\")\
\009\009\009\009\009else\
\009\009\009\009\009\009sv(args[1], args[2])\
\009\009\009\009\009end\
\009\009\009\009elseif e == \"ps\" then\
\009\009\009\009\009print(\"UID | Name/Path\")\
\009\009\009\009\009for k, v in pairs(tasks.list) do\
\009\009\009\009\009\009if not v.dead then\
\009\009\009\009\009\009\009term.write(tostring(v.uid)..\" | \")\
\009\009\009\009\009\009\009print(tostring(v.name))\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\
\009\009\009elseif fs.exists(e) == false and #e > 0 then\
\009\009\009\009--if any of these above don't exist\
\009\009\009\009print(\"Command not found.\")\
\009\009\009end\
\009\009\009if sudo then\
\009\009\009\009--if sudo was entered, get out of it again\
\009\009\009\009sudo = false\
\009\009\009end\
\009\009else\
\009\009\009--if the user entered a false directory\
\009\009\009printError(corruptMessage)\
\009\009end\
\
\009end\
end\
\
--code\
\
--Clear the screen\
term.setCursorPos(1,1)\
term.setBackgroundColor(colors.black)\
term.clear()\
\
--start the login script, if no user is logged in\
\
local ok, err, err2 = pcall(lib.perm.permission.getCurrentUser)\
if not ok then\
\009flag.STATE_CRASHED = err\
end\
if type(err) == \"string\" and #err < 1 or err == nil then\
\009login()\
end\
\
--Add the cmd function as the main task, with the parent window\
local maxX, maxY = term.getSize()\
local n, err = thread.new(cmd, getfenv(1), \"/sys/cmdbak\", tasks)\
if not n then\
\009printError(err)\
end\
local running = true\
local evt = {}\
while running do\
\009local ok = thread.resumeAll(tasks, evt)\
\009evt = {os.pullEventRaw()}\
\009if ok == false then\
\009\009running = false\
\009end\
end\
--[[Try to run all tasks, if it fails, it sets to dead, which leads to /vit/alive restarting\
local ok, err = pcall(thread.runAll, tasks)\
if not ok then\
\009printError(err)\
\009flag.STATE_DEAD = true\
end]]",
      "-- SHA-256 implementation in CC-Lua\
-- HMAC and PBKDF2 with SHA-256\
-- By Anavrins\
\
-- Usage\
---- Data format\
------ Almost all arguments passed in these functions can take both a string or a special table containing a byte array.\
------ This byte array format is simply a table containing a list of each character's byte values.\
------ The phrase \"hello world\" will become {104,101,108,108,111, 32,119,111,114,108,100}.\
------ Any strings can be converted into it with {str:byte(1,-1)}, and back into string with string.char(unpack(str))\
------\
------ The data returned by all functions are also in this byte array format.\
------ They are paired with a metatable containing metamethods like\
------ :toHex() to convert into the traditional hexadecimal representation.\
------ :isEqual(arr) to compare the hash with another byte array \"arr\" in constant time.\
------ __tostring to convert into a raw string (Might crash window api on old CC versions).\
\
---- digest(data)\
------ The digest function is the core of this API, it simply hashes your data with the SHA256 algorithm, period.\
------ It's the function everybody is familiar with, and most likely what you're looking for.\
------ This function is mainly used for file integrity, however it is not suited for password storage by itself, use PBKDF2 instead.\
\
---- hmac(data, key)\
------ The HMAC function is used for message authentication, it's primary use is in networking apis\
------ to authenticate an encrypted message and ensuring that the data was not tempered with.\
------ The key may be a string or a byte array, with a size between 0 and 32 bytes (256-bits), having a key larger than 32 bytes will not increase security.\
------ This function *may* be used for password storage, if you choose to do so, you must pass the password as the key argument, and the salt as the data argument.\
\
---- PBKDF2(pass, salt, iter, dklen)\
------ Password-based key derivation function, returns a \"dklen\" bytes long array for use in various networking protocol to generate secure cryptographic keys.\
------ This is the preferred choice for password storage, it uses individual argument for password and salt, do not concatenate beforehand.\
------ This algorithm is designed to inherently slow down hashing by repeating the process many times to slow down cracking attempts.\
------ You can adjust the number of \"iter\" to control the speed of the algorithm, higher \"iter\" means slower hashing, as well as slower to crack.\
------\
------ DO NOT TOUCH \"dklen\" if you're using it for passwords, simply pass nil or nothing at all (defaults to 32).\
------ Passing a dklen higher than 32 will multiply the number of iterations with no additional security whatsoever.\
\
-- For more help and details, you can PM me on the CC forums, http://www.computercraft.info/forums2/index.php?/user/12870-anavrins/\
-- You can use this code in your projects without asking me, as long as credit is given by keeping the first three lines of this paste.\
\
\
local mod32 = 2^32\
local sha_hashlen = 32\
local sha_blocksize = 64\
\
local band    = bit32 and bit32.band or bit.band\
local bnot    = bit32 and bit32.bnot or bit.bnot\
local bxor    = bit32 and bit32.bxor or bit.bxor\
local blshift = bit32 and bit32.lshift or bit.blshift\
local upack   = unpack\
\
local function rrotate(n, b)\
\009local s = n/(2^b)\
\009local f = s%1\
\009return (s-f) + f*mod32\
end\
local function brshift(int, by) -- Thanks bit32 for bad rshift\
\009local s = int / (2^by)\
\009return s - s%1\
end\
\
local H = {\
\0090x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\
\0090x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\
}\
\
local K = {\
\0090x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\
\0090xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\
\0090xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\
\0090x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\
\0090x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\
\0090xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\
\0090x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\
\0090x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\
}\
\
local function counter(incr)\
\009local t1, t2 = 0, 0\
\009if 0xFFFFFFFF - t1 < incr then\
\009\009t2 = t2 + 1\
\009\009t1 = incr - (0xFFFFFFFF - t1) - 1\009\009\
\009else t1 = t1 + incr\
\009end\
\009return t2, t1\
end\
\
local function BE_toInt(bs, i)\
\009return blshift((bs[i] or 0), 24) + blshift((bs[i+1] or 0), 16) + blshift((bs[i+2] or 0), 8) + (bs[i+3] or 0)\
end\
\
local function preprocess(data)\
\009local len = #data\
\009local proc = {}\
\009data[#data+1] = 0x80\
\009while #data%64~=56 do data[#data+1] = 0 end\
\009local blocks = math.ceil(#data/64)\
\009for i = 1, blocks do\
\009\009proc[i] = {}\
\009\009for j = 1, 16 do\
\009\009\009proc[i][j] = BE_toInt(data, 1+((i-1)*64)+((j-1)*4))\
\009\009end\
\009end\
\009proc[blocks][15], proc[blocks][16] = counter(len*8)\
\009return proc\
end\
\
local function digestblock(w, C)\
\009for j = 17, 64 do\
\009\009local v = w[j-15]\
\009\009local s0 = bxor(bxor(rrotate(w[j-15], 7), rrotate(w[j-15], 18)), brshift(w[j-15], 3))\
\009\009local s1 = bxor(bxor(rrotate(w[j-2], 17), rrotate(w[j-2], 19)), brshift(w[j-2], 10))\
\009\009w[j] = (w[j-16] + s0 + w[j-7] + s1)%mod32\
\009end\
\009local a, b, c, d, e, f, g, h = upack(C)\
\009for j = 1, 64 do\
\009\009local S1 = bxor(bxor(rrotate(e, 6), rrotate(e, 11)), rrotate(e, 25))\
\009\009local ch = bxor(band(e, f), band(bnot(e), g))\
\009\009local temp1 = (h + S1 + ch + K[j] + w[j])%mod32\
\009\009local S0 = bxor(bxor(rrotate(a, 2), rrotate(a, 13)), rrotate(a, 22))\
\009\009local maj = bxor(bxor(band(a, b), band(a, c)), band(b, c))\
\009\009local temp2 = (S0 + maj)%mod32\
\009\009h, g, f, e, d, c, b, a = g, f, e, (d+temp1)%mod32, c, b, a, (temp1+temp2)%mod32\
\009end\
\009C[1] = (C[1] + a)%mod32\
\009C[2] = (C[2] + b)%mod32\
\009C[3] = (C[3] + c)%mod32\
\009C[4] = (C[4] + d)%mod32\
\009C[5] = (C[5] + e)%mod32\
\009C[6] = (C[6] + f)%mod32\
\009C[7] = (C[7] + g)%mod32\
\009C[8] = (C[8] + h)%mod32\
\009return C\
end\
\
local mt = {\
\009__tostring = function(a) return string.char(unpack(a)) end,\
\009__index = {\
\009\009toHex = function(self, s) return (\"%02x\"):rep(#self):format(unpack(self)) end,\
\009\009isEqual = function(self, t)\
\009\009\009if type(t) ~= \"table\" then return false end\
\009\009\009if #self ~= #t then return false end\
\009\009\009local ret = 0\
\009\009\009for i = 1, #self do\
\009\009\009\009ret = bit32.bor(ret, bxor(self[i], t[i]))\
\009\009\009end\
\009\009\009return ret == 0\
\009\009end\
\009}\
}\
\
function toBytes(t, n)\
\009local b = {}\
\009for i = 1, n do\
\009\009b[(i-1)*4+1] = band(brshift(band(t[i], 0xFF000000), 24), 0xFF)\
\009\009b[(i-1)*4+2] = band(brshift(band(t[i], 0xFF0000), 16), 0xFF)\
\009\009b[(i-1)*4+3] = band(brshift(band(t[i], 0xFF00), 8), 0xFF)\
\009\009b[(i-1)*4+4] = band(t[i], 0xFF)\
\009end\
\009return setmetatable(b, mt)\
end\
\
\
function digest(data)\
\009data = data or \"\"\
\009data = type(data) == \"string\" and {data:byte(1,-1)} or data\
\
\009data = preprocess(data)\
\009local C = {upack(H)}\
\009for i = 1, #data do C = digestblock(data[i], C) end\
\009return toBytes(C, 8)\
end\
\
function hmac(data, key)\
\009local data = type(data) == \"table\" and {upack(data)} or {tostring(data):byte(1,-1)}\
\009local key = type(key) == \"table\" and {upack(key)} or {tostring(key):byte(1,-1)}\
\
\009local blocksize = sha_blocksize\
\
\009key = #key > blocksize and digest(key) or key\
\
\009local ipad = {}\
\009local opad = {}\
\009local padded_key = {}\
\
\009for i = 1, blocksize do\
\009\009ipad[i] = bxor(0x36, key[i] or 0)\
\009\009opad[i] = bxor(0x5C, key[i] or 0)\
\009end\
\
\009for i = 1, #data do\
\009\009ipad[blocksize+i] = data[i]\
\009end\
\
\009ipad = digest(ipad)\
\
\009for i = 1, blocksize do\
\009\009padded_key[i] = opad[i]\
\009\009padded_key[blocksize+i] = ipad[i]\
\009end\
\
\009return digest(padded_key)\
end\
\
function pbkdf2(pass, salt, iter, dklen)\
\009local out = {}\
\009local hashlen = sha_hashlen\
\009local block = 1\
\009dklen = dklen or 32\
\
\009while dklen > 0 do\
\009\009local ikey = {}\
\009\009local isalt = type(salt) == \"table\" and {upack(salt)} or {tostring(salt):byte(1,-1)}\
\009\009local clen = dklen > hashlen and hashlen or dklen\
\
\009\009isalt[#isalt+1] = band(brshift(band(block, 0xFF000000), 24), 0xFF)\
\009\009isalt[#isalt+1] = band(brshift(band(block, 0xFF0000), 16), 0xFF)\
\009\009isalt[#isalt+1] = band(brshift(band(block, 0xFF00), 8), 0xFF)\
\009\009isalt[#isalt+1] = band(block, 0xFF)\
\
\009\009for j = 1, iter do\
\009\009\009isalt = hmac(isalt, pass)\
\009\009\009for k = 1, clen do ikey[k] = bxor(isalt[k], ikey[k] or 0) end\
\009\009\009if j % 200 == 0 then os.queueEvent(\"PBKDF2\", j) coroutine.yield(\"PBKDF2\") end\
\009\009end\
\009\009dklen = dklen - clen\
\009\009block = block+1\
\009\009for k = 1, clen do out[#out+1] = ikey[k] end\
\009end\
\
\009return setmetatable(out, mt)\
end",
      "--[[\
Copyright (C) 2012 Thomas Farr a.k.a tomass1996 [farr.thomas@gmail.com]\
\
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\
associated documentation files (the \"Software\"), to deal in the Software without restriction,\
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\
copies of the Software, and to permit persons to whom the Software is furnished to do so,\
subject to the following conditions:\
\
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\
-Visible credit is given to the original author.\
-The software is distributed in a non-profit way.\
\
THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\
--]]\
\
local floor,modf, insert = math.floor,math.modf, table.insert\
local char,format,rep = string.char,string.format,string.rep\
\
local function basen(n,b)\
\009if n < 0 then\
\009\009n = -n\
\009end\
       local t = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~\"\
   if n < b then\
\009local ret = \"\"\
\009ret = ret..string.sub(t, (n%b)+1,(n%b)+1)\
\009return ret\
   else\
\009local tob = tostring(basen(math.floor(n/b), b))\
\009local ret = tob..t:sub((n%b)+1,(n%b)+1)\
\009return ret\
   end\
end\
\
local Base64 = {}\
Base64[\"lsh\"] = function(value,shift)\
    return (value*(2^shift)) % 256\
end\
Base64[\"rsh\"] = function(value,shift)\
    return math.floor(value/2^shift) % 256\
end\
Base64[\"bit\"] = function(x,b)\
    return (x % 2^b - x % 2^(b-1) > 0)\
end\
Base64[\"lor\"] = function(x,y)\
    local result = 0\
    for p=1,8 do result = result + (((Base64.bit(x,p) or Base64.bit(y,p)) == true) and 2^(p-1) or 0) end\
    return result\
end\
Base64[\"base64chars\"] = {\
    [0]='A',[1]='B',[2]='C',[3]='D',[4]='E',[5]='F',[6]='G',[7]='H',[8]='I',[9]='J',[10]='K',\
    [11]='L',[12]='M',[13]='N',[14]='O',[15]='P',[16]='Q',[17]='R',[18]='S',[19]='T',[20]='U',\
    [21]='V',[22]='W',[23]='X',[24]='Y',[25]='Z',[26]='a',[27]='b',[28]='c',[29]='d',[30]='e',\
    [31]='f',[32]='g',[33]='h',[34]='i',[35]='j',[36]='k',[37]='l',[38]='m',[39]='n',[40]='o',\
    [41]='p',[42]='q',[43]='r',[44]='s',[45]='t',[46]='u',[47]='v',[48]='w',[49]='x',[50]='y',\
    [51]='z',[52]='0',[53]='1',[54]='2',[55]='3',[56]='4',[57]='5',[58]='6',[59]='7',[60]='8',\
    [61]='9',[62]='-',[63]='_'}\
Base64[\"base64bytes\"] = {\
    ['A']=0,['B']=1,['C']=2,['D']=3,['E']=4,['F']=5,['G']=6,['H']=7,['I']=8,['J']=9,['K']=10,\
    ['L']=11,['M']=12,['N']=13,['O']=14,['P']=15,['Q']=16,['R']=17,['S']=18,['T']=19,['U']=20,\
    ['V']=21,['W']=22,['X']=23,['Y']=24,['Z']=25,['a']=26,['b']=27,['c']=28,['d']=29,['e']=30,\
    ['f']=31,['g']=32,['h']=33,['i']=34,['j']=35,['k']=36,['l']=37,['m']=38,['n']=39,['o']=40,\
    ['p']=41,['q']=42,['r']=43,['s']=44,['t']=45,['u']=46,['v']=47,['w']=48,['x']=49,['y']=50,\
    ['z']=51,['0']=52,['1']=53,['2']=54,['3']=55,['4']=56,['5']=57,['6']=58,['7']=59,['8']=60,\
    ['9']=61,['-']=62,['_']=63,['=']=nil}\
\
local base32 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\
\
local tSHA1 = {}\
tSHA1[\"bytes_to_w32\"] = function(a,b,c,d) return a*0x1000000+b*0x10000+c*0x100+d end\
tSHA1[\"w32_to_bytes\"] = function(i) return floor(i/0x1000000)%0x100,floor(i/0x10000)%0x100,floor(i/0x100)%0x100,i%0x100 end\
tSHA1[\"w32_rot\"] = function(bits,a)\
    local b2 = 2^(32-bits)\
    local a,b = modf(a/b2)\
    return a+b*b2*(2^(bits))\
end\
tSHA1[\"byte_to_bits\"] = function(b)\
    local b = function (n)\
        local b = floor(b/n)\
        return b%2==1\
    end\
    return b(1),b(2),b(4),b(8),b(16),b(32),b(64),b(128)\
end\
tSHA1[\"bits_to_byte\"] = function(a,b,c,d,e,f,g,h)\
    local function n(b,x) return b and x or 0 end\
    return n(a,1)+n(b,2)+n(c,4)+n(d,8)+n(e,16)+n(f,32)+n(g,64)+n(h,128)\
end\
tSHA1[\"bits_to_string\"] = function(a,b,c,d,e,f,g,h)\
    local function x(b) return b and \"1\" or \"0\" end\
    return (\"%s%s%s%s %s%s%s%s\"):format(x(a),x(b),x(c),x(d),x(e),x(f),x(g),x(h))\
end\
tSHA1[\"byte_to_bit_string\"] = function(b) return tSHA1.bits_to_string(byte_to_bits(b)) end\
tSHA1[\"w32_to_bit_string\"] = function(a)\
    if type(a) == \"string\" then return a end\
    local aa,ab,ac,ad = tSHA1.w32_to_bytes(a)\
    local s = tSHA1.byte_to_bit_string\
    return (\"%s %s %s %s\"):format(s(aa):reverse(),s(ab):reverse(),s(ac):reverse(),s(ad):reverse()):reverse()\
end\
tSHA1[\"band\"] = function(a,b)\
    local A,B,C,D,E,F,G,H = tSHA1.byte_to_bits(b)\
    local a,b,c,d,e,f,g,h = tSHA1.byte_to_bits(a)\
    return tSHA1.bits_to_byte(\
        A and a, B and b, C and c, D and d,\
        E and e, F and f, G and g, H and h)\
end\
tSHA1[\"bor\"] = function(a,b)\
    local A,B,C,D,E,F,G,H = tSHA1.byte_to_bits(b)\
    local a,b,c,d,e,f,g,h = tSHA1.byte_to_bits(a)\
    return tSHA1.bits_to_byte(\
        A or a, B or b, C or c, D or d,\
        E or e, F or f, G or g, H or h)\
end\
tSHA1[\"bxor\"] = function(a,b)\
    local A,B,C,D,E,F,G,H = tSHA1.byte_to_bits(b)\
    local a,b,c,d,e,f,g,h = tSHA1.byte_to_bits(a)\
    return tSHA1.bits_to_byte(\
        A ~= a, B ~= b, C ~= c, D ~= d,\
        E ~= e, F ~= f, G ~= g, H ~= h)\
end\
tSHA1[\"bnot\"] = function(x) return 255-(x % 256) end\
tSHA1[\"w32_comb\"] = function(fn)\
    return function (a,b)\
        local aa,ab,ac,ad = tSHA1.w32_to_bytes(a)\
        local ba,bb,bc,bd = tSHA1.w32_to_bytes(b)\
        return tSHA1.bytes_to_w32(fn(aa,ba),fn(ab,bb),fn(ac,bc),fn(ad,bd))\
    end\
end\
tSHA1[\"w32_xor_n\"] = function(a,...)\
    local aa,ab,ac,ad = tSHA1.w32_to_bytes(a)\
    for i=1,select('#',...) do\
        local ba,bb,bc,bd = tSHA1.w32_to_bytes(select(i,...))\
        aa,ab,ac,ad = tSHA1.bxor(aa,ba),tSHA1.bxor(ab,bb),tSHA1.bxor(ac,bc),tSHA1.bxor(ad,bd)\
    end\
    return tSHA1.bytes_to_w32(aa,ab,ac,ad)\
end\
tSHA1[\"w32_or3\"] = function(a,b,c)\
    local aa,ab,ac,ad = tSHA1.w32_to_bytes(a)\
    local ba,bb,bc,bd = tSHA1.w32_to_bytes(b)\
    local ca,cb,cc,cd = tSHA1.w32_to_bytes(c)\
    return tSHA1.bytes_to_w32(\
        tSHA1.bor(aa,tSHA1.bor(ba,ca)), tSHA1.bor(ab,tSHA1.bor(bb,cb)), tSHA1.bor(ac,tSHA1.bor(bc,cc)), tSHA1.bor(ad,tSHA1.bor(bd,cd))\
    )\
end\
tSHA1[\"w32_not\"] = function(a) return 4294967295-(a % 4294967296) end\
tSHA1[\"w32_add\"] = function(a,b) return (a+b) % 4294967296 end\
tSHA1[\"w32_add_n\"] = function(a,...)\
    for i=1,select('#',...) do\
        a = (a+select(i,...)) % 4294967296\
    end\
    return a\
end\
tSHA1[\"w32_to_hexstring\"] = function(w) return format(\"%08x\",w) end\
tSHA1[\"w32_and\"] = tSHA1.w32_comb(tSHA1.band)\
tSHA1[\"w32_xor\"] = tSHA1.w32_comb(tSHA1.bxor)\
tSHA1[\"w32_or\"] = tSHA1.w32_comb(tSHA1.bor)\
\
local CRC = {}\
CRC.crc32 = {\
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,\
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,\
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,\
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,\
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,\
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,\
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,\
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,\
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,\
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,\
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,\
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,\
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,\
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,\
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,\
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,\
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,\
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,\
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,\
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,\
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,\
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D }\
\
local bit = {}\
bit[\"bnot\"] = function(n)\
    local tbl = bit.tobits(n)\
    local size = math.max(table.getn(tbl), 32)\
    for i = 1, size do\
        if(tbl[i] == 1) then\
            tbl[i] = 0\
        else\
            tbl[i] = 1\
        end\
    end\
    return bit.tonumb(tbl)\
end\
bit[\"band\"] = function(m, n)\
    local tbl_m = bit.tobits(m)\
    local tbl_n = bit.tobits(n)\
    bit.expand(tbl_m, tbl_n)\
    local tbl = {}\
    local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))\
    for i = 1, rslt do\
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then\
            tbl[i] = 0\
        else\
            tbl[i] = 1\
        end\
    end\
    return bit.tonumb(tbl)\
end\
bit[\"bor\"] = function(m, n)\
    local tbl_m = bit.tobits(m)\
    local tbl_n = bit.tobits(n)\
    bit.expand(tbl_m, tbl_n)\
    local tbl = {}\
    local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))\
    for i = 1, rslt do\
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then\
            tbl[i] = 0\
        else\
            tbl[i] = 1\
        end\
    end\
    return bit.tonumb(tbl)\
end\
bit[\"bxor\"] = function(m, n)\
    local tbl_m = bit.tobits(m)\
    local tbl_n = bit.tobits(n)\
    bit.expand(tbl_m, tbl_n)\
    local tbl = {}\
    local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))\
    for i = 1, rslt do\
        if(tbl_m[i] ~= tbl_n[i]) then\
            tbl[i] = 1\
        else\
            tbl[i] = 0\
        end\
    end\
    return bit.tonumb(tbl)\
end\
bit[\"brshift\"] = function(n, bits)\
    bit.checkint(n)\
    local high_bit = 0\
    if(n < 0) then\
        n = bit.bnot(math.abs(n)) + 1\
        high_bit = 2147483648\
    end\
    for i=1, bits do\
        n = n/2\
        n = bit.bor(math.floor(n), high_bit)\
    end\
    return math.floor(n)\
end\
bit[\"blshift\"] = function(n, bits)\
    bit.checkint(n)\
    if(n < 0) then\
        n = bit.bnot(math.abs(n)) + 1\
    end\
    for i=1, bits do\
        n = n*2\
    end\
    return bit.band(n, 4294967295)\
end\
bit[\"bxor2\"] = function(m, n)\
    local rhs = bit.bor(bit.bnot(m), bit.bnot(n))\
    local lhs = bit.bor(m, n)\
    local rslt = bit.band(lhs, rhs)\
    return rslt\
end\
bit[\"blogic_rshift\"] = function(n, bits)\
    bit.checkint(n)\
    if(n < 0) then\
        n = bit.bnot(math.abs(n)) + 1\
    end\
    for i=1, bits do\
        n = n/2\
    end\
    return math.floor(n)\
end\
bit[\"tobits\"] = function(n)\
    bit.checkint(n)\
    if(n < 0) then\
        return bit.tobits(bit.bnot(math.abs(n)) + 1)\
    end\
    local tbl = {}\
    local cnt = 1\
    while (n > 0) do\
        local last = math.fmod(n,2)\
        if(last == 1) then\
            tbl[cnt] = 1\
        else\
            tbl[cnt] = 0\
        end\
        n = (n-last)/2\
        cnt = cnt + 1\
    end\
    return tbl\
end\
bit[\"tonumb\"] = function(tbl)\
    local n = table.getn(tbl)\
    local rslt = 0\
    local power = 1\
    for i = 1, n do\
        rslt = rslt + tbl[i]*power\
        power = power*2\
    end\
    return rslt\
end\
bit[\"checkint\"] = function(n)\
    if(n - math.floor(n) > 0) then\
        error(\"trying to use bitwise operation on non-integer!\")\
    end\
end\
bit[\"expand\"] = function(tbl_m, tbl_n)\
    local big = {}\
    local small = {}\
    if(table.getn(tbl_m) > table.getn(tbl_n)) then\
        big = tbl_m\
        small = tbl_n\
    else\
        big = tbl_n\
        small = tbl_m\
    end\
    for i = table.getn(small) + 1, table.getn(big) do\
        small[i] = 0\
    end\
end\
\
local FCS = {}\
FCS[\"16\"] = {\
    [0]=0, 4489, 8978, 12955, 17956, 22445, 25910, 29887,\
    35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735,\
    4225, 264, 13203, 8730, 22181, 18220, 30135, 25662,\
    40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510,\
    8450, 12427, 528, 5017, 26406, 30383, 17460, 21949,\
    44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797,\
    12675, 8202, 4753, 792, 30631, 26158, 21685, 17724,\
    48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572,\
    16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011,\
    52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859,\
    21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786,\
    57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634,\
    25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073,\
    61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921,\
    29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848,\
    65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696,\
    33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623,\
    2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999,\
    38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398,\
    6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774,\
    42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685,\
    10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061,\
    46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460,\
    14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836,\
    50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747,\
    19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123,\
    54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522,\
    23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898,\
    59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809,\
    27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185,\
    63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584,\
    31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960 }\
FCS[\"32\"] = {\
    [0]=0, 1996959894, -301047508, -1727442502, 124634137, 1886057615, -379345611, -1637575261,\
    249268274, 2044508324, -522852066, -1747789432, 162941995, 2125561021, -407360249, -1866523247,\
    498536548, 1789927666, -205950648, -2067906082, 450548861, 1843258603, -187386543, -2083289657,\
    325883990, 1684777152, -43845254, -1973040660, 335633487, 1661365465, -99664541, -1928851979,\
    997073096, 1281953886, -715111964, -1570279054, 1006888145, 1258607687, -770865667, -1526024853,\
    901097722, 1119000684, -608450090, -1396901568, 853044451, 1172266101, -589951537, -1412350631,\
    651767980, 1373503546, -925412992, -1076862698, 565507253, 1454621731, -809855591, -1195530993,\
    671266974, 1594198024, -972236366, -1324619484, 795835527, 1483230225, -1050600021, -1234817731,\
    1994146192, 31158534, -1731059524, -271249366, 1907459465, 112637215, -1614814043, -390540237,\
    2013776290, 251722036, -1777751922, -519137256, 2137656763, 141376813, -1855689577, -429695999,\
    1802195444, 476864866, -2056965928, -228458418, 1812370925, 453092731, -2113342271, -183516073,\
    1706088902, 314042704, -1950435094, -54949764, 1658658271, 366619977, -1932296973, -69972891,\
    1303535960, 984961486, -1547960204, -725929758, 1256170817, 1037604311, -1529756563, -740887301,\
    1131014506, 879679996, -1385723834, -631195440, 1141124467, 855842277, -1442165665, -586318647,\
    1342533948, 654459306, -1106571248, -921952122, 1466479909, 544179635, -1184443383, -832445281,\
    1591671054, 702138776, -1328506846, -942167884, 1504918807, 783551873, -1212326853, -1061524307,\
    -306674912, -1698712650, 62317068, 1957810842, -355121351, -1647151185, 81470997, 1943803523,\
    -480048366, -1805370492, 225274430, 2053790376, -468791541, -1828061283, 167816743, 2097651377,\
    -267414716, -2029476910, 503444072, 1762050814, -144550051, -2140837941, 426522225, 1852507879,\
    -19653770, -1982649376, 282753626, 1742555852, -105259153, -1900089351, 397917763, 1622183637,\
    -690576408, -1580100738, 953729732, 1340076626, -776247311, -1497606297, 1068828381, 1219638859,\
    -670225446, -1358292148, 906185462, 1090812512, -547295293, -1469587627, 829329135, 1181335161,\
    -882789492, -1134132454, 628085408, 1382605366, -871598187, -1156888829, 570562233, 1426400815,\
    -977650754, -1296233688, 733239954, 1555261956, -1026031705, -1244606671, 752459403, 1541320221,\
    -1687895376, -328994266, 1969922972, 40735498, -1677130071, -351390145, 1913087877, 83908371,\
    -1782625662, -491226604, 2075208622, 213261112, -1831694693, -438977011, 2094854071, 198958881,\
    -2032938284, -237706686, 1759359992, 534414190, -2118248755, -155638181, 1873836001, 414664567,\
    -2012718362, -15766928, 1711684554, 285281116, -1889165569, -127750551, 1634467795, 376229701,\
    -1609899400, -686959890, 1308918612, 956543938, -1486412191, -799009033, 1231636301, 1047427035,\
    -1362007478, -640263460, 1088359270, 936918000, -1447252397, -558129467, 1202900863, 817233897,\
    -1111625188, -893730166, 1404277552, 615818150, -1160759803, -841546093, 1423857449, 601450431,\
    -1285129682, -1000256840, 1567103746, 711928724, -1274298825, -1022587231, 1510334235, 755167117 }\
\
--String Utils :\
\
function toCharTable(str)  --Returns table of @str's chars\
    if not str then return nil end\
    str = tostring(str)\
\009local chars = {}\
\009for n=1,#str do\
\009\009chars[n] = str:sub(n,n)\
\009end\
\009return chars\
end\
\
function toByteTable(str)  --Returns table of @str's bytes\
    if not str then return nil end\
    str = tostring(str)\
\009local bytes = {}\
\009for n=1,#str do\
\009\009bytes[n] = str:byte(n)\
\009end\
\009return bytes\
end\
\
function fromCharTable(chars)  --Returns string made of chracters in @chars\
    if not chars or type(chars)~=\"table\" then return nil end\
\009return table.concat(chars)\
end\
\
function fromByteTable(bytes)  --Returns string made of bytes in @bytes\
    if not bytes or type(bytes)~=\"table\" then return nil end\
\009local str = \"\"\
\009for n=1,#bytes do\
\009\009str = str..string.char(bytes[n])\
\009end\
\009return str\
end\
\
function contains(str,find)  --Returns true if @str contains @find\
    if not str then return nil end\
    str = tostring(str)\
\009for n=1, #str-#find+1 do\
\009\009if str:sub(n,n+#find-1) == find then return true end\
\009end\
\009return false\
end\
\
function startsWith(str,Start) --Check if @str starts with @Start\
    if not str then return nil end\
    str = tostring(str)\
    return str:sub(1,Start:len())==Start\
end\
\
function endsWith(str,End)  --Check if @str ends with @End\
    if not str then return nil end\
    str = tostring(str)\
    return End=='' or str:sub(#str-#End+1)==End\
end\
\
function trim(str)  --Trim @str of initial/trailing whitespace\
    if not str then return nil end\
    str = tostring(str)\
    return (str:gsub(\"^%s*(.-)%s*$\", \"%1\"))\
end\
\
function firstLetterUpper(str)  --Capitilizes first letter of @str\
    if not str then return nil end\
    str = tostring(str)\
\009str = str:gsub(\"%a\", string.upper, 1)\
    return str\
end\
\
function titleCase(str)  --Changes @str to title case\
\009if not str then return nil end\
\009str = tostring(str)\
    local function tchelper(first, rest)\
\009\009return first:upper()..rest:lower()\
    end\
    str = str:gsub(\"(%a)([%w_']*)\", tchelper)\
\009return str\
end\
\
function isRepetition(str, pat)  --Checks if @str is a repetition of @pat\
    if not str then return nil end\
    str = tostring(str)\
\009return \"\" == str:gsub(pat, \"\")\
end\
\
function isRepetitionWS(str, pat)  --Checks if @str is a repetition of @pat seperated by whitespaces\
    if not str then return nil end\
    str = tostring(str)\
\009return not str:gsub(pat, \"\"):find\"%S\"\
end\
\
function urlDecode(str)  --Url decodes @str\
    if not str then return nil end\
    str = tostring(str)\
\009str = string.gsub (str, \"+\", \" \")\
\009str = string.gsub (str, \"%%(%x%x)\", function(h) return string.char(tonumber(h,16)) end)\
\009str = string.gsub (str, \"\\r\\n\", \"\\n\")\
\009return str\
end\
\
function urlEncode(str)  --Url encodes @str\
    if not str then return nil end\
    str = tostring(str)\
\009if (str) then\
\009\009str = string.gsub (str, \"\\n\", \"\\r\\n\")\
\009\009str = string.gsub (str, \"([^%w ])\", function (c) return string.format (\"%%%02X\", string.byte(c)) end)\
\009\009str = string.gsub (str, \" \", \"+\")\
\009end\
\009return str\
end\
\
function isEmailAddress(str)  --Checks if @str is a valid email address\
    if not str then return nil end\
    str = tostring(str)\
\009if (str:match(\"[A-Za-z0-9%.%%%+%-]+@[A-Za-z0-9%.%%%+%-]+%.%w%w%w?%w?\")) then\
\009\009return true\
\009else\
\009\009return false\
\009end\
end\
\
function chunk(str, size)  --Splits @str into chunks of length @size\
\009if not size then return nil end\
\009str = tostring(str)\
\009local num2App = size - (#str%size)\
\009str = str..(rep(char(0), num2App) or \"\")\
\009assert(#str%size==0)\
\009local chunks = {}\
\009local numChunks = #str / size\
\009local chunk = 0\
\009while chunk < numChunks do\
\009\009local start = chunk * size + 1\
        chunk = chunk+1\
\009\009if start+size-1 > #str-num2App then\
            if str:sub(start, #str-num2App) ~= (nil or \"\") then\
\009\009\009    chunks[chunk] = str:sub(start, #str-num2App)\
            end\
\009\009else\
\009\009\009chunks[chunk] = str:sub(start, start+size-1)\
\009\009end\
\009end\
\009return chunks\
end\
\
function find(str, match, startIndex)  --Finds @match in @str optionally after @startIndex\
\009if not match then return nil end\
\009str = tostring(str)\
\009local _ = startIndex or 1\
\009local _s = nil\
\009local _e = nil\
\009local _len = match:len()\
\009while true do\
\009\009local _t = str:sub( _ , _len + _ - 1)\
\009\009if _t == match then\
\009\009\009_s = _\
\009\009\009_e = _ + _len - 1\
\009\009\009break\
\009\009end\
\009\009_ = _ + 1\
\009\009if _ > str:len() then break end\
\009end\
\009if _s == nil then return nil else return _s, _e end\
end\
\
function seperate(str, divider)  --Separates @str on @divider\
\009if not divider then return nil end\
\009str = tostring(str)\
\009local start = {}\
\009local endS = {}\
\009local n=1\
\009repeat\
\009\009if n==1 then\
\009\009\009start[n], endS[n] = find(str, divider)\
\009\009else\
\009\009\009start[n], endS[n] = find(str, divider, endS[n-1]+1)\
        end\
\009\009n=n+1\
\009until start[n-1]==nil\
\009local subs = {}\
\009for n=1, #start+1 do\
\009\009if n==1 then\
\009\009\009subs[n] = str:sub(1, start[n]-1)\
\009\009elseif n==#start+1 then\
\009\009\009subs[n] = str:sub(endS[n-1]+1)\
\009\009else\
\009\009\009subs[n] = str:sub(endS[n-1]+1, start[n]-1)\
        end\
\009end\
\009return subs\
end\
\
function replace(str, from, to)  --Replaces @from to @to in @str\
\009if not from then return nil end\
\009str = tostring(str)\
\009local pcs = seperate(str, from)\
\009str = pcs[1]\
\009for n=2,#pcs do\
\009\009str = str..to..pcs[n]\
\009end\
\009return str\
end\
\
function jumble(str)  --Jumbles @str\
\009if not str then return nil end\
\009str = tostring(str)\
\009local chars = {}\
\009for i = 1, #str do\
\009\009chars[i] = str:sub(i, i)\
\009end\
\009local usedNums = \":\"\
\009local res = \"\"\
\009local rand = 0\
\009for i=1, #chars do\
\009\009while true do\
\009\009\009rand = math.random(#chars)\
\009\009\009if find(usedNums, \":\"..rand..\":\") == nil then break end\
\009\009end\
\009\009res = res..chars[rand]\
\009\009usedNums = usedNums..rand..\":\"\
\009end\
\009return res\
end\
\
function toBase(str, base)  --Encodes @str in @base\
\009if not base then return nil end\
\009str = tostring(str)\
\009local res = \"\"\
\009for i = 1, str:len() do\
\009\009if i == 1 then\
\009\009\009res = basen(str:byte(i), base)\
\009\009else\
\009\009\009res = res..\":\"..basen(str:byte(i), base)\
\009\009end\
\009end\
\009return res\
end\
\
function fromBase(str, base)  --Decodes @str from @base\
\009if not base then return nil end\
\009str = tostring(str)\
\009local bytes = seperate(str, \":\")\
\009local res = \"\"\
\009for i = 1, #bytes do\
\009\009res = res..(string.char(basen(tonumber(bytes[i], base), 10)))\
\009end\
\009return res\
end\
\
function toBinary(str)  --Encodes @str in binary\
\009if not str then return nil end\
\009str = tostring(str)\
\009return toBase(str, 2)\
end\
\
function fromBinary(str)  --Decodes @str from binary\
\009if not str then return nil end\
\009str = tostring(str)\
\009return fromBase(str, 2)\
end\
\
function toOctal(str)  --Encodes @str in octal\
\009if not str then return nil end\
\009str = tostring(str)\
\009return toBase(str, 8)\
end\
\
function fromOctal(str)  --Decodes @str from octal\
\009if not str then return nil end\
\009str = tostring(str)\
\009return fromBase(str, 8)\
end\
\
function toHex(str)  --Encodes @str in hex\
\009if not str then return nil end\
\009str = tostring(str)\
\009return toBase(str, 16)\
end\
\
function fromHex(str)  --Decodes @str from hex\
\009if not str then return nil end\
\009str = tostring(str)\
\009return fromBase(str, 16)\
end\
\
function toBase36(str)  --Encodes @str in Base36\
\009if not str then return nil end\
\009str = tostring(str)\
\009return toBase(str, 36)\
end\
\
function fromBase36(str)  --Decodes @str from Base36\
\009if not str then return nil end\
\009str = tostring(str)\
\009return fromBase(str, 36)\
end\
\
function toBase32(str)  --Encodes @str in Base32\
\009if not str then return nil end\
\009str = tostring(str)\
\009local byte=0\
\009local bits=0\
\009local rez=\"\"\
\009local i=0\
\009for i = 1, str:len() do\
\009\009byte=byte*256+str:byte(i)\
\009\009bits=bits+8\
\009\009repeat\
\009\009\009bits=bits-5\
\009\009\009local mul=(2^(bits))\
\009\009\009local b32n=math.floor(byte/mul)\
\009\009\009byte=byte-(b32n*mul)\
\009\009\009b32n=b32n+1\
\009\009\009rez=rez..string.sub(base32,b32n,b32n)\
\009\009until bits<5\
\009end\
\009if bits>0 then\
\009\009local b32n= math.fmod(byte*(2^(5-bits)),32)\
\009\009b32n=b32n+1\
\009\009rez=rez..string.sub(base32,b32n,b32n)\
\009end\
\009return rez\
end\
\
function fromBase32(str)  --Decodes @str from Base32\
\009if not str then return nil end\
\009str = tostring(str)\
\009local b32n=0\
\009local bits=0\
\009local rez=\"\"\
\009local i=0\
\009string.gsub(str:upper(), \"[\"..base32..\"]\", function (char)\
\009\009local num = string.find(base32, char, 1, true)\
\009\009b32n=b32n*32+(num - 1)\
\009\009bits=bits+5\
\009\009while  bits>=8 do\
\009\009\009bits=bits-8\
\009\009\009local mul=(2^(bits))\
\009\009\009local byte = math.floor(b32n/mul)\
\009\009\009b32n=b32n-(byte*mul)\
\009\009\009rez=rez..string.char(byte)\
\009\009end\
\009end)\
\009return rez\
end\
\
function toBase64(str)  --Encodes @str in Base64\
\009if not str then return nil end\
\009str = tostring(str)\
\009local bytes = {}\
\009local result = \"\"\
\009for spos=0,str:len()-1,3 do\
\009\009for byte=1,3 do bytes[byte] = str:byte(spos+byte) or 0 end\
\009\009result = string.format('%s%s%s%s%s',result,Base64.base64chars[Base64.rsh(bytes[1],2)],Base64.base64chars[Base64.lor(Base64.lsh((bytes[1] % 4),4), Base64.rsh(bytes[2],4))] or \"=\",((str:len()-spos) > 1) and Base64.base64chars[Base64.lor(Base64.lsh(bytes[2] % 16,2), Base64.rsh(bytes[3],6))] or \"=\",((str:len()-spos) > 2) and Base64.base64chars[(bytes[3] % 64)] or \"=\")\
\009end\
\009return result\
end\
\
function fromBase64(str)  --Decodes @str from Base64\
\009if not str then return nil end\
\009str = tostring(str)\
\009local chars = {}\
\009local result=\"\"\
\009for dpos=0,str:len()-1,4 do\
\009\009for char=1,4 do chars[char] = Base64.base64bytes[(str:sub((dpos+char),(dpos+char)) or \"=\")] end\
\009\009result = string.format('%s%s%s%s',result,string.char(Base64.lor(Base64.lsh(chars[1],2), Base64.rsh(chars[2],4))),(chars[3] ~= nil) and string.char(Base64.lor(Base64.lsh(chars[2],4), Base64.rsh(chars[3],2))) or \"\",(chars[4] ~= nil) and string.char(Base64.lor(Base64.lsh(chars[3],6) % 192, (chars[4]))) or \"\")\
\009end\
\009return result\
end\
\
function rot13(str)  --Rot13s @str\
\009if not str then return nil end\
\009str = tostring(str)\
\009local rot = \"\"\
\009local len = str:len()\
\009for i = 1, len do\
\009\009local k = str:byte(i)\
\009\009if (k >= 65 and k <= 77) or (k >= 97 and k <=109) then\
\009\009\009rot = rot..string.char(k+13)\
\009\009elseif (k >= 78 and k <= 90) or (k >= 110 and k <= 122) then\
\009\009\009rot = rot..string.char(k-13)\
\009\009else\
\009\009\009rot = rot..string.char(k)\
\009\009end\
\009end\
\009return rot\
end\
\
function rot47(str)  --Rot47s @str\
\009if not str then return nil end\
\009str = tostring(str)\
\009local rot = \"\"\
\009for i = 1, str:len() do\
\009\009local p = str:byte(i)\
\009\009if p >= string.byte('!') and p <= string.byte('O') then\
\009\009\009p = ((p + 47) % 127)\
\009\009elseif p >= string.byte('P') and p <= string.byte('~') then\
\009\009\009p = ((p - 47) % 127)\
\009\009end\
\009\009rot = rot..string.char(p)\
\009end\
\009return rot\
end\
\
function SHA1(str) --Returns SHA1 Hash of @str\
    if not str then return nil end\
    str = tostring(str)\
    local H0,H1,H2,H3,H4 = 0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0\
    local msg_len_in_bits = #str * 8\
    local first_append = char(0x80)\
    local non_zero_message_bytes = #str +1 +8\
    local current_mod = non_zero_message_bytes % 64\
    local second_append = current_mod>0 and rep(char(0), 64 - current_mod) or \"\"\
    local B1, R1 = modf(msg_len_in_bits  / 0x01000000)\
    local B2, R2 = modf( 0x01000000 * R1 / 0x00010000)\
    local B3, R3 = modf( 0x00010000 * R2 / 0x00000100)\
    local B4\009  =\0090x00000100 * R3\
    local L64 = char( 0) .. char( 0) .. char( 0) .. char( 0)\
            .. char(B1) .. char(B2) .. char(B3) .. char(B4)\
    str = str .. first_append .. second_append .. L64\
    assert(#str % 64 == 0)\
    local chunks = #str / 64\
    local W = { }\
    local start, A, B, C, D, E, f, K, TEMP\
    local chunk = 0\
    while chunk < chunks do\
        start,chunk = chunk * 64 + 1,chunk + 1\
        for t = 0, 15 do\
            W[t] = tSHA1.bytes_to_w32(str:byte(start, start + 3))\
            start = start + 4\
        end\
        for t = 16, 79 do\
            W[t] = tSHA1.w32_rot(1, tSHA1.w32_xor_n(W[t-3], W[t-8], W[t-14], W[t-16]))\
        end\
        A,B,C,D,E = H0,H1,H2,H3,H4\
        for t = 0, 79 do\
            if t <= 19 then\
                f = tSHA1.w32_or(tSHA1.w32_and(B, C), tSHA1.w32_and(tSHA1.w32_not(B), D))\
                K = 0x5A827999\
            elseif t <= 39 then\
                f = tSHA1.w32_xor_n(B, C, D)\
                K = 0x6ED9EBA1\
            elseif t <= 59 then\
                f = tSHA1.w32_or3(tSHA1.w32_and(B, C), tSHA1.w32_and(B, D), tSHA1.w32_and(C, D))\
                K = 0x8F1BBCDC\
            else\
                f = tSHA1.w32_xor_n(B, C, D)\
                K = 0xCA62C1D6\
            end\
            A,B,C,D,E = tSHA1.w32_add_n(tSHA1.w32_rot(5, A), f, E, W[t], K),\
            A, tSHA1.w32_rot(30, B), C, D\
        end\
        H0,H1,H2,H3,H4 = tSHA1.w32_add(H0, A),tSHA1.w32_add(H1, B),tSHA1.w32_add(H2, C),tSHA1.w32_add(H3, D),tSHA1.w32_add(H4, E)\
    end\
    local f = tSHA1.w32_to_hexstring\
    return f(H0) .. f(H1) .. f(H2) .. f(H3) .. f(H4)\
end\
\
function CRC32(str) --Returns CRC32 Hash of @str\
    local crc, l, i = 0xFFFFFFFF, string.len(str)\
    for i = 1, l, 1 do\
        crc = bit.bxor(bit.brshift(crc, 8), CRC.crc32[bit.band(bit.bxor(crc, string.byte(str, i)), 0xFF) + 1])\
    end\
    return bit.bxor(crc, -1)\
end\
\
function FCS16(str) --Returns FCS16 Hash of @str\
    local i\
    local l=string.len(str)\
    local uFcs16 = 65535\
    for i = 1,l do\
        uFcs16 = bit.bxor(bit.brshift(uFcs16,8), FCS[\"16\"][bit.band(bit.bxor(uFcs16, string.byte(str,i)), 255)])\
    end\
    return  bit.bxor(uFcs16, 65535)\
end\
\
function FCS32(str) --Returns FCS32 Hash of @str\
    local i\
    local l = string.len(str)\
    local uFcs32 = -1\
    for i=1,l do\
        uFcs32 = bit.bxor(bit.brshift(uFcs32,8), FCS[\"32\"][bit.band(bit.bxor(uFcs32, string.byte(str,i)), 255)])\
    end\
    return bit.bnot(uFcs32)\
end\
\
function encrypt(str, key)  --Encrypts @str with @key\
\009if not key then return nil end\
\009str = tostring(str)\
\009local alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~\"\
\009local _rand = math.random(#alphabet-10)\
\009local iv = string.sub(jumble(alphabet), _rand, _rand  + 9)\
\009iv = jumble(iv)\
\009str = iv..str\
\009local key = SHA1(key)\
\009local strLen = str:len()\
\009local keyLen = key:len()\
\009local j=1\
\009local result = \"\"\
\009for i=1, strLen do\
\009\009local ordStr = string.byte(str:sub(i,i))\
\009\009if j == keyLen then j=1 end\
\009\009local ordKey = string.byte(key:sub(j,j))\
\009\009result = result..string.reverse(basen(ordStr+ordKey, 36))\
\009\009j = j+1\
\009end\
\009return result\
end\
\
function decrypt(str, key)  --Decrypts @str with @key\
\009if not key then return nil end\
\009str = tostring(str)\
\009local key = SHA1(key)\
\009local strLen = str:len()\
\009local keyLen = key:len()\
\009local j=1\
\009local result = \"\"\
\009for i=1, strLen, 2 do\
\009\009local ordStr = basen(tonumber(string.reverse(str:sub(i, i+1)),36),10)\
\009\009if j==keyLen then j=1 end\
\009\009local ordKey = string.byte(key:sub(j,j))\
\009\009result = result..string.char(ordStr-ordKey)\
\009\009j = j+1\
\009end\
\009return result:sub(11)\
end\
\
function setRandSeed(seed)  --Sets random seed to @seed\
\009math.randomseed(seed)\
end\
\
setRandSeed(os.time())",
      "--[[\
\009cLinux : Lore of the Day!\
\009Made by Piorjade, daelvn\
\
\009NAME:        /lib/services.l\
\009CATEGORY:    Library\
\009SET:         Core Library\
\009VERSION:     01:alpha0\
\009DESCRIPTION:\
\009\009This script is manages things, that should be started after shell.\
\009\009Services can be added and removed as root.\
\009\009(Basically this is an autorun manager, for things like starting a window manager)\
]]--\
local serv = {}\
local list = {}\
\
local function initServicesConf()\
\009list['/sys/commandline'] = true\
\009for _, a in ipairs(fs.list(\"/etc/services.d\")) do\
\009\009list[a] = false\
\009end\
\009local file = fs.open(\"/etc/services.conf\", \"w\")\
\009file.write(textutils.serialize(list))\
\009file.close()\
end\
\
function serv.update()\
\009for _, a in ipairs(fs.list(\"/etc/services.d\")) do\
\009\009if list[a] == nil then\
\009\009\009list[a] = false\
\009\009end\
\009end\
\009for _, a in pairs(list) do\
\009\009if fs.exists(_) or fs.exists(\"/etc/services.d/\".._) then\
\
\009\009else\
\009\009\009list[_] = nil\
\009\009end\
\009end\
\009local file = fs.open(\"/etc/services.conf\", \"w\")\
\009file.write(textutils.serialize(list))\
\009file.close()\
end\
\
local file = fs.open(\"/etc/services.conf\", \"r\")\
if not file then\
\009print(\"error\")\
\009sleep(2)\
\009initServicesConf()\
else\
\009local inhalt = file.readAll()\
\009inhalt = textutils.unserialize(inhalt)\
\009file.close()\
\009local foundcore = false\
\009for k, v in pairs(inhalt) do\
\009\009if v == \"core\" then\
\009\009\009foundcore = true\
\009\009\009break\
\009\009else\
\009\009\009foundcore = false\
\009\009end\
\009end\
\009if not foundcore then\
\009\009initServicesConf()\
\009else\
\009\009list = inhalt\
\009\009serv.update()\
\
\009end\
end\
\
\
function serv.set(k, bool)\
\009if type(bool) ~= \"boolean\" and bool ~= \"core\" then return false, \"boolean exptected\" end\
\009serv.update()\
\009if list[k] ~= nil or fs.exists(k) then\
\009\009if bool == \"core\" then\
\009\009\009for _, a in pairs(list) do\
\009\009\009\009if a == \"core\" then\
\009\009\009\009\009list[_] = false\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009list[k] = bool\
\009\009serv.update()\
\009\009return true\
\009else\
\009\009return false, \"no such service\"\
\009end\
end\
\
function serv.giveList()\
\009return list\
end\
\
_putLib('serv', serv)",
      "--[[\
  cLinux001: cLinux 0.0.1 (complete rewrite)\
  NAME:        /startup\
  CATEGORY:    bootloader\
  VERSION:     0.0.1 (didn't decide a version-system yet.)\
  DESCRIPTION: Bootloader, may be called a 'GRUB' clone.\
\
  Made by Piorjade & thecrimulo\
]]--\
print(type(keys))\
print(type(_G.keys))\
sleep(2)\
--variables\
\
local bootList = {} --The list with bootable images (.i) is going to be stored here\
local selected = 1 --The pre-selected image\
local defaultcmd = {} --The default command, which the command is booted with\
\
--functions\
\
local function getList()\
\009local file = fs.open(\"/grubcfg\", \"r\")\
\009local inhalt = file.readAll()\
\009file.close()\
\009inhalt = textutils.unserialize(inhalt)\
\009bootList = inhalt.list\
\009selected = inhalt.default\
\009defaultcmd = inhalt.command\
\009blacklist = inhalt.blacklist\
    for _, a in ipairs(bootList) do\
        local i,j = string.find(a, \"../\")\
        if i then\
            table.remove(bootList, _)\
        end\
    end\
end\
\
local function readNoJump()\009--Reads the user input, but doesn't jump to the next line when finishing\
\009local str = \"\"\
\009local reading = true\
\009term.setCursorBlink(true)\
\009sleep(0.2)\
\009while reading do\
\009\009local _, k = os.pullEventRaw()\
\009\009local x, y = term.getCursorPos()\
\009\009if _ == \"key\" and k == keys.enter then\
\009\009\009term.setCursorBlink(false)\
\009\009\009reading = false\
\009\009\009return str\
\009\009elseif _ == \"key\" and k == keys.backspace and x > 1 then\
\009\009\009str = string.reverse(str)\
\009\009\009str = string.sub(str, 2)\
\009\009\009str = string.reverse(str)\
\009\009\009local x, y = term.getCursorPos()\
\009\009\009term.setCursorPos(x-1, y)\
\009\009\009term.write(\" \")\
\009\009\009term.setCursorPos(x-1, y)\
\009\009elseif _ == \"char\" then\
\009\009\009str = str..tostring(k)\
\009\009\009term.write(tostring(k))\
\009\009end\
\009end\
end\
\
local function drawMenu()\
\009local function clear()\
\009\009term.setCursorPos(1,1)\
\009\009term.setBackgroundColor(colors.black)\
\009\009term.setTextColor(colors.white)\
\009\009term.clear()\
\009end\
\009clear()\
\
\
\009oldTerm = term.current()\
\009local w, h = 15, 11\
\009local wlist = window.create(term.current(), 26-w/2, 10-h/2, w, h)\
\009local str = \"-GRUB-\"\
\009local str2 = \"Please select an image.\"\
\009local str3 = \"Press E to write additional commands.\"\
\009local cmd = window.create(term.current(), 26-#str3/2, 19, #str3, 1)\
\009cmd.setBackgroundColor(colors.gray)\
\009cmd.clear()\
\009term.setCursorPos(26-#str/2, 1)\
\009term.write(str)\
\009term.setCursorPos(26-#str2/2, 2)\
\009term.write(str2)\
\009term.setCursorPos(26-#str3/2, 18)\
\009term.write(str3)\
\009local function redrawList()\
\009\009wlist.setBackgroundColor(colors.gray)\
\009\009wlist.clear()\
\009\009wlist.setCursorPos(1,1)\
\009\009wlist.setTextColor(colors.white)\
\009\009term.redirect(wlist)\
\009\009for _, o in ipairs(bootList) do\
\009\009\009local x, y = term.getCursorPos()\
\009\009\009if _ == selected then\
\009\009\009\009term.setBackgroundColor(colors.lightBlue)\
\009\009\009\009term.clearLine()\
\009\009\009\009term.write(o)\
\009\009\009\009if _ < #bootList then\
\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009end\
\009\009\009\009term.setBackgroundColor(colors.gray)\
\009\009\009else\
\009\009\009\009term.write(o)\
\009\009\009\009if _ < #bootList then\
\009\009\009\009\009term.setCursorPos(1, y+1)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009term.redirect(oldTerm)\
\009end\
\
\009local function redrawCommand()\
\009\009term.redirect(cmd)\
\009\009term.setCursorPos(1,1)\
\009\009term.setBackgroundColor(colors.gray)\
\009\009term.setTextColor(colors.lime)\
\009\009term.clear()\
\009\009if defaultcmd[selected] ~= nil then\
\009\009\009term.write(defaultcmd[selected])\
\009\009else\
\009\009\009term.write(\"NONE\")\
\009\009end\
\009\009term.redirect(oldTerm)\
\009end\
\
\009redrawList()\
\009redrawCommand()\
\009local running = true\
\009term.redirect(wlist)\
\009while running do\
\009\009local _, k = os.pullEventRaw(\"key\")\
\009\009if k == keys.up and selected > 1 then\
\009\009\009selected = selected-1\
\009\009\009redrawList()\
\009\009\009redrawCommand()\
\009\009elseif k == keys.down and selected < #bootList then\
\009\009\009selected = selected+1\
\009\009\009redrawList()\
\009\009\009redrawCommand()\
\009\009elseif k == keys.e then\
\009\009\009term.redirect(cmd)\
\009\009\009term.setCursorPos(1,1)\
\009\009\009term.setBackgroundColor(colors.gray)\
\009\009\009term.setTextColor(colors.lime)\
\009\009\009term.clear()\
\009\009\009local e = readNoJump()\
\009\009\009term.redirect(oldTerm)\
\009\009\009defaultcmd[selected] = e\
\009\009elseif k == keys.enter then\
\009\009\009if fs.exists(\"/boot/\"..bootList[selected]) == false then\
\009\009\009\009clear()\
\009\009\009\009printError(\"/boot/\"..bootList[selected]..\" does not exist.\")\
\009\009\009\009running = false\
\009\009\009\009break\
\009\009\009else\
\009\009\009\009running = false\
\009\009\009\009clear()\
\009\009\009\009local tArgs = {}\
\009\009\009\009if defaultcmd[selected] ~= nil then\
\009\009\009\009\009repeat\
\009\009\009\009\009\009local i, j = string.find(defaultcmd[selected], \" \")\
\009\009\009\009\009\009if i then\
\009\009\009\009\009\009\009local a = string.sub(defaultcmd[selected], 1, i-1)\
\009\009\009\009\009\009\009table.insert(tArgs, a)\
\009\009\009\009\009\009\009defaultcmd[selected] = string.sub(defaultcmd[selected], j+1, #defaultcmd[selected])\
\009\009\009\009\009\009end\
\009\009\009\009\009until i == nil\
\009\009\009\009\009table.insert(tArgs, defaultcmd[selected])\
\009\009\009\009end\
\
\009\009\009\009term.redirect(oldTerm)\
\009\009\009\009term.setCursorPos(1,1)\
\009\009\009\009term.clear()\
\009\009\009\009os.run({}, \"/boot/\"..bootList[selected], unpack(tArgs))\
\009\009\009end\
\009\009end\
\009end\
\009term.redirect(oldTerm)\
end\
\
\
if fs.exists(\"/grubcfg\") then\
\009getList()\
\
\009if #bootList <= 11 then\
\009\009drawMenu()\
\009elseif #bootList > 11 then\
\009\009printError(\"/grubcfg: Too many entries.\")\
\009elseif #bootList < 1 then\
\009\009printError(\"/grubcfg: No entries.\")\
\009end\
else\
\009printError(\"/grubcfg: Not found.\")\
end",
      "cd changes the the directory you're in.\
\
ex:\
\"cd rom\" will move to \"rom\" folder.\
\"cd ..\" will move up one folder.\
\"cd /\" will move to the root.",
      "repeat is a program for repeating rednet messages across long distances. To use, connect 2 or more modems to a computer and run the \"repeat\" program; from then on, any rednet message sent from any computer in wireless range or connected by networking cable to either of the modems will be repeated to those on the other side.",
      "Wired and Wireless Modems are peripheral devices available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Modem is connected, peripheral.getType() will return \"modem\".\
\
Methods exposed by Modems:\
open( channel )\
isOpen( channel )\
close( channel )\
closeAll()\
transmit( channel, replyChannel, message )\
isWireless()\
\
Events fired by Modems:\
\"modem_message\" when a message is received on an open channel. Arguments are name, channel, replyChannel, message, distance",
      "help is the help tool you're currently using.\
Type \"help index\" to see all help topics.\
Type \"help\" to see the help intro.\
Type \"help helpapi\" for information on the help Lua API.",
      "Functions in the GPS API:\
gps.locate( timeout )\
\
The locate function will send a signal to nearby gps servers, and wait for responses before the timeout. If it receives enough responses to determine this computers position then x, y and z co-ordinates will be returned, otherwise it will return nil. If GPS hosts do not have their positions configured correctly, results will be inaccurate.",
      "mv moves a file or directory from one location to another.\
\
ex:\
\"mv foo bar\" renames the file \"foo\" to \"bar\".\
\"mv foo bar/foo\" moves the file \"foo\" to a folder called \"bar\".\
\"mv disk/* disk2\" moves the contents of one disk to another",
      "time prints the current time of day.",
      "Functions in the os (Operating System) API:\
os.version()\
os.getComputerID()\
os.getComputerLabel()\
os.setComputerLabel()\
os.run( environment, programpath, arguments )\
os.loadAPI( path )\
os.unloadAPI( name )\
os.pullEvent( [filter] )\
os.queueEvent( event, arguments )\
os.clock()\
os.startTimer( timeout )\
os.cancelTimer( token )\
os.sleep( timeout )\
os.time()\
os.day()\
os.setAlarm( time )\
os.cancelAlarm( token )\
os.shutdown()\
os.reboot()\
\
Events emitted by the os API:\
\"timer\" when a timeout started by os.startTimer() completes. Argument is the token returned by os.startTimer().\
\"alarm\" when a time passed to os.setAlarm() is reached. Argument is the token returned by os.setAlarm().\
Type \"help events\" to learn about the event system.",
      "multishell is the toplevel program on Advanced Computers which manages background tabs.\
Type \"help shellapi\" for information about the shell lua api.",
      "The keys API contains constants for all the key codes that can be returned by the \"key\" event:\
\
Example usage:\
local sEvent, nKey = os.pullEvent()\
if sEvent == \"key\" and nKey == keys.enter then\
   -- Do something  \
end\
\
See http://www.minecraftwiki.net/wiki/Key_codes, or the source code, for a complete reference.",
      "Surf the rednet superhighway with \"chat\", the networked chat program for CraftOS! Host chatrooms and invite your friends! Requires a Wired or Wireless Modem on each computer. When running chat, type \"/help\" to see a list of available commands.\
\
ex:\
\"chat host forgecraft\" will create a chatroom with the name \"forgecraft\"\
\"chat join forgecraft direwolf20\" will connect to the chatroom with the name \"forgecraft\", using the nickname \"direwolf20\"",
      "math is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "alias assigns shell commands to run other programs.\
\
ex:\
\"alias dir ls\" will make the \"dir\" command run the \"ls\" program\
\"alias dir\" will remove the alias set on \"dir\"\
\"alias\" will list all current aliases.",
      "type determines the type of a file or directory. Prints \"file\", \"directory\" or \"does not exist\".",
      "Functions in the Redstone API:\
redstone.getSides( )\
redstone.getInput( side )\
redstone.setOutput( side, boolean )\
redstone.getOutput( side )\
redstone.getAnalogInput( side )\
redstone.setAnalogOutput( side, number )\
redstone.getAnalogOutput( side )\
\
Functions in the Redstone API for working with bundled cables:\
redstone.getBundledInput( side )\
redstone.testBundledInput( side, color )\
redstone.setBundledOutput( side, colors )\
redstone.getBundledOutput( side )\
Type \"help bundled\" for usage examples.\
\
Events emitted by the redstone API:\
\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\
Type \"help events\" to learn about the event system.",
      "go is a program for Turtles, used to control the turtle without programming. It accepts one or more commands as a direction followed by a distance.\
\
ex:\
\"go forward\" moves the turtle 1 space forward.\
\"go forward 3\" moves the turtle 3 spaces forward.\
\"go forward 3 up left 2\" moves the turtle 3 spaces forward, 1 spaces up, then left 180 degrees.",
      "The Disk Drive is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Disk Drive is connected, peripheral.getType() will return \"drive\".\
\
Methods exposed by the Disk Drive:\
isDiskPresent()\
getDiskLabel()\
setDiskLabel( label )\
hasData()\
getMountPath()\
hasAudio()\
getAudioTitle()\
playAudio()\
stopAudio()\
ejectDisk()\
getDiskID()\
\
Events fired by the Disk Drive:\
\"disk\" when a disk or other item is inserted into the drive. Argument is the name of the drive.\
\"disk_eject\" when a disk is removed from a  drive. Argument is the name of the drive.\
Type \"help events\" to learn about the event system.",
      "Functions in the HTTP API:\
http.checkURL( url )\
http.request( url, [postData], [headers] )\
http.get( url, [headers] )\
http.post( url, postData, [headers] )\
\
The HTTP API may be disabled in ComputerCraft.cfg\
A period of time after a http.request() call is made, a \"http_success\" or \"http_failure\" event will be raised. Arguments are the url and a file handle if successful. http.get() and http.post() block until this event fires instead.",
      "On a Command Computer, \"commands\" will list all the commands available for use. Use \"exec\" to execute them.\
Type \"help commandsapi\" for help using commands in lua programs.",
      "Functions in the 3D Vector Math API:\
vector.new( x,y,z )\
\
Vectors returned by vector.new() have the following fields and methods:\
vector.x\
vector.y\
vector.z\
vector:add( vector )\
vector:sub( vector )\
vector:mul( number )\
vector:dot( vector )\
vector:cross( vector )\
vector:length()\
vector:normalize()\
vector:round()\
vector:tostring()\
The +, - and * operators can also be used on vectors.",
      "dj plays Music Discs from disk drives attached to the computer.\
\
ex:\
\"dj\" or \"dj play\" plays a random disc.\
\"dj play left\" plays the disc in the drive on the left of the computer.\
\"dj stop\" stops the current disc.",
      "Copyright (c) 2007 LuaJ. All rights reserved.\
\
Permission is hereby granted, free of charge, to any person obtaining a copy\
of this software and associated documentation files (the \"Software\"), to deal\
in the Software without restriction, including without limitation the rights\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\
copies of the Software, and to permit persons to whom the Software is\
furnished to do so, subject to the following conditions:\
\
The above copyright notice and this permission notice shall be included in\
all copies or substantial portions of the Software.\
\
THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\
THE SOFTWARE.",
      "New Features in ComputerCraft 1.79:\
\
* Ported ComputerCraftEdu to Minecraft 1.8.9\
* Fixed a handful of bugs in ComputerCraft\
\
Type \"help changelog\" to see the full version history.",
      "Functions in the Redstone API:\
rs.getSides( )\
rs.getInput( side )\
rs.setOutput( side, boolean )\
rs.getOutput( side )\
rs.getAnalogInput( side )\
rs.setAnalogOutput( side, number )\
rs.getAnalogOutput( side )\
\
Functions in the Redstone API for working with RedPower bundled cables:\
rs.getBundledInput( side )\
rs.testBundledInput( side, color )\
rs.setBundledOutput( side, colors )\
rs.getBundledOutput( side )\
Type \"help bundled\" for usage examples.\
\
Events emitted by the redstone API:\
\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\
Type \"help events\" to learn about the event system.",
      "To set bundled outputs:\
c = colors.combine( colors.red, colors.blue )\
rs.setBundledOutput( \"left\", c )\
\
c = colors.combine( c, colors.green )\
rs.setBundledOutput( \"left\", c )\
\
c = colors.subtract( c, colors.blue )\
rs.setBundledOutput( \"left\", c )\
\
To get bundled inputs:\
c = rs.getBundledInput( \"right\" )\
red = colors.test( c, colors.red )\
\
Type \"help colors\" for the list of wire colors.",
      "lua is an interactive prompt for the lua programming language. It's a useful tool for learning the language.",
      "adventure is a text adventure game for CraftOS. To navigate around the world of adventure, type simple instructions to the interpreter, for example: \"go north\", \"punch tree\", \"craft planks\", \"mine coal with pickaxe\", \"hit creeper with sword\"",
      "Functions in the Terminal API:\
term.write( text )\
term.blit( text, textColor, backgroundColor )\
term.clear()\
term.clearLine()\
term.getCursorPos()\
term.setCursorPos( x, y )\
term.setCursorBlink( blink )\
term.isColor()\
term.setTextColor( color )\
term.setBackgroundColor( color )\
term.getTextColor()\
term.getBackgroundColor()\
term.getSize()\
term.scroll( n )\
term.redirect( object )\
term.current()\
\
Events emitted by the terminals:\
\"term_resize\", when the size of a terminal changes. This can happen in multitasking environments, or when the terminal out is being redirected by the \"monitor\" program.",
      "reboot will turn the computer off and on again.\
You can also hold Ctrl+R at any time to quickly reboot.",
      "io is a standard Lua5.1 API, reimplemented for CraftOS. Not all the features are availiable.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "programs lists all the programs on the rom of the computer.",
      "Functions in the Text Utilities API:\
textutils.slowPrint( text )\
textutils.tabulate( table, table2, ... )\
textutils.pagedTabulate( table, table2, ... )\
textutils.formatTime( time, bTwentyFourHour )\
textutils.serialize( table )\
textutils.unserialize( string )\
textutils.serializeJSON( table, [useNBTStyle] )\
textutils.urlEncode( string )\
textutils.complete( string, table )",
      "bg is a program for Advanced Computers which opens a new tab in the background.\
\
ex:\
\"bg\" will open a background tab running the shell\
\"bg worm\" will open a background tab running the \"worm\" program",
      "ls will list all the directories and files in the current location. Use \"type\" to find out if an item is a file or a directory.",
      "tunnel is a program for Mining Turtles. Tunnel will mine a 3x2 tunnel of the depth specified.\
\
ex:\
\"tunnel 20\" will tunnel a tunnel 20 blocks long.",
      "sleep makes the computer idle for a specific number of seconds.\
\
ex:\
\"sleep 10\" puts the computer to sleep for 10 seconds",
      "The set program can be used to inspect and change system settings.\
\
Usage:\
\"set\" will print all the system settings and their values\
\"set foo\" will print the value of the system setting \"foo\"\
\"set foo bar\" will set the value of the system setting \"foo\" to \"bar\"",
      "The Printer is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Printer is connected, peripheral.getType() will return \"printer\".\
\
Methods exposed by the Printer:\
getInkLevel()\
getPaperLevel()\
newPage()\
setPageTitle( title )\
getPageSize()\
setCursorPos( x, y )\
getCursorPos()\
write( text )\
endPage()",
      "craft is a program for Crafty Turtles. Craft will craft a stack of items using the current inventory.\
\
ex:\
\"craft\" will craft as many items as possible\
\"craft 5\" will craft at most 5 times",
      "\"From Russia with Fun\" comes a fun, new, suspiciously-familiar falling block game for CraftOS. Only on Pocket Computers!",
      "excavate is a program for Mining Turtles. When excavate is run, the turtle will mine a rectangular shaft into the ground, collecting blocks as it goes, and return to the surface once bedrock is hit.\
\
ex:\
\"excavate 3\" will mine a 3x3 shaft.",
      "Functions in the colors api\
(used for redstone.setBundledOutput):\
colors.combine( color1, color2, color3, ... )\
colors.subtract( colors, color1, color2, ... )\
colors.test( colors, color )\
\
Color constants in the colors api, in ascending bit order:\
colors.white, colors.orange, colors.magenta, colors.lightBlue, colors.yellow, colors.lime, colors.pink, colors.gray, colors.lightGray, colors.cyan, colors.purple, colors.blue, colors.brown, colors.green, colors.red, colors.black.",
      "Functions in the Filesystem API:\
fs.list( path )\
fs.find( wildcard )\
fs.exists( path )\
fs.isDir( path )\
fs.isReadOnly( path )\
fs.getDir( path )\
fs.getName( path )\
fs.getSize( path )\
fs.getDrive( path )\
fs.getFreeSpace( path )\
fs.makeDir( path )\
fs.move( path, path )\
fs.copy( path, path )\
fs.delete( path )\
fs.combine( path, localpath )\
fs.open( path, mode )\
fs.complete( path, location )\
Available fs.open() modes are \"r\", \"w\", \"a\", \"rb\", \"wb\" and \"ab\".\
\
Functions on files opened with mode \"r\":\
readLine()\
readAll()\
close()\
\
Functions on files opened with mode \"w\" or \"a\":\
write( string )\
writeLine( string )\
flush()\
close()\
\
Functions on files opened with mode \"rb\":\
read()\
close()\
\
Functions on files opened with mode \"wb\" or \"ab\":\
write( byte )\
flush()\
close()",
      "wget is a program for downloading files from the internet. This is useful for downloading programs created by other players.\
The HTTP API must be enabled in ComputerCraft.cfg to use this program.\
\
ex:\
\"wget http://pastebin.com/raw/CxaWmPrX test\" will download the file from the URL http://pastebin.com/raw/CxaWmPrX, and save it as \"test\".",
      "The rednet API provides a simple computer networking model using modems.\
\
Functions in the rednet API:\
rednet.open( side )\
rednet.close( [side] )\
rednet.isOpen( [side] )\
rednet.send( receiverID, message, [protocol] ) -- Send to a specific computer\
rednet.broadcast( message, [protocol] ) -- Send to all computers\
rednet.receive( [protocol], [timeout] ) -- Returns: senderID, message, protocol\
rednet.host( protocol, hostname )\
rednet.unhost( protocol )\
rednet.lookup( protocol, [hostname] ) -- Returns: ID\
\
Events fired by the rednet API:\
\"rednet_message\" when a message is received. Arguments are senderID, message, protocol\
Type \"help events\" to learn about the event system.\
\
Rednet is not the only way to use modems for networking. Interfacing with the modem directly using the peripheral API and listening for the \"modem_message\" event allows for lower level control, at the expense of powerful high level networking features.",
      "rm deletes a file or a directory and its contents.\
\
ex:\
\"rm foo\" will delete the file foo.\
\"rm disk/*\" will delete the contents of a disk.",
      "unequip is a program for Turtles. unequip will remove tools of peripherals from the specified side of the turtle.\
\
ex:\
\"unequip left\" will remove the item on the left side of the turtle",
      "The peripheral API is for interacting with external peripheral devices. Type \"help peripherals\" to learn about the peripherals available.\
\
Functions in the peripheral API:\
peripheral.getNames()\
peripheral.isPresent( name )\
peripheral.getType( name )\
peripheral.getMethods( name )\
peripheral.call( name, methodName, param1, param2, etc )\
peripheral.wrap( name )\
peripheral.find( type, [fnFilter] )\
\
Events fired by the peripheral API:\
\"peripheral\" when a new peripheral is attached. Argument is the name.\
\"peripheral_detach\" when a peripheral is removed. Argument is the name.\
Type \"help events\" to learn about the event system.",
      "turn is a program for Turtles, used to turn the turtle around without programming. It accepts one or more commands as a direction and a number of turns. The \"go\" program can also be used for turning.\
\
ex:\
\"turn left\" turns the turtle 90 degrees left.\
\"turn right 2\" turns the turtle 180 degrees right.\
\"turn left 2 right\" turns left 180 degrees, then right 90 degrees.",
      "Functions in the Settings API:\
settings.get( name, [default] )\
settings.set( name, value )\
settings.unset( name )\
settings.load( path )\
settings.save( path )\
settings.clear()\
settings.getNames()",
      "The redstone program can be used to get, set or pulse redstone inputs and outputs from the computer.\
\
ex:\
\"redstone probe\" will list all the redstone inputs to the computer\
\"redstone set left true\" turns on the left redstone output.\
\"redstone set right blue false\" turns off the blue wire in the bundled cable on the right redstone output.\
\"redstone pulse front 10 1\" emits 10 one second redstone pulses on the front redstone output.\
\
Type \"help redstoneapi\" or \"help rs\" for information on the redstone Lua API.",
      "refuel is a program for Turtles. Refuel will consume items from the inventory as fuel for turtle.\
\
ex:\
\"refuel\" will refuel with at most one fuel item\
\"refuel 10\" will refuel with at most 10 fuel items\
\"refuel all\" will refuel with as many fuel items as possible",
      "Redirection ComputerCraft Edition is the CraftOS version of a fun new puzzle game by Dan200, the author of ComputerCraft.\
Play it on any Advanced Computer, then visit http://www.redirectiongame.com to play the full game!",
      "Functions in the Parallel API:\
parallel.waitForAny( function1, function2, ... )\
parallel.waitForAll( function1, function2, ... )\
These methods provide an easy way to run multiple lua functions simultaneously.",
      "The function os.pullEvent() will yield the program until a system event occurs. The first return value is the event name, followed by any arguments.\
\
Some events which can occur are:\
\"char\" when text is typed on the keyboard. Argument is the character typed.\
\"key\" when a key is pressed on the keyboard. Arguments are the keycode and whether the key is a repeat. Compare the keycode to the values in keys API to see which key was pressed.\
\"key_up\" when a key is released on the keyboard. Argument is the numerical keycode. Compare to the values in keys API to see which key was released.\
\"paste\" when text is pasted from the users keyboard. Argument is the line of text pasted.\
\
Events only on advanced computers:\
\"mouse_click\" when a user clicks the mouse. Arguments are button, xPos, yPos.\
\"mouse_drag\" when a user moves the mouse when held. Arguments are button, xPos, yPos.\
\"mouse_up\" when a user releases the mouse button. Arguments are button, xPos, yPos.\
\"mouse_scroll\" when a user uses the scrollwheel on the mouse. Arguments are direction, xPos, yPos.\
\
Other APIs and peripherals will emit their own events. See their respective help pages for details.",
      "New Features in ComputerCraft 1.79:\
\
* Ported ComputerCraftEdu to Minecraft 1.8.9\
* Fixed a handful of bugs in ComputerCraft\
\
New Features in ComputerCraft 1.77:\
\
* Ported to Minecraft 1.8.9\
* Added \"settings\" API\
* Added \"set\" and \"wget\" programs\
* Added settings to disable multishell, startup scripts, and tab completion on a per-computer basis. The default values for these settings can be customised in ComputerCraft.cfg\
* All Computer and Turtle items except Command Computers can now be mounted in Disk Drives\
\
New Features in ComputerCraft 1.76:\
\
* Ported to Minecraft 1.8\
* Added Ender Modems for cross-dimensional communication\
* Fixed handling of 8-bit characters. All the characters in the ISO 8859-1 codepage can now be displayed\
* Added some extra graphical characters in the unused character positions, including a suite of characters for Teletext style drawing\
* Added support for the new commands in Minecraft 1.8 to the Command Computer\
* The return values of turtle.inspect() and commands.getBlockInfo() now include blockstate information\
* Added commands.getBlockInfos() function for Command Computers\
* Added new \"peripherals\" program\
* Replaced the \"_CC_VERSION\" and \"_MC_VERSION\" constants with a new \"_HOST\" constant\
* Shortened the length of time that \"Ctrl+T\", \"Ctrl+S\" and \"Ctrl+R\" must be held down for to terminate, shutdown and reboot the computer\
* textutils.serialiseJSON() now takes an optional parameter allowing it to produce JSON text with unquoted object keys. This is used by all autogenerated methods in the \"commands\" api except for \"title\" and \"tellraw\"\
* Fixed many bugs\
\
New Features in ComputerCraft 1.75:\
\
* Fixed monitors sometimes rendering without part of their text.\
* Fixed a regression in the \"bit\" API.\
\
New Features in ComputerCraft 1.74:\
\
* Added tab completion to \"edit\", \"lua\" and the shell.\
* Added textutils.complete(), fs.complete(), shell.complete(), shell.setCompletionFunction() and help.complete().\
* Added tab completion options to read().\
* Added \"key_up\" and \"mouse_up\" events.\
* Non-advanced terminals now accept both grey colours.\
* Added term.getTextColour(), term.getBackgroundColour() and term.blit().\
* Improved the performance of text rendering on Advanced Computers.\
* Added a \"Run\" button to the edit program on Advanced Computers.\
* Turtles can now push players and entities (configurable).\
* Turtles now respect server spawn protection (configurable).\
* Added a turtle permissions API for mod authors.\
* Implemented a subset of the Lua 5.2 API so programs can be written against it now, ahead of a future Lua version upgrade.\
* Added a config option to disable parts of the Lua 5.1 API which will be removed when a future Lua version upgrade happens.\
* Command Computers can no longer be broken by survival players.\
* Fixed the \"pick block\" key not working on ComputerCraft items in creative mode.\
* Fixed the \"edit\" program being hard to use on certain European keyboards.\
* Added \"_CC_VERSION\" and \"_MC_VERSION\" constants.\
\
New Features in ComputerCraft 1.73:\
\
* The \"exec\" program, commands.exec() and all related Command Computer functions now return the console output of the command.\
* Fixed two multiplayer crash bugs.\
\
New Features in ComputerCraft 1.7:\
\
* Added Command Computers\
* Added new API: commands\
* Added new programs: commands, exec\
* Added textutils.serializeJSON()\
* Added ILuaContext.executeMainThreadTask() for peripheral developers\
* Disk Drives and Printers can now be renamed with Anvils\
* Fixed various bugs, crashes and exploits\
* Fixed problems with HD texture packs\
* Documented the new features in the in-game help\
\
New Features in ComputerCraft 1.65:\
\
* Fixed a multiplayer-only crash with turtle.place()\
* Fixed some problems with http.post()\
* Fixed fs.getDrive() returning incorrect results on remote peripherals\
\
New Features in ComputerCraft 1.64:\
\
* Ported to Minecraft 1.7.10\
* New turtle functions: turtle.inspect(), turtle.inspectUp(), turtle.inspectDown(), turtle.getItemDetail()\
* Lots of bug and crash fixes, a huge stability improvement over previous versions\
\
New Features in ComputerCraft 1.63:\
\
* Turtles can now be painted with dyes, and cleaned with water buckets\
* Added a new game: Redirection - ComputerCraft Edition\
* Turtle label nameplates now only show when the Turtle is moused-over\
* The HTTP API is now enabled by default, and can be configured with a whitelist of permitted domains\
* http.get() and http.post() now accept parameters to control the request headers\
* New fs function: fs.getDir( path )\
* Fixed some bugs\
\
New Features in ComputerCraft 1.62:\
\
* Added IRC-style commands to the \"chat\" program\
* Fixed some bugs and crashes\
\
New Features in ComputerCraft 1.6:\
\
* Added Pocket Computers\
* Added a multi-tasking system for Advanced Computers and Turtles\
* Turtles can now swap out their tools and peripherals at runtime\
* Turtles can now carry two tools or peripherals at once in any combination\
* Turtles and Computers can now be labelled using Name Tags and Anvils\
* Added a configurable fuel limit for Turtles\
* Added hostnames, protocols and long distance routing to the rednet API\
* Added a peer-to-peer chat program to demonstrate new rednet capabilities\
* Added a new game, only on Pocket Computers: \"falling\" by GopherATL\
* File system commands in the shell now accept wildcard arguments\
* The shell now accepts long arguments in quotes\
* Terminal redirection now no longer uses a stack-based system. Instead: term.current() gets the current terminal object and term.redirect() replaces it. term.restore() has been removed.\
* Added a new Windowing API for addressing sub-areas of the terminal\
* New programs: fg, bg, multishell, chat, repeat, redstone, equip, unequip\
* Improved programs: copy, move, delete, rename, paint, shell\
* Removed programs: redset, redprobe, redpulse\
* New APIs: window, multishell\
* New turtle functions: turtle.equipLeft() and turtle.equipRight()\
* New peripheral functions: peripheral.find( [type] )\
* New rednet functions: rednet.host( protocol, hostname ), rednet.unhost( protocol ), rednet.locate( protocol, [hostname] )\
* New fs function: fs.find( wildcard )\
* New shell functions: shell.openTab(), shell.switchTab( [number] )\
* New event \"term_resize\" fired when the size of a terminal changes\
* Improved rednet functions: rednet.send(), rednet.broadcast() and rednet.receive() now take optional protocol parameters\
* turtle.craft(0) and turtle.refuel(0) now return true if there is a valid recipe or fuel item, but do not craft of refuel anything\
* turtle.suck( [limit] ) can now be used to limit the number of items picked up\
* Users of turtle.dig() and turtle.attack() can now specify which side of the turtle to look for a tool to use (by default, both will be considered)\
* textutils.serialise( text ) now produces human-readable output\
* Refactored most of the codebase and fixed many old bugs and instabilities, turtles should never ever lose their content now\
* Fixed the \"turtle_inventory\" event firing when it shouldn't have\
* Added error messages to many more turtle functions after they return false\
* Documented all new programs and API changes in the \"help\" system\
\
New Features in ComputerCraft 1.58:\
\
* Fixed a long standing bug where turtles could lose their identify if they travel too far away\
* Fixed use of deprecated code, ensuring mod compatibility with the latest versions of Minecraft Forge, and world compatibility with future versions of Minecraft\
\
New Features in ComputerCraft 1.57:\
\
* Ported to Minecraft 1.6.4\
* Added two new Treasure Disks: Conway's Game of Life by vilsol and Protector by fredthead\
* Fixed a very nasty item duplication bug\
\
New Features in ComputerCraft 1.56:\
\
* Added Treasure Disks: Floppy Disks in dungeons which contain interesting community made programs. Find them all!\
* All turtle functions now return additional error messages when they fail.\
* Resource Packs with Lua Programs can now be edited when extracted to a folder, for easier editing.\
\
New Features in ComputerCraft 1.55:\
\
* Ported to Minecraft 1.6.2\
* Added Advanced Turtles\
* Added \"turtle_inventory\" event. Fires when any change is made to the inventory of a turtle\
* Added missing functions io.close, io.flush, io.input, io.lines, io.output\
* Tweaked the screen colours used by Advanced Computers, Monitors and Turtles\
* Added new features for Peripheral authors\
* Lua programs can now be included in Resource Packs\
\
New Features in ComputerCraft 1.52:\
\
* Ported to Minecraft 1.5.1\
\
New Features in ComputerCraft 1.51:\
\
* Ported to Minecraft 1.5\
* Added Wired Modems\
* Added Networking Cables\
* Made Wireless Modems more expensive to craft\
* New redstone API functions: getAnalogInput(), setAnalogOutput(), getAnalogOutput()\
* Peripherals can now be controlled remotely over wired networks. New peripheral API function: getNames()\
* New event: \"monitor_resize\" when the size of a monitor changes\
* Except for labelled computers and turtles, ComputerCraft blocks no longer drop items in creative mode\
* The pick block function works in creative mode now works for all ComputerCraft blocks\
* All blocks and items now use the IDs numbers assigned by FTB by default\
* Fixed turtles sometimes placing blocks with incorrect orientations\
* Fixed Wireless modems being able to send messages to themselves\
* Fixed turtle.attack() having a very short range\
* Various bugfixes\
\
New Features in ComputerCraft 1.5:\
\
* Redesigned Wireless Modems; they can now send and receive on multiple channels, independent of the computer ID. To use these features, interface with modem peripherals directly. The rednet API still functions as before\
* Floppy Disks can now be dyed with multiple dyes, just like armour\
* The \"excavate\" program now retains fuel in it's inventory, so can run unattended\
* turtle.place() now tries all possible block orientations before failing\
* turtle.refuel(0) returns true if a fuel item is selected\
* turtle.craft(0) returns true if the inventory is a valid recipe\
* The in-game help system now has documentation for all the peripherals and their methods, including the new modem functionality\
* A romantic surprise\
\
New Features in ComputerCraft 1.48:\
\
* Ported to Minecraft 1.4.6\
* Advanced Monitors now emit a \"monitor_touch\" event when right clicked\
* Advanced Monitors are now cheaper to craft\
* Turtles now get slightly less fuel from items\
* Computers can now interact with Command Blocks (if enabled in ComputerCraft.cfg)\
* New API function: os.day()\
* A christmas surprise\
\
New Features in ComputerCraft 1.45:\
\
* Added Advanced Computers\
* Added Advanced Monitors\
* New program: paint by nitrogenfingers\
* New API: paintutils\
* New term functions: term.setBackgroundColor, term.setTextColor, term.isColor\
* New turtle function: turtle.transferTo\
\
New Features in ComputerCraft 1.43:\
\
* Added Printed Pages\
* Added Printed Books\
* Fixed incompatibility with Forge 275 and above\
* Labelled Turtles now keep their fuel when broken\
\
New Features in ComputerCraft 1.42:\
\
* Ported to Minecraft 1.3.2\
* Added Printers\
* Floppy Disks can be dyed different colours\
* Wireless Crafty Turtles can now be crafted\
* New textures\
* New forge config file\
* Bug fixes\
\
New Features in ComputerCraft 1.4:\
\
* Ported to Forge Mod Loader. ComputerCraft can now be ran directly from the .zip without extraction\
* Added Farming Turtles\
* Added Felling Turtles\
* Added Digging Turtles\
* Added Melee Turtles\
* Added Crafty Turtles\
* Added 14 new Turtle Combinations accessible by combining the turtle upgrades above\
* Labelled computers and turtles can now be crafted into turtles or other turtle types without losing their ID, label and data\
* Added a \"Turtle Upgrade API\" for mod developers to create their own tools and peripherals for turtles\
* Turtles can now attack entities with turtle.attack(), and collect their dropped items\
* Turtles can now use turtle.place() with any item the player can, and can interact with entities\
* Turtles can now craft items with turtle.craft()\
* Turtles can now place items into inventories with turtle.drop()\
* Changed the behaviour of turtle.place() and turtle.drop() to only consider the currently selected slot\
* Turtles can now pick up items from the ground, or from inventories, with turtle.suck()\
* Turtles can now compare items in their inventories\
* Turtles can place signs with text on them with turtle.place( [signText] )\
* Turtles now optionally require fuel items to move, and can refuel themselves\
* The size of the the turtle inventory has been increased to 16\
* The size of the turtle screen has been increased\
* New turtle functions: turtle.compareTo( [slotNum] ), turtle.craft(), turtle.attack(), turtle.attackUp(), turtle.attackDown(), turtle.dropUp(), turtle.dropDown(), turtle.getFuelLevel(), turtle.refuel()\
* New disk function: disk.getID()\
* New turtle programs: craft, refuel\
* \"excavate\" program now much smarter: Will return items to a chest when full, attack mobs, and refuel itself automatically\
* New API: keys\
* Added optional Floppy Disk and Hard Drive space limits for computers and turtles\
* New fs function: fs.getFreeSpace( path ), also fs.getDrive() works again\
* The send and receive range of wireless modems now increases with altitude, allowing long range networking from high-altitude computers (great for GPS networks)\
* http.request() now supports https:// URLs\
* Right clicking a Disk Drive with a Floppy Disk or a Record when sneaking will insert the item into the Disk Drive automatically\
* The default size of the computer screen has been increased\
* Several stability and security fixes. LuaJ can now no longer leave dangling threads when a computer is unloaded, turtles can no longer be destroyed by tree leaves or walking off the edge of the loaded map. Computers no longer crash when used with RedPower frames.\
\
New Features in ComputerCraft 1.31:\
\
* Ported to Minecraft 1.2.3\
* Added Monitors (thanks to Cloudy)\
* Updated LuaJ to a newer, less memory hungry version\
* rednet_message event now has a third parameter, \"distance\", to support position triangulation.\
* New programs: gps, monitor, pastebin.\
* Added a secret program. Use with large monitors!\
* New apis: gps, vector\
* New turtle functions: turtle.compare(), turtle.compareUp(), turtle.compareDown(), turtle.drop( quantity )\
* New http functions: http.post().\
* New term functions: term.redirect(), term.restore()\
* New textutils functions: textutils.urlEncode()\
* New rednet functions: rednet.isOpen()\
* New config options: modem_range, modem_rangeDuringStorm\
* Bug fixes, program tweaks, and help updates\
\
New Features in ComputerCraft 1.3:\
\
* Ported to Minecraft Forge\
* Added Turtles\
* Added Wireless Modems\
* Added Mining Turtles\
* Added Wireless Turtles\
* Added Wireless Mining Turtles\
* Computers and Disk Drives no longer get destroyed by water.\
* Computers and Turtles can now be labelled with the label program, and labelled devices keep their state when destroyed.\
* Computers/Turtles can connect to adjacent devices, and turn them on and off\
* User programs now give line numbers in their error messages\
* New APIs: turtle, peripheral\
* New programs for turtles: tunnel, excavate, go, turn, dance\
* New os functions: os.getComputerLabel(), os.setComputerLabel()\
* Added \"filter\" parameter to os.pullEvent()\
* New shell function: shell.getCurrentProgram()\
* New textutils functions: textutils.serialize(), textutils.unserialize(), textutils.tabulate(), textutils.pagedTabulate(), textutils.slowWrite()\
* New io file function: file:lines()\
* New fs function: fs.getSize()\
* Disk Drives can now play records from other mods\
* Bug fixes, program tweaks, and help updates\
\
New Features in ComputerCraft 1.2:\
\
* Added Disk Drives and Floppy Disks\
* Added Ctrl+T shortcut to terminate the current program (hold)\
* Added Ctrl+S shortcut to shutdown the computer (hold)\
* Added Ctrl+R shortcut to reboot the computer (hold)\
* New Programs: alias, apis, copy, delete, dj, drive, eject, id, label, list, move, reboot, redset, rename, time, worm.\
* New APIs: bit, colours, disk, help, rednet, parallel, textutils.\
* New color functions: colors.combine(), colors.subtract(), colors.test()\
* New fs functions: fs.getName(), new modes for fs.open()\
* New os functions: os.loadAPI(), os.unloadAPI(),\
os.clock(), os.time(), os.setAlarm(),\
os.reboot(), os.queueEvent()\
* New redstone function: redstone.getSides()\
* New shell functions: shell.setPath(), shell.programs(), shell.resolveProgram(), shell.setAlias()\
* Lots of updates to the help pages\
* Bug fixes\
\
New Features in ComputerCraft 1.1:\
\
* Added Multiplayer support throughout.\
* Added connectivity with RedPower bundled cables\
* Added HTTP api, enabled via the mod config, to allow computers to access the real world internet\
* Added command history to the shell.\
* Programs which spin in an infinite loop without yielding will no longer freeze minecraft\
* Help updates and bug fixes\
\
New Features in ComputerCraft 1.0:\
\
* First Release!",
      "dance is a program for Turtles. Turtles love to get funky.",
      "Functions in the commands API:\
commands.exec( command )\
commands.execAsync( command )\
commands.list()\
commands.getBlockPosition()\
commands.getBlockInfo( x, y, z )\
commands.getBlockInfos( minx, miny, minz, maxx, maxy, maxz )\
\
The commands API can also be used to invoke commands directly, like so:\
commands.say( \"Hello World\" )\
commands.give( \"dan200\", \"minecraft:diamond\", 64 )\
This works with any command. Use \"commands.async\" instead of \"commands\" to execute asynchronously.\
\
The commands API is only available on Command Computers.\
Visit http://minecraft.gamepedia.com/Commands for documentation on all commands.",
      "edit is a text editor for creating or modifying programs or text files. After creating a program with edit, type its filename in the shell to run it. You can open any of the builtin programs with edit to learn how to program.\
\
ex:\
\"edit hello\" opens a file called \"hello\" for editing.",
      "exit will exit the current shell.",
      "cp copies a file or directory from one location to another.\
\
ex:\
\"cp rom myrom\" copies \"rom\" to \"myrom\".\
\"cp rom mystuff/rom\" copies \"rom\" to \"mystuff/rom\".\
\"cp disk/* disk2\" copies the contents of one disk to another",
      "label gets or sets the label of the Computer, or of Floppy Disks in attached disk drives.\
\
ex:\
\"label get\" prints the label of the computer.\
\"label get left\" prints the label of the disk in the left drive.\
\"label set \"My Computer\"\" set the label of the computer to \"My Computer\".\
\"label set left \"My Programs\"\" - sets the label of the disk in the left drive to \"My Programs\".\
\"label clear\" clears the label of the computer.\
\"label clear left\" clears the label of the disk in the left drive.",
      "To learn the lua programming language, visit http://lua-users.org/wiki/TutorialDirectory.\
\
To experiment with lua in CraftOS, run the \"lua\" program and start typing code.\
To create programs, use \"edit\" to create files, then type their names in the shell to run them. If you name a program \"startup\" and place it in the root or on a disk drive, it will run automatically when the computer starts.\
\
To terminate a program stuck in a loop, hold Ctrl+T for 1 second.\
To quickly shutdown a computer, hold Ctrl+S for 1 second.\
To quickly reboot a computer, hold Ctrl+R for 1 second.\
\
To learn about the programming APIs availiable, type \"apis\" or \"help apis\".\
If you get stuck, visit the forums at http://www.computercraft.info/ for advice and tutorials.",
      "Workbenches are peripheral devices found on Crafty Turtles running CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a workbench is attached to a turtle, peripheral.getType() will return \"workbench\".\
\
Methods exposed by Workbenches:\
craft( channel )",
      "drive tells you which disk drive the current or specified directory is located in.\
\
ex:\
\"drive\" tell you the disk drive of the current directory.\
\"drive foo\" tells you the disk drive of the subdirectory \"foo\"",
      "You've played it in the arcades, now experience the high-octane thrills of the hit game \"WORM!\" on your home computer! Only on CraftOS!",
      "ComputerCraft was created by Daniel \"dan200\" Ratcliffe, with additional code by Aaron \"Cloudy\" Mills.\
Thanks to nitrogenfingers, GopherATL and RamiLego for program contributions.\
Thanks to Mojang, the Forge team, and the MCP team.\
Uses LuaJ from http://luaj.sourceforge.net/\
\
The ComputerCraft 1.76 update was sponsored by MinecraftU and Deep Space.\
Visit http://www.minecraftu.org and http://www.deepspace.me/space-cadets to find out more.\
\
Join the ComputerCraft community online at http://www.computercraft.info\
Follow @DanTwoHundred on Twitter!",
      "shutdown will turn off the computer.",
      "Functions in the disk API. These functions are for interacting with disk drives:\
disk.isPresent( drive )\
disk.setLabel( drive, label )\
disk.getLabel( drive )\
disk.hasData( drive )\
disk.getMountPath( drive )\
disk.hasAudio( drive )\
disk.getAudioTitle( drive )\
disk.playAudio( drive )\
disk.stopAudio( )\
disk.eject( drive )\
disk.getID( drive )\
\
Events fired by the disk API:\
\"disk\" when a disk or other item is inserted into a disk drive. Argument is the name of the drive\
\"disk_eject\" when a disk is removed from a disk drive. Argument is the name of the drive\
Type \"help events\" to learn about the event system.",
      "mkdir creates a directory in the current location.\
\
ex:\
\"mkdir foo\" creates a directory named \"foo\".\
\"mkdir ../foo\" creates a directory named \"foo\" in the directory above the current directory.",
      "Functions in the help API:\
help.setPath( path )\
help.lookup( topic )\
help.topics()\
help.completeTopic( topic )",
      "pastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.\
The HTTP API must be enabled in ComputerCraft.cfg to use this program.\
\
ex:\
\"pastebin put foo\" will upload the file \"foo\" to pastebin.com, and print the URL.\
\"pastebin get xq5gc7LB foo\" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as \"foo\".\
\"pastebin run CxaWmPrX\" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.",
      "gps can be used to host a GPS server, or to determine a position using trilateration.\
Type \"help gpsapi\" for help using GPS functions in lua programs.\
\
ex:\
\"gps locate\" will connect to nearby GPS servers, and try to determine the position of the computer or turtle.\
\"gps host\" will try to determine the position, and host a GPS server if successful.\
\"gps host 10 20 30\" will host a GPS server, using the manually entered position 10,20,30. \
\
Take care when manually entering host positions. If the positions entered into multiple GPS hosts\
are not consistent, the results of locate calls will be incorrect.",
      "eject ejects the contents of an attached disk drive.\
\
ex:\
\"eject left\" ejects the contents of the disk drive to the left of the computer.",
      "hello prints the text \"Hello World!\" to the screen.",
      "The \"peripherals\" program will list all of the peripheral devices accessible from this computer.\
Peripherals are external devices which CraftOS Computers and Turtles can interact with using the peripheral API.\
Type \"help peripheral\" to learn about using the peripheral API.\
Type \"help drives\" to learn about using Disk Drives.\
Type \"help modems\" to learn about using Modems.\
Type \"help monitors\" to learn about using Monitors.\
Type \"help printers\" to learn about using Printers.",
      "coroutine is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "Functions in the bit manipulation API (NOTE: This API will be removed in a future version. Use bit32 instead):\
bit.bnot(n)          -- bitwise not (~n)\
bit.band(m, n)       -- bitwise and (m & n)\
bit.bor(m, n)        -- bitwise or (m | n)\
bit.bxor(m, n)       -- bitwise xor (m ^ n)\
bit.brshift(n, bits) -- right shift (n >> bits)\
bit.blshift(n, bits) -- left shift (n << bits)",
      "monitor will connect to an attached Monitor peripheral, and run a program on its display.\
Type \"help monitors\" for help using monitors as peripherals in lua programs.\
\
ex:\
\"monitor left hello\" will run the \"hello\" program on the monitor to the left of the computer.\
\"monitor top edit foo\" will run the edit program on the top monitor, editing the file \"foo\".",
      "Mostly harmless.",
      "Functions in the Shell API:\
shell.exit()\
shell.dir()\
shell.setDir( path )\
shell.path()\
shell.setPath( path )\
shell.resolve( localpath )\
shell.resolveProgram( name )\
shell.aliases()\
shell.setAlias( alias, command )\
shell.clearAlias( alias )\
shell.programs()\
shell.run( program, arguments )\
shell.getRunningProgram()\
shell.complete( line )\
shell.completeProgram( program )\
shell.setCompletionFunction( program, fnComplete )\
shell.openTab( program, arguments ) (Advanced Computer required)\
shell.switchTab( n ) (Advanced Computer required)",
      "id prints the unique identifier of this computer, or a Disk in an attached Disk Drive.\
\
ex:\
\"id\" will print this Computers ID and label\
\"id left\" will print the ID and label of the disk in the Disk Drive on the left",
      "apis lists the currently loaded APIs available to programs in CraftOS.\
\
Type \"help <api>\" to see help for a specific api.\
Call os.loadAPI( path ) to load extra apis.",
      "string is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "equip is a program for Turtles. equip will equip an item from the Turtle's inventory for use as a tool of peripheral.\
\
ex:\
\"equip 5 left\" will equip the item from slot 5 of the turtle onto the left side of the turtle",
      "paint is a program for creating images on Advanced Computers. Select colors from the color pallette on the right, and click on the canvas to draw. Press Ctrl to access the menu and save your pictures.\
\
ex:\
\"edit mario\" opens an image called \"mario\" for editing.",
      "Functions in the window API:\
window.create( parent, x, y, width, height, visible )\
\
Windows created with the window API have the following methods:\
write( text )\
blit( text, textColor, backgroundColor )\
clear()\
clearLine()\
getCursorPos()\
setCursorPos( x, y )\
setCursorBlink( blink )\
isColor()\
setTextColor( color )\
setBackgroundColor( color )\
getTextColor()\
getBackgroundColor()\
getSize()\
scroll( n )\
setVisible( bVisible )\
redraw()\
restoreCursor()\
getPosition()\
reposition( x, y, width, height )",
      "rename renames a file or directory.\
\
ex:\
\"rename foo bar\" renames the file \"foo\" to \"bar\".",
      "Functions in the Paint Utilities API:\
paintutils.drawPixel( x, y, colour )\
paintutils.drawLine( startX, startY, endX, endY, colour )\
paintutils.drawBox( startX, startY, endX, endY, colour )\
paintutils.drawFilledBox( startX, startY, endX, endY, colour )\
paintutils.loadImage( path )\
paintutils.drawImage( image, x, y )",
      "clear clears the screen.",
      "shell is the toplevel program which interprets commands and runs program.\
Type \"help shellapi\" for information about the shell lua api.",
      "turtle is an api availiable on Turtles, which controls their movement.\
Functions in the Turtle API:\
turtle.forward()\
turtle.back()\
turtle.up()\
turtle.down()\
turtle.turnLeft()\
turtle.turnRight()\
turtle.select( slotNum )\
turtle.getSelectedSlot()\
turtle.getItemCount( [slotNum] )\
turtle.getItemSpace( [slotNum] )\
turtle.getItemDetail( [slotNum] )\
turtle.equipLeft()\
turtle.equipRight()\
turtle.dig( [toolSide] )\
turtle.digUp( [toolSide] )\
turtle.digDown( [toolSide] )\
turtle.place()\
turtle.placeUp()\
turtle.placeDown()\
turtle.attack( [toolSide] )\
turtle.attackUp( [toolSide] )\
turtle.attackDown( [toolSide] )\
turtle.detect()\
turtle.detectUp()\
turtle.detectDown()\
turtle.compare()\
turtle.compareUp()\
turtle.compareDown()\
turtle.inspect()\
turtle.inspectUp()\
turtle.inspectDown()\
turtle.inspectSlot( [slotNum] )\
turtle.compareTo( slotNum )\
turtle.transferTo( slotNum, [quantity] )\
turtle.drop( [quantity] )\
turtle.dropUp( [quantity] )\
turtle.dropDown( [quantity] )\
turtle.suck( [quantity] )\
turtle.suckUp( [quantity] )\
turtle.suckDown( [quantity] )\
turtle.getFuelLevel()\
turtle.getFuelLimit()\
turtle.refuel( [quantity] )\
turtle.craft( [quantity] ) (requires Crafty Turtle)\
\
Events fired by the Turtle API:\
\"turtle_inventory\" when any of the items in the inventory are changed. Use comparison operations to inspect the changes.",
      "Functions in the colours api\
(used for redstone.setBundledOutput):\
colours.combine( colour1, colour2, colour3, ...)\
colours.subtract( colours, colour1, colour2, ...)\
colours.test( colours, colour )\
\
Colour constants in the colours api, in ascending bit order:\
colours.white, colours.orange, colours.magenta, colours.lightBlue, colours.yellow, colours.lime, colours.pink, colours.grey, colours.lightGrey, colours.cyan, colours.purple, colours.blue, colours.brown, colours.green, colours.red, colours.black.",
      "On a Command Computer, \"exec\" will execute a command as if entered on a command block. Use \"commands\" to list all the available commands.\
\
ex:\
\"exec say Hello World\"\
\"exec setblock ~0 ~1 ~0 minecraft:dirt\"\
\
Type \"help commandsapi\" for help using commands in lua programs.",
      "table is a standard Lua5.1 API.\
Refer to http://www.lua.org/manual/5.1/ for more information.",
      "Welcome to CraftOS!\
Type \"programs\" to see the programs you can run.\
Type \"help <program>\" to see help for a specific program.\
Type \"help programming\" to learn about programming.\
Type \"help whatsnew\" to find out about new features.\
Type \"help credits\" to learn who made all this.\
Type \"help index\" to see all help topics.",
      "The Monitor is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Monitor is connected, peripheral.getType() will return \"monitor\". A wrapped monitor can be used with term.redirect() to send all terminal output to the monitor.\
\
Methods exposed by the Monitor:\
write( text )\
blit( text, textColor, backgroundColor )\
clear()\
clearLine()\
getCursorPos()\
setCursorPos( x, y )\
setCursorBlink( blink )\
isColor()\
setTextColor( color )\
setBackgroundColor( color )\
getTextColor()\
getBackgroundColor()\
getSize()\
scroll( n )\
\
Events fired by the Monitor:\
\"monitor_touch\" when an Advanced Monitor is touched by the player. Arguments are name, x, y\
\"monitor_resize\" when the size of a Monitor changes. Argument is the name of the monitor.",
      "fg is a program for Advanced Computers which opens a new tab in the foreground.\
\
ex:\
\"fg\" will open a foreground tab running the shell\
\"fg worm\" will open a foreground tab running the \"worm\" program",
      "--[[\
Alright then, don't ignore me. This file is to ensure the existance of the \"autorun\" folder, files placed in this folder\
using resource packs will always run when computers startup.\
]]",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: cd <path>\" )\
\009return\
end\
\
local sNewDir = shell.resolve( tArgs[1] )\
if fs.isDir( sNewDir ) then\
\009shell.setDir( sNewDir )\
else\
  \009print( \"Not a directory\" )\
  \009return\
end",
      "local tArgs = { ... }\
if #tArgs > 0 then\
\009sTopic = tArgs[1]\
else\
\009sTopic = \"intro\"\
end\
\
if sTopic == \"index\" then\
\009print( \"Help topics availiable:\" )\
\009local tTopics = help.topics()\
\009textutils.pagedTabulate( tTopics )\
\009return\
end\
\009\
local w,h = term.getSize()\
local sFile = help.lookup( sTopic )\
local file = ((sFile ~= nil) and io.open( sFile )) or nil\
local nLinesPrinted = 0\
if file then\
\009local sLine = file:read()\
\009local nLines = 0\
\009while sLine do\
\009\009nLines = nLines + textutils.pagedPrint( sLine, (h-3) - nLines )\
    \009sLine = file:read()\
    end\
\009file:close()\
else\
\009print( \"No help available\" )\
end",
      "local tArgs = { ... }\
\
local function printUsage()\
\009print( \"Usages:\")\
\009print( \"dj play\" )\
\009print( \"dj play <drive>\" )\
\009print( \"dj stop\" )\
end\
\
if #tArgs > 2 then\
\009printUsage()\
\009return\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"stop\" then\
\009-- Stop audio\
\009disk.stopAudio()\
\
elseif sCommand == \"play\" or sCommand == nil then\
\009-- Play audio\
\009local sName = tArgs[2]\
\009if sName == nil then\
\009\009-- No disc specified, pick one at random\
\009\009local tNames = {}\
\009\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009\009if disk.isPresent( sName ) and disk.hasAudio( sName ) then\
\009\009\009\009table.insert( tNames, sName )\
\009\009\009end\
\009\009end\
\009\009if #tNames == 0 then\
\009\009\009print( \"No Music Discs in attached disk drives\" )\
\009\009\009return\
\009\009end\
\009\009sName = tNames[ math.random(1,#tNames) ]\
\009end\
\
\009-- Play the disc\
\009if disk.isPresent( sName ) and disk.hasAudio( sName ) then\
\009\009print( \"Playing \"..disk.getAudioTitle( sName ) )\
\009\009disk.playAudio( sName )\
\009else\
\009\009print( \"No Music Disc in disk drive: \"..sName )\
\009\009return\
\009end\
\009\
else\
\009printUsage()\
\009\
end",
      "\
local tBiomes = {\
\009\"in a forest\",\
\009\"in a pine forest\",\
\009\"knee deep in a swamp\",\
\009\"in a mountain range\",\
\009\"in a desert\",\
\009\"in a grassy plain\",\
\009\"in frozen tundra\",\
}\
\
local function hasTrees( _nBiome )\
\009return _nBiome <= 3\
end\
\
local function hasStone( _nBiome )\
\009return _nBiome == 4\
end\
\
local function hasRivers( _nBiome )\
\009return _nBiome ~= 3 and _nBiome ~= 5\
end\
\
local items = {\
\009[\"no tea\"] = {\
\009\009droppable = false,\
\009\009desc = \"Pull yourself together man.\",\
\009},\
\009[\"a pig\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009drops = { \"some pork\" },\
\009\009aliases = { \"pig\" },\
\009\009desc = \"The pig has a square nose.\",\
\009},\
\009[\"a cow\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009aliases = { \"cow\" },\
\009\009desc = \"The cow stares at you blankly.\",\
\009},\
\009[\"a sheep\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009hitDrops = { \"some wool\" },\
\009\009aliases = { \"sheep\" },\
\009\009desc = \"The sheep is fluffy.\",\
\009},\
\009[\"a chicken\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009drops = { \"some chicken\" },\
\009\009aliases = { \"chicken\" },\
\009\009desc = \"The chicken looks delicious.\",\
\009},\
\009[\"a creeper\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"creeper\" },\
\009\009desc = \"The creeper needs a hug.\",\
\009},\
\009[\"a skeleton\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"skeleton\" },\
\009\009nocturnal = true,\
\009\009desc = \"The head bone's connected to the neck bone, the neck bone's connected to the chest bone, the chest bone's connected to the arm bone, the arm bone's connected to the bow, and the bow is pointed at you.\",\
\009},\
\009[\"a zombie\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"zombie\" },\
\009\009nocturnal = true,\
\009\009desc = \"All he wants to do is eat your brains.\",\
\009},\
\009[\"a spider\"] = {\
\009\009heavy = true,\
\009\009creature = true,\
\009\009monster = true,\
\009\009aliases = { \"spider\" },\
\009\009desc = \"Dozens of eyes stare back at you.\",\
\009},\
\009[\"a cave entrance\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"cave entance\", \"cave\", \"entrance\" },\
\009\009desc = \"The entrance to the cave is dark, but it looks like you can climb down.\",\
\009},\
\009[\"an exit to the surface\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"exit to the surface\", \"exit\", \"opening\" },\
\009\009desc = \"You can just see the sky through the opening.\",\
\009},\
\009[\"a river\"] = {\
\009\009heavy = true,\
\009\009aliases = { \"river\" },\
\009\009desc = \"The river flows majestically towards the horizon. It doesn't do anything else.\",\
\009},\
\009[\"some wood\"] = {\
\009\009aliases = { \"wood\" },\
\009\009material = true,\
\009\009desc = \"You could easilly craft this wood into planks.\",\
\009},\
\009[\"some planks\"] = {\
\009\009aliases = { \"planks\", \"wooden planks\", \"wood planks\" },\
\009\009desc = \"You could easilly craft these planks into sticks.\",\
\009},\
\009[\"some sticks\"] = {\
\009\009aliases = { \"sticks\", \"wooden sticks\", \"wood sticks\" },\
\009\009desc = \"A perfect handle for torches or a pickaxe.\",\
\009},\
\009[\"a crafting table\"] = {\
\009\009aliases = { \"crafting table\", \"craft table\", \"work bench\", \"workbench\", \"crafting bench\", \"table\", },\
\009\009desc = \"It's a crafting table. I shouldn't tell you this, but these don't actually do anything in this game, you can craft tools whenever you like.\",\
\009},\
\009[\"a furnace\"] = {\
\009\009aliases = { \"furnace\" },\
\009\009desc = \"It's a furnace. Between you and me, these don't actually do anything in this game.\",\
\009},\
\009[\"a wooden pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"wooden pick\", \"wooden pickaxe\", \"wood pick\", \"wood pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks good for breaking stone and coal.\",\
\009},\
\009[\"a stone pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"stone pick\", \"stone pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks good for breaking iron.\",\
\009},\
\009[\"an iron pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"iron pick\", \"iron pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"pick\",\
\009\009desc = \"The pickaxe looks strong enough to break diamond.\",\
\009},\
\009[\"a diamond pickaxe\"] = {\
\009\009aliases = { \"pickaxe\", \"pick\", \"diamond pick\", \"diamond pickaxe\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"pick\",\
\009\009desc = \"Best. Pickaxe. Ever.\",\
\009},\
\009[\"a wooden sword\"] = {\
\009\009aliases = { \"sword\", \"wooden sword\", \"wood sword\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"sword\",\
\009\009desc = \"Flimsy, but better than nothing.\",\
\009},\
\009[\"a stone sword\"] = {\
\009\009aliases = { \"sword\", \"stone sword\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"sword\",\
\009\009desc = \"A pretty good sword.\",\
\009},\
\009[\"an iron sword\"] = {\
\009\009aliases = { \"sword\", \"iron sword\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"sword\",\
\009\009desc = \"This sword can slay any enemy.\",\
\009},\
\009[\"a diamond sword\"] = {\
\009\009aliases = { \"sword\", \"diamond sword\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"sword\",\
\009\009desc = \"Best. Sword. Ever.\",\
\009},\
\009[\"a wooden shovel\"] = {\
\009\009aliases = { \"shovel\", \"wooden shovel\", \"wood shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"a stone shovel\"] = {\
\009\009aliases = { \"shovel\", \"stone shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"an iron shovel\"] = {\
\009\009aliases = { \"shovel\", \"iron shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"a diamond shovel\"] = {\
\009\009aliases = { \"shovel\", \"diamond shovel\" },\
\009\009tool = true,\
\009\009toolLevel = 4,\
\009\009toolType = \"shovel\",\
\009\009desc = \"Good for digging holes.\",\
\009},\
\009[\"some coal\"] = {\
\009\009aliases = { \"coal\" },\
\009\009ore = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"That coal looks useful for building torches, if only you had a pickaxe to mine it.\",\
\009},\
\009[\"some dirt\"] = {\
\009\009aliases = { \"dirt\" },\
\009\009material = true,\
\009\009desc = \"Why not build a mud hut?\",\
\009},\
\009[\"some stone\"] = {\
\009\009aliases = { \"stone\", \"cobblestone\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009infinite = true,\
\009\009toolLevel = 1,\
\009\009toolType = \"pick\",\
\009\009desc = \"Stone is useful for building things, and making stone pickaxes.\",\
\009},\
\009[\"some iron\"] = {\
\009\009aliases = { \"iron\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009toolLevel = 2,\
\009\009toolType = \"pick\",\
\009\009desc = \"That iron looks mighty strong, you'll need a stone pickaxe to mine it.\",\
\009},\
\009[\"some diamond\"] = {\
\009\009aliases = { \"diamond\", \"diamonds\" },\
\009\009material = true,\
\009\009ore = true,\
\009\009toolLevel = 3,\
\009\009toolType = \"pick\",\
\009\009desc = \"Sparkly, rare, and impossible to mine without an iron pickaxe.\",\
\009},\
\009[\"some torches\"] = {\
\009\009aliases = { \"torches\", \"torch\" },\
\009\009desc = \"These won't run out for a while.\",\
\009},\
\009[\"a torch\"] = {\
\009\009aliases = { \"torch\" },\
\009\009desc = \"Fire, fire, burn so bright, won't you light my cave tonight?\",\
\009},\
\009[\"some wool\"] = {\
\009\009aliases = { \"wool\" },\
\009\009material = true,\
\009\009desc = \"Soft and good for building.\",\
\009},\
\009[\"some pork\"] = {\
\009\009aliases = { \"pork\", \"porkchops\" },\
\009\009food = true,\
\009\009desc = \"Delicious and nutricious.\",\
\009},\
\009[\"some chicken\"] = {\
\009\009aliases = { \"chicken\" },\
\009\009food = true,\
\009\009desc = \"Finger licking good.\",\
\009},\
}\
\
local tAnimals = {\
\009\"a pig\", \"a cow\", \"a sheep\", \"a chicken\",\
}\
\
local tMonsters = {\
\009\"a creeper\", \"a skeleton\", \"a zombie\", \"a spider\"\
}\
\
local tRecipes = {\
\009[\"some planks\"] = { \"some wood\" },\
\009[\"some sticks\"] = { \"some planks\" },\
\009[\"some sticks\"] = { \"some planks\" },\
\009[\"a crafting table\"] = { \"some planks\" },\
\009[\"a furnace\"] = { \"some stone\" },\
\009[\"some torches\"] = { \"some sticks\", \"some coal\" },\
\009\
\009[\"a wooden pickaxe\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone pickaxe\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron pickaxe\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond pickaxe\"] = { \"some diamond\", \"some sticks\" },\
\
\009[\"a wooden sword\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone sword\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron sword\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond sword\"] = { \"some diamond\", \"some sticks\" },\
\
\009[\"a wooden shovel\"] = { \"some planks\", \"some sticks\" },\
\009[\"a stone shovel\"] = { \"some stone\", \"some sticks\" },\
\009[\"an iron shovel\"] = { \"some iron\", \"some sticks\" },\
\009[\"a diamond shovel\"] = { \"some diamond\", \"some sticks\" },\
}\
\
local tGoWest = {\
\009\"(life is peaceful there)\",\
\009\"(lots of open air)\",\
\009\"(to begin life anew)\",\
\009\"(this is what we'll do)\",\
\009\"(sun in winter time)\",\
\009\"(we will do just fine)\",\
\009\"(where the skies are blue)\",\
\009\"(this and more we'll do)\",\
}\
local nGoWest = 0\
\
local bRunning = true\
local tMap = { { {}, }, }\
local x,y,z = 0,0,0\
local inventory = {\
\009[\"no tea\"] = items[\"no tea\"],\
}\
\
local nTurn = 0\
local nTimeInRoom = 0\
local bInjured = false\
\
local tDayCycle = {\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"It is daytime.\",\
\009\"The sun is setting.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"It is night.\",\
\009\"The sun is rising.\",\
}\
\
local function getTimeOfDay()\
\009return math.fmod( math.floor(nTurn/3), #tDayCycle ) + 1\
end\
\
local function isSunny()\
\009return (getTimeOfDay() < 10)\
end\
\
local function getRoom( x, y, z, dontCreate )\
\009tMap[x] = tMap[x] or {}\
\009tMap[x][y] = tMap[x][y] or {}\
\009if not tMap[x][y][z] and dontCreate ~= true then\
 \009\009local room = {\
 \009\009\009items = {},\
 \009\009\009exits = {},\
 \009\009\009nMonsters = 0,\
 \009\009}\
\009\009tMap[x][y][z] = room\
\009\009\
\009\009if y == 0 then\
\009\009\009-- Room is above ground\
\
\009\009\009-- Pick biome\
\009\009\009room.nBiome = math.random( 1, #tBiomes )\
\009\009\009room.trees = hasTrees( room.nBiome )\
\009\009\
\009\009\009-- Add animals\
\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009for n = 1,math.random(1,2) do\
\009\009\009\009\009local sAnimal = tAnimals[ math.random( 1, #tAnimals ) ]\
\009\009\009\009\009room.items[ sAnimal ] = items[ sAnimal ]\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009-- Add surface ore\
\009\009\009if math.random(1,5) == 1 or hasStone( room.nBiome ) then\
\009\009\009\009room.items[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.items[ \"some coal\" ] = items[ \"some coal\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 and hasRivers( room.nBiome ) then\
\009\009\009\009room.items[ \"a river\" ] = items[ \"a river\" ]\
\009\009\009end\
\
\009\009\009-- Add exits\
\009\009\009room.exits = {\
\009\009\009\009[\"north\"] = true,\
\009\009\009\009[\"south\"] = true,\
\009\009\009\009[\"east\"] = true,\
\009\009\009\009[\"west\"] = true,\
\009\009\009}\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.exits[\"down\"] = true\
\009\009\009\009room.items[\"a cave entrance\"] = items[\"a cave entrance\"]\
\009\009\009end\
\009\009\009\009\009\009\
\009\009else\
\009\009\009-- Room is underground\
\009\009\009-- Add exits\
\009\009\009local function tryExit( sDir, sOpp, x, y, z )\
\009\009\009\009local adj = getRoom( x, y, z, true )\
\009\009\009\009if adj then\
\009\009\009\009\009if adj.exits[sOpp] then\
\009\009\009\009\009\009room.exits[sDir] = true\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009\009\009room.exits[sDir] = true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if y == -1 then\
\009\009\009\009local above = getRoom( x, y + 1, z )\
\009\009\009\009if above.exits[\"down\"] then\
\009\009\009\009\009room.exits[\"up\"] = true\
\009\009\009\009\009room.items[\"an exit to the surface\"] = items[\"an exit to the surface\"]\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009tryExit( \"up\", \"down\", x, y + 1, z )\
\009\009\009end\
\009\009\009\
\009\009\009if y > -3 then\
\009\009\009\009tryExit( \"down\", \"up\", x, y - 1, z )\
\009\009\009end\
\009\009\009\
\009\009\009tryExit( \"east\", \"west\", x - 1, y, z )\
\009\009\009tryExit( \"west\", \"east\", x + 1, y, z )\
\009\009\009tryExit( \"north\", \"south\", x, y, z + 1 )\
\009\009\009tryExit( \"south\", \"north\", x, y, z - 1 )\009\
\009\009\009\
\009\009\009-- Add ores\
\009\009\009room.items[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009if math.random(1,3) == 1 then\
\009\009\009\009room.items[ \"some coal\" ] = items[ \"some coal\" ]\
\009\009\009end\
\009\009\009if math.random(1,8) == 1 then\
\009\009\009\009room.items[ \"some iron\" ] = items[ \"some iron\" ]\
\009\009\009end\
\009\009\009if y == -3 and math.random(1,15) == 1 then\
\009\009\009\009room.items[ \"some diamond\" ] = items[ \"some diamond\" ]\
\009\009\009end\
\009\009\009\
\009\009\009-- Turn out the lights\
\009\009\009room.dark = true\
\009\009end\
\009end\
\009return tMap[x][y][z]\
end\
\
local function itemize( t )\
\009local item = next( t )\
\009if item == nil then\
\009\009return \"nothing\"\
\009end\
\009\
\009local text = \"\"\
\009while item do\
\009\009text = text .. item\
\009\009\
\009\009local nextItem = next( t, item )\
\009\009if nextItem ~= nil then\
\009\009\009local nextNextItem = next( t, nextItem )\
\009\009\009if nextNextItem == nil then\
\009\009\009\009text = text .. \" and \"\
\009\009\009else\
\009\009\009\009text = text .. \", \"\
\009\009\009end\
\009\009end\
\009\009item = nextItem\
\009end\
\009return text\
end\
\
local function findItem( _tList, _sQuery )\
\009for sItem, tItem in pairs( _tList ) do\
\009\009if sItem == _sQuery then\
\009\009\009return sItem\
\009\009end\
\009\009if tItem.aliases ~= nil then\
\009\009\009for n, sAlias in pairs( tItem.aliases ) do\
\009\009\009\009if sAlias == _sQuery then\
\009\009\009\009\009return sItem\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
local tMatches = {\
\009[\"wait\"] = {\
\009\009\"wait\",\
\009},\
\009[\"look\"] = {\
\009\009\"look at the ([%a ]+)\",\
\009\009\"look at ([%a ]+)\",\
\009\009\"look\",\
\009\009\"inspect ([%a ]+)\",\
\009\009\"inspect the ([%a ]+)\",\
\009\009\"inspect\",\
\009},\
\009[\"inventory\"] = {\
\009\009\"check self\",\
\009\009\"check inventory\",\
\009\009\"inventory\",\
\009\009\"i\",\
\009},\
\009[\"go\"] = {\
\009\009\"go (%a+)\",\
\009\009\"travel (%a+)\",\
\009\009\"walk (%a+)\",\
\009\009\"run (%a+)\",\
\009\009\"go\",\
\009},\
\009[\"dig\"] = {\
\009\009\"dig (%a+) using ([%a ]+)\",\
\009\009\"dig (%a+) with ([%a ]+)\",\
\009\009\"dig (%a+)\",\
\009\009\"dig\",\
\009},\
\009[\"take\"] = {\
\009\009\"pick up the ([%a ]+)\",\
\009\009\"pick up ([%a ]+)\",\
\009\009\"pickup ([%a ]+)\",\
\009\009\"take the ([%a ]+)\",\
\009\009\"take ([%a ]+)\",\
\009\009\"take\",\
\009},\
\009[\"drop\"] = {\
\009\009\"put down the ([%a ]+)\",\
\009\009\"put down ([%a ]+)\",\
\009\009\"drop the ([%a ]+)\",\
\009\009\"drop ([%a ]+)\",\
\009\009\"drop\",\
\009},\
\009[\"place\"] = {\
\009\009\"place the ([%a ]+)\",\
\009\009\"place ([%a ]+)\",\
\009\009\"place\",\
\009},\
\009[\"cbreak\"] = {\
\009\009\"punch the ([%a ]+)\",\
\009\009\"punch ([%a ]+)\",\
\009\009\"punch\",\
\009\009\"break the ([%a ]+) with the ([%a ]+)\",\
\009\009\"break ([%a ]+) with ([%a ]+) \",\
\009\009\"break the ([%a ]+)\",\
\009\009\"break ([%a ]+)\",\
\009\009\"break\",\
\009},\
\009[\"mine\"] = {\
\009\009\"mine the ([%a ]+) with the ([%a ]+)\",\
\009\009\"mine ([%a ]+) with ([%a ]+)\",\
\009\009\"mine ([%a ]+)\",\
\009\009\"mine\",\
\009},\
\009[\"attack\"] = {\
\009\009\"attack the ([%a ]+) with the ([%a ]+)\",\
\009\009\"attack ([%a ]+) with ([%a ]+)\",\
\009\009\"attack ([%a ]+)\",\
\009\009\"attack\",\
\009\009\"kill the ([%a ]+) with the ([%a ]+)\",\
\009\009\"kill ([%a ]+) with ([%a ]+)\",\
\009\009\"kill ([%a ]+)\",\
\009\009\"kill\",\
\009\009\"hit the ([%a ]+) with the ([%a ]+)\",\
\009\009\"hit ([%a ]+) with ([%a ]+)\",\
\009\009\"hit ([%a ]+)\",\
\009\009\"hit\",\
\009},\
\009[\"craft\"] = {\
\009\009\"craft a ([%a ]+)\",\
\009\009\"craft some ([%a ]+)\",\
\009\009\"craft ([%a ]+)\",\
\009\009\"craft\",\
\009\009\"make a ([%a ]+)\",\
\009\009\"make some ([%a ]+)\",\
\009\009\"make ([%a ]+)\",\
\009\009\"make\",\
\009},\
\009[\"build\"] = {\
\009\009\"build ([%a ]+) out of ([%a ]+)\",\
\009\009\"build ([%a ]+) from ([%a ]+)\",\
\009\009\"build ([%a ]+)\",\
\009\009\"build\",\
\009},\
\009[\"eat\"] = {\
\009\009\"eat a ([%a ]+)\",\
\009\009\"eat the ([%a ]+)\",\
\009\009\"eat ([%a ]+)\",\
\009\009\"eat\",\
\009},\
\009[\"help\"] = {\
\009\009\"help me\",\
\009\009\"help\",\
\009},\
\009[\"exit\"] = {\
\009\009\"exit\",\
\009\009\"quit\",\
\009\009\"goodbye\",\
\009\009\"good bye\",\
\009\009\"bye\",\
\009\009\"farewell\",\
\009},\
}\
\
local commands = {}\
local function doCommand( text )\
\009if text == \"\" then\
\009\009commands[ \"noinput\" ]()\
\009\009return\
\009end\
\009\
\009for sCommand, t in pairs( tMatches ) do\
\009\009for n, sMatch in pairs( t ) do\
\009\009\009local tCaptures = { string.match( text, \"^\" .. sMatch .. \"$\" ) }\
\009\009\009if #tCaptures ~= 0 then\
\009\009\009\009local fnCommand = commands[ sCommand ]\
\009\009\009\009if #tCaptures == 1 and tCaptures[1] == sMatch then\
\009\009\009\009\009fnCommand()\
\009\009\009\009else\
\009\009\009\009\009fnCommand( table.unpack( tCaptures ) )\
\009\009\009\009end\
\009\009\009\009return\
\009\009\009end\
\009\009end\
\009end\
\009commands[ \"badinput\" ]()\
end\
\
function commands.wait()\
\009print( \"Time passes...\" )\
end\
\
function commands.look( _sTarget )\
\009local room = getRoom( x,y,z )\
\009if room.dark then\
\009\009print( \"It is pitch dark.\" )\
\009\009return\
\009end\
\
\009if _sTarget == nil then\
\009\009-- Look at the world\
\009\009if y == 0 then\
\009\009\009io.write( \"You are standing \" .. tBiomes[room.nBiome] .. \". \" )\
\009\009\009print( tDayCycle[ getTimeOfDay() ] )\
\009\009else\
\009\009\009io.write( \"You are underground. \" )\
\009\009\009if next( room.exits ) ~= nil then\
\009\009\009\009print( \"You can travel \"..itemize( room.exits )..\".\" )\
\009\009\009else\
\009\009\009\009print()\
\009\009\009end\
\009\009end\
\009\009if next( room.items ) ~= nil then\
\009\009\009print( \"There is \" .. itemize( room.items ) .. \" here.\" )\
\009\009end\
\009\009if room.trees then\
\009\009\009print( \"There are trees here.\" )\
\009\009end\
\009\009\
\009else\
\009\009-- Look at stuff\
\009\009if room.trees and (_sTarget == \"tree\" or _sTarget == \"trees\") then\
\009\009\009print( \"The trees look easy to break.\" )\
\009\009elseif _sTarget == \"self\" or _sTarget == \"myself\" then\
\009\009\009print( \"Very handsome.\" )\
\009\009else\
\009\009\009local tItem = nil\
\009\009\009local sItem = findItem( room.items, _sTarget )\
\009\009\009if sItem then\
\009\009\009\009tItem = room.items[sItem]\
\009\009\009else\
\009\009\009\009sItem = findItem( inventory, _sTarget )\
\009\009\009\009if sItem then\
\009\009\009\009\009tItem = inventory[sItem]\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if tItem then\
\009\009\009\009print( tItem.desc or (\"You see nothing special about \"..sItem..\".\") )\
\009\009\009else\
\009\009\009\009print( \"You don't see any \".._sTarget..\" here.\" )\
\009\009\009end\
\009\009end\
\009end\
end\
\
function commands.go( _sDir )\
\009local room = getRoom( x,y,z )\
\009if _sDir == nil then\
\009\009print( \"Go where?\" )\
\009\009return\
\009end\
\009\
\009if nGoWest ~= nil then\
\009\009if _sDir == \"west\" then\
\009\009\009nGoWest = nGoWest + 1\
\009\009\009if nGoWest > #tGoWest then\
\009\009\009\009nGoWest = 1\
\009\009\009end\
\009\009\009print( tGoWest[ nGoWest ] )\
\009\009else\
\009\009\009if nGoWest > 0 or nTurn > 6 then\
\009\009\009\009nGoWest = nil\
\009\009\009end\
\009\009end\
\009end\
\009\
\009if room.exits[_sDir] == nil then\
\009\009print( \"You can't go that way.\" )\
\009\009return\
\009end\
\009\
\009if _sDir == \"north\" then\
\009\009z = z + 1\
\009elseif _sDir == \"south\" then\
\009\009z = z - 1\
\009elseif _sDir == \"east\" then\
\009\009x = x - 1\
\009elseif _sDir == \"west\" then\
\009\009x = x + 1\
\009elseif _sDir == \"up\" then\
\009\009y = y + 1\
\009elseif _sDir == \"down\" then\
\009\009y = y - 1\
\009else\
\009\009print( \"I don't understand that direction.\" )\
\009\009return\
\009end\
\009\
\009nTimeInRoom = 0\
\009doCommand( \"look\" )\
end\
\
function commands.dig( _sDir, _sTool )\
\009local room = getRoom( x,y,z )\
\009if _sDir == nil then\
\009\009print( \"Dig where?\" )\
\009\009return\
\009end\
\009\
\009local sTool = nil\
\009local tTool = nil\
\009if _sTool ~= nil then\
\009\009sTool = findItem( inventory, _sTool )\
\009\009if not sTool then\
\009\009\009print( \"You're not carrying a \".._sTool..\".\" )\
\009\009\009return\
\009\009end\
\009\009tTool = inventory[ sTool ]\
\009end\
\009\
\009local room = getRoom( x, y, z )\
\009local bActuallyDigging = (room.exits[ _sDir ] ~= true)\
\009if bActuallyDigging then\
\009\009if sTool == nil or tTool.toolType ~= \"pick\" then\
\009\009\009print( \"You need to use a pickaxe to dig through stone.\" )\
\009\009\009return\
\009\009end\
\009end\
\009\
\009if _sDir == \"north\" then\
\009\009room.exits[\"north\"] = true\
\009\009z = z + 1\
\009\009getRoom( x, y, z ).exits[\"south\"] = true\
\
\009elseif _sDir == \"south\" then\
\009\009room.exits[\"south\"] = true\
\009\009z = z - 1\
\009\009getRoom( x, y, z ).exits[\"north\"] = true\
\009\009\
\009elseif _sDir == \"east\" then\
\009\009room.exits[\"east\"] = true\
\009\009x = x - 1\
\009\009getRoom( x, y, z ).exits[\"west\"] = true\
\009\009\
\009elseif _sDir == \"west\" then\
\009\009room.exits[\"west\"] = true\
\009\009x = x + 1\
\009\009getRoom( x, y, z ).exits[\"east\"] = true\
\009\009\
\009elseif _sDir == \"up\" then\
\009\009if y == 0 then\
\009\009\009print( \"You can't dig that way.\" )\
\009\009\009return\
\009\009end\
\
\009\009room.exits[\"up\"] = true\
\009\009if y == -1 then\
\009\009\009room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\
\009\009end\
\009\009y = y + 1\
\009\009\
\009\009room = getRoom( x, y, z )\
\009\009room.exits[\"down\"] = true\
\009\009if y == 0 then\
\009\009\009room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\
\009\009end\
\009\009\
\009elseif _sDir == \"down\" then\
\009\009if y <= -3 then\
\009\009\009print( \"You hit bedrock.\" )\
\009\009\009return\
\009\009end\
\
\009\009room.exits[\"down\"] = true\
\009\009if y == 0 then\
\009\009\009room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\
\009\009end\
\009\009y = y - 1\
\009\009\
\009\009room = getRoom( x, y, z )\
\009\009room.exits[\"up\"] = true\
\009\009if y == -1 then\
\009\009\009room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\
\009\009end\
\009\009\
\009else\
\009\009print( \"I don't understand that direction.\" )\
\009\009return\
\009end\
\009\
\009--\
\009if bActuallyDigging then\
\009\009if _sDir == \"down\" and y == -1 or\
\009\009   _sDir == \"up\" and y == 0 then\
\009\009\009inventory[ \"some dirt\" ] = items[ \"some dirt\" ]\
\009\009\009inventory[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some dirt and stone.\" )\
\009\009else\
\009\009\009inventory[ \"some stone\" ] = items[ \"some stone\" ]\
\009\009\009print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some stone.\" )\
\009\009end\
\009end\
\009\
\009nTimeInRoom = 0\
\009doCommand( \"look\" )\
end\
\
function commands.inventory()\
\009print( \"You are carrying \" .. itemize( inventory ) .. \".\" )\
end\
\
function commands.drop( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Drop what?\" )\
\009\009return\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( inventory, _sItem )\
\009if sItem then\
\009\009local tItem = inventory[ sItem ]\
\009\009if tItem.droppable == false then\
\009\009\009print( \"You can't drop that.\" )\
\009\009else\
\009\009\009room.items[ sItem ] = tItem\
\009\009\009inventory[ sItem ] = nil\
\009\009\009print( \"Dropped.\" )\
\009\009end\
\009else\
\009\009print( \"You don't have a \".._sItem..\".\" )\
\009end\
end\
\
function commands.place( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Place what?\" )\
\009\009return\
\009end\
\009\
\009if _sItem == \"torch\" or _sItem == \"a torch\" then\
\009\009local room = getRoom( x,y,z )\
\009\009if inventory[\"some torches\"] or inventory[\"a torch\"] then\
\009\009\009inventory[\"a torch\"] = nil\
\009\009\009room.items[\"a torch\"] = items[\"a torch\"]\
\009\009\009if room.dark then\
\009\009\009\009print( \"The cave lights up under the torchflame.\" )\
\009\009\009\009room.dark = false\
\009\009\009elseif y == 0 and not isSunny() then\
\009\009\009\009print( \"The night gets a little brighter.\" )\
\009\009\009else\
\009\009\009\009print( \"Placed.\" )\
\009\009\009end\
\009\009else\
\009\009\009print( \"You don't have torches.\" )\
\009\009end\
\009\009return\
\009end\
\009\
\009commands.drop( _sItem )\
end\
\
function commands.take( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Take what?\" )\
\009\009return\
\009end\
\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( room.items, _sItem )\
\009if sItem then\
\009\009local tItem = room.items[ sItem ]\
\009\009if tItem.heavy == true then\
\009\009\009print( \"You can't carry \"..sItem..\".\" )\
\009\009elseif tItem.ore == true then\
\009\009\009print( \"You need to mine this ore.\" )\
\009\009else\
\009\009\009if tItem.infinite ~= true then\
\009\009\009\009room.items[ sItem ] = nil\
\009\009\009end\
\009\009\009inventory[ sItem ] = tItem\
\009\009\009\
\009\009\009if inventory[\"some torches\"] and inventory[\"a torch\"] then\
\009\009\009\009inventory[\"a torch\"] = nil\
\009\009\009end\
\009\009\009if sItem == \"a torch\" and y < 0 then\
\009\009\009\009room.dark = true\
\009\009\009\009print( \"The cave plunges into darkness.\" )\
\009\009\009else\
\009\009\009\009print( \"Taken.\" )\
\009\009\009end\
\009\009end\
\009else\
\009\009print( \"You don't see a \".._sItem..\" here.\" )\
\009end\
end\
\
function commands.mine( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Mine what?\" )\
\009\009return\
\009end\
\009if _sTool == nil then\
\009\009print( \"Mine \".._sItem..\" with what?\" )\
\009\009return\
\009end\009\
\009commands.cbreak( _sItem, _sTool )\
end\
\
function commands.attack( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Attack what?\" )\
\009\009return\
\009end\
\009commands.cbreak( _sItem, _sTool )\
end\
\
function commands.cbreak( _sItem, _sTool )\
\009if _sItem == nil then\
\009\009print( \"Break what?\" )\
\009\009return\
\009end\
\009\
\009local sTool = nil\
\009if _sTool ~= nil then\
\009\009sTool = findItem( inventory, _sTool )\
\009\009if sTool == nil then\
\009\009\009print( \"You're not carrying a \".._sTool..\".\" )\
\009\009\009return\
\009\009end\
\009end\
\
\009local room = getRoom( x,y,z )\
\009if _sItem == \"tree\" or _sItem == \"trees\" or _sItem == \"a tree\" then\
\009\009print( \"The tree breaks into blocks of wood, which you pick up.\" )\
\009\009inventory[ \"some wood\" ] = items[ \"some wood\" ]\
\009\009return\
\009elseif _sItem == \"self\" or _sItem == \"myself\" then\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You have died.\" )\
\009\009print( \"Score: &e0\" )\
\009\009term.setTextColour( colours.white )\
\009\009bRunning = false\
\009\009return\
\009end\
\009\
\009local sItem = findItem( room.items, _sItem )\
\009if sItem then\
\009\009local tItem = room.items[ sItem ]\
\009\009if tItem.ore == true then\
\009\009\009-- Breaking ore\
\009\009\009if not sTool then\
\009\009\009\009print( \"You need a tool to break this ore.\" )\
\009\009\009\009return\
\009\009\009end\
\009\009\009local tTool = inventory[ sTool ]\
\009\009\009if tTool.tool then\
\009\009\009\009if tTool.toolLevel < tItem.toolLevel then\
\009\009\009\009\009print( sTool ..\" is not strong enough to break this ore.\" )\
\009\009\009\009elseif tTool.toolType ~= tItem.toolType then\
\009\009\009\009\009print( \"You need a different kind of tool to break this ore.\" )\
\009\009\009\009else\
\009\009\009\009\009print( \"The ore breaks, dropping \"..sItem..\", which you pick up.\" )\
\009\009\009\009\009inventory[ sItem ] = items[ sItem ]\
\009\009\009\009\009if tItem.infinite ~= true then\
\009\009\009\009\009\009room.items[ sItem ] = nil\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009print( \"You can't break \"..sItem..\" with \"..sTool..\".\")\
\009\009\009end\
\009\009\009\
\009\009elseif tItem.creature == true then\
\009\009\009-- Fighting monsters (or pigs)\
\009\009\009local toolLevel = 0\
\009\009\009local tTool = nil\
\009\009\009if sTool then\
\009\009\009\009tTool = inventory[ sTool ]\
\009\009\009\009if tTool.toolType == \"sword\" then\
\009\009\009\009\009toolLevel = tTool.toolLevel\
\009\009\009\009end\
\009\009\009end\
\009\009\009\009\009\009\
\009\009\009local tChances = { 0.2, 0.4, 0.55, 0.8, 1 }\
\009\009\009if math.random() <= tChances[ toolLevel + 1 ] then\
\009\009\009\009room.items[ sItem ] = nil\
\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dies.\" )\
\009\
\009\009\009\009if tItem.drops then\
\009\009\009\009\009for n, sDrop in pairs( tItem.drops ) do\
\009\009\009\009\009\009if not room.items[sDrop] then\
\009\009\009\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\
\009\009\009\009\009\009\009room.items[sDrop] = items[sDrop]\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009\
\009\009\009\009if tItem.monster then\
\009\009\009\009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009print( \"The \"..tItem.aliases[1]..\" is injured by your blow.\" )\
\009\009\009end\
\009\009\009\
\009\009\009if tItem.hitDrops then\
\009\009\009\009for n, sDrop in pairs( tItem.hitDrops ) do\
\009\009\009\009\009if not room.items[sDrop] then\
\009\009\009\009\009\009print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\
\009\009\009\009\009\009room.items[sDrop] = items[sDrop]\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\
\009\009else\
\009\009\009print( \"You can't break \"..sItem..\".\" )\
\009\009end\
\009else\
\009\009print( \"You don't see a \".._sItem..\" here.\" )\
\009end\
end\
\
function commands.craft( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Craft what?\" )\
\009\009return\
\009end\
\009\
\009if _sItem == \"computer\" or _sItem == \"a computer\" then\
\009\009print( \"By creating a computer in a computer in a computer, you tear a hole in the spacetime continuum from which no mortal being can escape.\" )\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You have died.\" )\
\009\009print( \"Score: &e0\" )\
\009\009term.setTextColour( colours.white )\
\009\009bRunning = false\
\009\009return\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009local sItem = findItem( items, _sItem )\
\009local tRecipe = (sItem and tRecipes[ sItem ]) or nil\
\009if tRecipe then\
\009\009for n,sReq in ipairs( tRecipe ) do\
\009\009\009if inventory[sReq] == nil then\
\009\009\009\009print( \"You don't have the items you need to craft \"..sItem..\".\" )\
\009\009\009\009return\
\009\009\009end\
\009\009end\
\009\009\
\009\009for n,sReq in ipairs( tRecipe ) do\
\009\009\009inventory[sReq] = nil\
\009\009end\
\009\009inventory[ sItem ] = items[ sItem ]\
\009\009if inventory[\"some torches\"] and inventory[\"a torch\"] then\
\009\009\009inventory[\"a torch\"] = nil\
\009\009end\
\009\009print( \"Crafted.\" )\
\009else\
\009\009print( \"You don't know how to make \"..(sItem or _sItem)..\".\" )\
\009end\009\
end\
\
function commands.build( _sThing, _sMaterial )\
\009if _sThing == nil then\
\009\009print( \"Build what?\" )\
\009\009return\
\009end\
\009\009\
\009local sMaterial = nil\
\009if _sMaterial == nil then\
\009\009for sItem, tItem in pairs( inventory ) do\
\009\009\009if tItem.material then\
\009\009\009\009sMaterial = sItem\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009if sMaterial == nil then\
\009\009\009print( \"You don't have any building materials.\" )\
\009\009\009return\
\009\009end\
\009else\
\009\009sMaterial = findItem( inventory, _sMaterial )\
\009\009if not sMaterial then\
\009\009\009print( \"You don't have any \".._sMaterial )\
\009\009\009return\
\009\009end\
\009\009\
\009\009if inventory[sMaterial].material ~= true then\
\009\009\009print( sMaterial..\" is not a good building material.\" )\
\009\009\009return\
\009\009end\
\009end\
\009\
\009local alias = nil\
\009if string.sub(_sThing, 1, 1) == \"a\" then\
\009\009alias = string.match( _sThing, \"a ([%a ]+)\" )\
\009end\
\009\
\009local room = getRoom( x,y,z )\
\009inventory[sMaterial] = nil\
\009room.items[ _sThing ] = {\
\009\009heavy = true,\
\009\009aliases = { alias },\
\009\009desc = \"As you look at your creation (made from \"..sMaterial..\"), you feel a swelling sense of pride.\",\
\009}\
\
\009print( \"Your construction is complete.\" )\
end\
\
function commands.help()\
\009local sText = \
\009\009\"Welcome to adventure, the greatest text adventure game on CraftOS. \" ..\
\009\009\"To get around the world, type actions, and the adventure will \" ..\
\009\009\"be read back to you. The actions availiable to you are go, look, inspect, inventory, \" ..\
\009\009\"take, drop, place, punch, attack, mine, dig, craft, build, eat and exit.\"\
\009print( sText )\
end\
\
function commands.eat( _sItem )\
\009if _sItem == nil then\
\009\009print( \"Eat what?\" )\
\009\009return\
\009end\
\
\009local sItem = findItem( inventory, _sItem )\
\009if not sItem then\
\009\009print( \"You don't have any \".._sItem..\".\" )\
\009\009return\
\009end\
\009\
\009local tItem = inventory[sItem]\
\009if tItem.food then\
\009\009print( \"That was delicious!\" )\
\009\009inventory[sItem] = nil\
\009\009\
\009\009if bInjured then\
\009\009\009print( \"You are no longer injured.\" )\
\009\009\009bInjured = false\
\009\009end\
\009else\
\009\009print( \"You can't eat \"..sItem..\".\" )\
\009end\
end\
\
function commands.exit()\
\009bRunning = false\
end\
\
function commands.badinput()\
\009local tResponses = {\
\009\009\"I don't understand.\",\
\009\009\"I don't understand you.\",\
\009\009\"You can't do that.\",\
\009\009\"Nope.\",\
\009\009\"Huh?\",\
\009\009\"Say again?\",\
\009\009\"That's crazy talk.\",\
\009\009\"Speak clearly.\",\
\009\009\"I'll think about it.\",\
\009\009\"Let me get back to you on that one.\",\
\009\009\"That doesn't make any sense.\",\
\009\009\"What?\",\
\009}\
\009print( tResponses[ math.random(1,#tResponses) ] )\
end\
\
function commands.noinput()\
\009local tResponses = {\
\009\009\"Speak up.\",\
\009\009\"Enunciate.\",\
\009\009\"Project your voice.\",\
\009\009\"Don't be shy.\",\
\009\009\"Use your words.\",\
\009}\
\009print( tResponses[ math.random(1,#tResponses) ] )\
end\
\
local function simulate()\
\009local bNewMonstersThisRoom = false\
\009\
\009-- Spawn monsters in nearby rooms\
\009for sx = -2,2 do\
\009\009for sy = -1,1 do\
\009\009\009for sz = -2,2 do\
\009\009\009\009local h = y + sy\
\009\009\009\009if h >= -3 and h <= 0 then\
\009\009\009\009\009local room = getRoom( x + sx, h, z + sz )\
\009\009\009\009\009\
\009\009\009\009\009-- Spawn monsters\
\009\009\009\009\009if room.nMonsters < 2 and\
\009\009\009\009\009   ((h == 0 and not isSunny() and not room.items[\"a torch\"]) or room.dark) and\
\009\009\009\009\009   math.random(1,6) == 1 then\
\009\009\009\009\009   \
\009\009\009\009\009\009local sMonster = tMonsters[ math.random(1,#tMonsters) ]\
\009\009\009\009\009\009if room.items[ sMonster ] == nil then\
\009\009\009\009\009   \009\009room.items[ sMonster ] = items[ sMonster ]\
\009\009\009\009\009   \009\009room.nMonsters = room.nMonsters + 1\
\009\009\009\009\009   \009\009\
\009\009\009\009\009   \009\009if sx == 0 and sy == 0 and sz == 0 and not room.dark then\
\009\009\009\009\009   \009\009\009print( \"From the shadows, \"..sMonster..\" appears.\" )\
\009\009\009\009\009   \009\009\009bNewMonstersThisRoom = true\
\009\009\009\009\009   \009\009end\
\009\009\009\009\009\009end\009\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009-- Burn monsters\
\009\009\009\009\009if h == 0 and isSunny() then\
\009\009\009\009\009\009for n,sMonster in ipairs( tMonsters ) do\
\009\009\009\009\009\009\009if room.items[sMonster] and items[sMonster].nocturnal then\
\009\009\009\009\009\009\009\009room.items[sMonster] = nil\
\009\009\009\009\009\009   \009\009if sx == 0 and sy == 0 and sz == 0 and not room.dark then\
\009\009\009\009\009\009   \009\009\009print( \"With the sun high in the sky, the \"..items[sMonster].aliases[1]..\" bursts into flame and dies.\" )\
\009\009\009\009\009\009   \009\009end\
\009\009\009\009\009\009   \009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009\009\009   \009end\
\009\009\009\009\009\009end\
\009\009\009\009\009end\009\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009-- Make monsters attack\
\009local room = getRoom( x, y, z )\
\009if nTimeInRoom >= 2 and not bNewMonstersThisRoom then\
\009\009for n,sMonster in ipairs( tMonsters ) do\
\009\009\009if room.items[sMonster] then\
\009\009\009\009if math.random(1,4) == 1 and\
\009\009\009\009   not (y == 0 and isSunny() and (sMonster == \"a spider\")) then\
\009\009\009\009\009if sMonster == \"a creeper\" then\
\009\009\009\009\009\009if room.dark then\
\009\009\009\009\009\009\009print( \"A creeper explodes.\" )\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009print( \"The creeper explodes.\" )\
\009\009\009\009\009\009end\
\009\009\009\009\009\009room.items[sMonster] = nil\
\009\009\009\009\009\009room.nMonsters = room.nMonsters - 1\
\009\009\009\009\009else\
\009\009\009\009\009\009if room.dark then\
\009\009\009\009\009\009\009print( \"A \"..items[sMonster].aliases[1]..\" attacks you.\" )\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009print( \"The \"..items[sMonster].aliases[1]..\" attacks you.\" )\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009if bInjured then\
\009\009\009\009\009\009if term.isColour() then\
\009\009\009\009\009\009\009term.setTextColour( colours.red )\
\009\009\009\009\009\009end\
\009\009\009\009\009\009print( \"You have died.\" )\
\009\009\009\009\009\009print( \"Score: &e0\" )\
\009\009\009\009\009\009term.setTextColour( colours.white )\
\009\009\009\009\009\009bRunning = false\
\009\009\009\009\009\009return\
\009\009\009\009\009else\
\009\009\009\009\009\009bInjured = true\
\009\009\009\009\009end\
\009\009\009\009\009\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009\
\009-- Always print this\
\009if bInjured then\
\009\009if term.isColour() then\
\009\009\009term.setTextColour( colours.red )\
\009\009end\
\009\009print( \"You are injured.\" )\
\009\009term.setTextColour( colours.white )\
\009end\
\009\
\009-- Advance time\
\009nTurn = nTurn + 1\
\009nTimeInRoom = nTimeInRoom + 1\
end\
\
doCommand( \"look\" )\
simulate()\
\
local tCommandHistory = {}\
while bRunning do\
\009if term.isColour() then\
\009\009term.setTextColour( colours.yellow )\
\009end\
    write( \"? \" )\
\009term.setTextColour( colours.white )\
\009\009\
    local sRawLine = read( nil, tCommandHistory )\
    table.insert( tCommandHistory, sRawLine )\
    \
    local sLine = nil\
\009for match in string.gmatch(sRawLine, \"%a+\") do\
\009\009if sLine then\
\009\009\009sLine = sLine .. \" \" .. string.lower(match)\
\009\009else\
\009\009\009sLine = string.lower(match)\
\009\009end\
\009end\
\009\
\009doCommand( sLine or \"\" )\
    if bRunning then\
\009    simulate()\
\009end\
end",
      "4\
7777777777\
7288888837\
78      87\
788888b 87\
788888b 87\
788888b 87\
788888b 87\
78      87\
7188888807\
7777777777",
      "6\
77  777  77\
72888888897\
 8   8   8\
 8 8b888 8\
78 e8888 87\
78888788887\
78 8888e 87\
 8 888b8 8\
 8   8   8\
75888888807\
77  777  77",
      "1\
     777\
     7b7\
     787\
7777778777\
7188888887\
7777777777",
      "3\
728777778b7\
78888888887\
78777877787\
787 787 787\
787 7877788\
787 7888889\
88777877777\
e888887\
7777887",
      "2\
  77777777\
777888188777\
7b78777787b7\
78787  78787\
78787  78787\
78887  78887\
777877778777\
  78838887\
  77777777",
      "1\
777777777\
7888888b7\
787778887\
787 78777\
7877787\
7888887\
7777787\
    707\
    777",
      "3\
777777777\
788888887\
787787787\
787787787\
788888887\
787787787\
787787787\
78e748887\
777777777",
      "2\
    777  777\
  777877778777\
  788838888887\
7778bbbbbbbb8777\
7888b888888b8897\
7878be8888eb8787\
7588b888888b8887\
7778bbbbbbbb8777\
  788888818887\
  777877778777\
    777  777",
      "2\
    77777777\
777778888887\
788888777787\
7b77787  787\
787 787  787\
7b77787  787\
7888887  787\
7777707  707\
    777  777",
      "5\
 777    77777\
 727777778837\
 788888878787\
 787777888887\
77877778777777\
7e8b7888b888e7\
7787787b777877\
 777887887887\
   7487807487\
   7777777777",
      "0\
77     77\
718888887\
 8     8\
 8     8\
 8     8\
788888897\
77     77",
      "4\
777777 7777\
7287b7 7867\
788787 7887\
77878777877\
 7888eb8887\
 77877787877\
 7887 787887\
 7487 7e7807\
 7777 777777",
      "4\
   777777777\
   727872787\
   787878787\
777787878787777\
7be888888888be7\
777787878787777\
   787878787\
   787478747\
   777777777",
      "--CCRedirection by : RamiLego4Game and Dan200--\
--Based on Redirection by Dan200: http://www.redirectiongame.com--\
--Clearing Screen--\
\
--Vars--\
local TermW,TermH = term.getSize()\
\
local sLevelTitle\
local tScreen\
local oScreen\
local SizeW,SizeH\
local aExits\
local fExit\
local nSpeed\
local Speed\
local fSpeed\
local fSpeedS\
local bPaused\
local Tick\
local Blocks\
local XOrgin,YOrgin\
local fLevel\
\
local function reset()\
    sLevelTitle = \"\"\
    tScreen = {}\
    oScreen = {}\
    SizeW,SizeH = TermW,TermH\
    aExits = 0\
    fExit = \"nop\"\
    nSpeed = 0.6\
    Speed = nSpeed\
    fSpeed = 0.2\
    fSpeedS = false\
    bPaused = false\
    Tick = os.startTimer(Speed)\
    Blocks = 0\
    XOrgin,YOrgin = 1,1\
\
    term.setBackgroundColor(colors.black)\
    term.setTextColor(colors.white)\
    term.clear()\
end\
\
local InterFace = {}\
InterFace.cExit = colors.red\
InterFace.cSpeedD = colors.white\
InterFace.cSpeedA = colors.red\
InterFace.cTitle = colors.red\
\
local cG = colors.lightGray\
local cW = colors.gray\
local cS = colors.black\
local cR1 = colors.blue\
local cR2 = colors.red\
local cR3 = colors.green\
local cR4 = colors.yellow\
\
local tArgs = { ... }\
\
--Functions--\
local function printCentred( yc, stg )\
\009local xc = math.floor((TermW - string.len(stg)) / 2) + 1\
\009term.setCursorPos(xc,yc)\
\009term.write( stg )\
end\
\
local function centerOrgin()\
\009XOrgin = math.floor((TermW/2)-(SizeW/2))\
\009YOrgin = math.floor((TermH/2)-(SizeH/2))\
end\
\
local function reMap()\
\009tScreen = nil\
\009tScreen = {}\
\009for x=1,SizeW do\
\009\009tScreen[x] = {}\
\009\009for y=1,SizeH do\
\009\009\009tScreen[x][y] = { space = true, wall = false, ground = false, robot = \"zz\", start = \"zz\", exit = \"zz\" }\
\009\009end\
\009end\
end\
\
local function tablecopy(t)\
  local t2 = {}\
  for k,v in pairs(t) do\
    t2[k] = v\
  end\
  return t2\
end\
\
local function buMap()\
\009oScreen = nil\
\009oScreen = {}\
\009for x=1,SizeW do\
\009\009oScreen[x] = {}\
\009\009for y=1,SizeH do\
\009\009\009oScreen[x][y] = tablecopy(tScreen[x][y])\
\009\009end\
\009end\
end\
\
local function addRobot(x,y,side,color)\
\009local obj = tScreen[x][y]\
\009local data = side..color\
\009if obj.wall == nil and obj.robot == nil then\
\009\009tScreen[x][y].robot = data\
\009else\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009tScreen[x][y].robot = data\
\009end\
end\
\
local function addStart(x,y,side,color)\
\009local obj = tScreen[x][y]\
\009local data = side..color\
\009if obj.wall == nil and obj.space == nil then\
\009\009tScreen[x][y].start = data\
\009else\
\009\009obj.wall = nil\
\009\009obj.space = nil\
\009\009tScreen[x][y].start = data\
\009end\
\009aExits = aExits+1\
end\
\
local function addGround(x,y)\
\009local obj = tScreen[x][y]\
\009if obj.space == nil and obj.exit == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].ground = true\
\009else\
\009\009obj.space = nil\
\009\009obj.exit = \"zz\"\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009obj.start = \"zz\"\
\009\009tScreen[x][y].ground = true\
\009end\
end\
\
local function addExit(x,y,cl)\
\009local obj = tScreen[x][y]\
\009if obj.space == nil and obj.ground == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].exit = cl\
\009else\
\009\009obj.space = nil\
\009\009obj.ground = nil\
\009\009obj.wall = nil\
\009\009obj.robot = \"zz\"\
\009\009obj.start = \"zz\"\
\009\009tScreen[x][y].exit = cl\
\009end\
end\
\
local function addWall(x,y)\
\009local obj = tScreen[x][y]\
\009if obj == nil then\
\009\009return error(\"Here X\"..x..\" Y\"..y)\
\009end\
\009if obj.space == nil and obj.exit == nil and obj.ground == nil and obj.robot == nil and obj.start == nil then\
\009\009tScreen[x][y].wall = true\
\009else\
\009\009obj.space = nil\
\009\009obj.exit = nil\
\009\009obj.ground = nil\
\009\009obj.robot = nil\
\009\009obj.start = nil\
\009\009tScreen[x][y].wall = true\
\009end\
end\
\
local function loadLevel(nNum)\
    sLevelTitle = \"Level \"..nNum\
\009if nNum == nil then return error(\"nNum == nil\") end\
\009local sDir = fs.getDir( shell.getRunningProgram() )\
\009local sLevelD = sDir .. \"/levels/\" .. tostring(nNum)\
\009if not ( fs.exists(sLevelD) or fs.isDir(sLevelD) ) then return error(\"Level Not Exists : \"..sLevelD) end\
\009fLevel = fs.open(sLevelD,\"r\")\
\009local Line = 0\
\009local wl = true\
\009Blocks = tonumber(string.sub(fLevel.readLine(),1,1))\
\009local xSize = string.len(fLevel.readLine())+2\
\009local Lines = 3\
\009while wl do\
\009\009local wLine = fLevel.readLine()\
\009\009if wLine == nil then\
\009\009\009fLevel.close()\
\009\009\009wl = false\
\009\009else\
    \009    xSize = math.max(string.len(wLine)+2,xSize)\
\009\009\009Lines = Lines + 1\
\009\009end\
\009end\
\009SizeW,SizeH = xSize,Lines\
\009reMap()\
\009fLevel = fs.open(sLevelD,\"r\")\
\009fLevel.readLine()\
\009for Line=2,Lines-1 do\
\009\009sLine = fLevel.readLine()\
\009\009local chars = string.len(sLine)\
\009\009for char = 1, chars do\
\009\009\009local el = string.sub(sLine,char,char)\
\009\009\009if el == \"8\" then\
\009\009\009\009addGround(char+1,Line)\
\009\009\009elseif el == \"0\" then\
\009\009\009\009addStart(char+1,Line,\"a\",\"a\")\
\009\009\009elseif el == \"1\" then\
\009\009\009\009addStart(char+1,Line,\"b\",\"a\")\
\009\009\009elseif el == \"2\" then\
\009\009\009\009addStart(char+1,Line,\"c\",\"a\")\
\009\009\009elseif el == \"3\" then\
\009\009\009\009addStart(char+1,Line,\"d\",\"a\")\
\009\009\009elseif el == \"4\" then\
\009\009\009\009addStart(char+1,Line,\"a\",\"b\")\
\009\009\009elseif el == \"5\" then\
\009\009\009\009addStart(char+1,Line,\"b\",\"b\")\
\009\009\009elseif el == \"6\" then\
\009\009\009\009addStart(char+1,Line,\"c\",\"b\")\
\009\009\009elseif el == \"9\" then\
\009\009\009\009addStart(char+1,Line,\"d\",\"b\")\
\009\009\009elseif el == \"b\" then\
\009\009\009\009addExit(char+1,Line,\"a\")\
\009\009\009elseif el == \"e\" then\
\009\009\009\009addExit(char+1,Line,\"b\")\
\009\009\009elseif el == \"7\" then\
\009\009\009\009addWall(char+1,Line)\
\009\009\009end\
\009\009end\
\009end\
\009fLevel.close()\
end\
\
local function drawStars()\
\009--CCR Background By : RamiLego--\
\009local cStar,cStarG,crStar,crStarB = colors.lightGray,colors.gray,\".\",\"*\"\
\009local DStar,BStar,nStar,gStar = 14,10,16,3\
\009local TermW,TermH = term.getSize()\
\
    term.clear()\
    term.setCursorPos(1,1)\
\009for x=1,TermW do\
\009\009for y=1,TermH do\
\009\009\009local StarT = math.random(1,30)\
\009\009\009if StarT == DStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStar)\
\009\009\009\009write(crStar)\
\009\009\009elseif StarT == BStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStar)\
\009\009\009\009write(crStarB)\
\009\009\009elseif StarT == nStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStarG)\
\009\009\009\009write(crStar)\
\009\009\009elseif StarT == gStar then\
\009\009\009\009term.setCursorPos(x,y)\
\009\009\009\009term.setTextColor(cStarG)\
\009\009\009\009write(crStarB)\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function drawMap()\
\009for x=1,SizeW do\
\009\009for y=1,SizeH do\
\009\009  \
\009\009\009local obj = tScreen[x][y]\
\009\009\009if obj.ground == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cG)\
\009\009\009end\
\009\009\009if obj.wall == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cW)\
\009\009\009end\
\009\009 \
\009\009 local ex = tostring(tScreen[x][y].exit)\
\009\009\009if not(ex == \"zz\" or ex == \"nil\") then\
\009\009\009\009if ex == \"a\" then\
\009\009\009\009\009ex = cR1\
\009\009\009\009elseif ex == \"b\" then\
\009\009\009\009\009ex = cR2\
\009\009\009\009elseif ex == \"c\" then\
\009\009\009\009\009ex = cR3\
\009\009\009\009elseif ex == \"d\" then\
\009\009\009\009\009ex = cR4\
\009\009\009\009else\
\009\009\009\009\009return error(\"Exit Color Out\")\
\009\009\009\009end\
\009\009\009\009term.setBackgroundColor(cG)\
\009\009\009\009term.setTextColor(ex)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\009print(\"X\")\
\009\009\009end\
\009\009 \
\009\009 local st = tostring(tScreen[x][y].start)\
\009\009\009if not(st == \"zz\" or st == \"nil\") then\
\009\009\009\009local Cr = string.sub(st,2,2)\
\009\009\009\009if Cr == \"a\" then\
\009\009\009\009\009Cr = cR1\
\009\009\009\009elseif Cr == \"b\" then\
\009\009\009\009\009Cr = cR2\
\009\009\009\009elseif Cr == \"c\" then\
\009\009\009\009\009Cr = cR3\
\009\009\009\009elseif Cr == \"d\" then\
\009\009\009\009\009Cr = cR4\
\009\009\009\009else\
\009\009\009\009\009return error(\"Start Color Out\")\
\009\009\009\009end\
\009\009\009\
\009\009\009\009term.setTextColor(Cr)\
\009\009\009term.setBackgroundColor(cG)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\
\009\009\009\009sSide = string.sub(st,1,1)\
\009\009\009\009if sSide == \"a\" then\
\009\009\009\009\009print(\"^\")\
\009\009\009\009elseif sSide == \"b\" then\
\009\009\009\009\009print(\">\")\
\009\009\009\009elseif sSide == \"c\" then\
\009\009\009\009\009print(\"v\")\
\009\009\009\009elseif sSide == \"d\" then\
\009\009\009\009\009print(\"<\")\
\009\009\009\009else\
\009\009\009\009\009print(\"@\")\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009\009if obj.space == true then\
\009\009\009\009paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cS)\
\009\009\009end\
\009\009\009\
\009\009\009local rb = tostring(tScreen[x][y].robot)\
\009\009\009if not(rb == \"zz\" or rb == \"nil\") then\
\009\009\009\009local Cr = string.sub(rb,2,2)\
\009\009\009\009if Cr == \"a\" then\
\009\009\009\009\009Cr = cR1\
\009\009\009\009elseif Cr == \"b\" then\
\009\009\009\009\009Cr = cR2\
\009\009\009\009elseif Cr == \"c\" then\
\009\009\009\009\009Cr = cR3\
\009\009\009\009elseif Cr == \"d\" then\
\009\009\009\009\009Cr = cR4\
\009\009\009\009else\
\009\009\009\009\009Cr = colors.white\
\009\009\009\009end\
\009\009\009\009term.setBackgroundColor(Cr)\
\009\009\009\009term.setTextColor(colors.white)\
\009\009\009\009term.setCursorPos(XOrgin+x,YOrgin+y+1)\
\009\009\009\009sSide = string.sub(rb,1,1)\
\009\009\009\009if sSide == \"a\" then\
\009\009\009\009\009print(\"^\")\
\009\009\009\009elseif sSide == \"b\" then\
\009\009\009\009\009print(\">\")\
\009\009\009\009elseif sSide == \"c\" then\
\009\009\009\009\009print(\"v\")\
\009\009\009\009elseif sSide == \"d\" then\
\009\009\009\009\009print(\"<\")\
\009\009\009\009else\
\009\009\009\009\009print(\"@\")\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function isBrick(x,y)\
\009local brb = tostring(tScreen[x][y].robot)\
\009local bobj = oScreen[x][y]\
\009if (brb == \"zz\" or brb == \"nil\") and not bobj.wall == true then\
\009\009return false\
\009else\
\009\009return true\
\009end\
end\
\
local function gRender(sContext)\
\009if sContext == \"start\" then\
\009\009for x=1,SizeW do\
\009\009\009for y=1,SizeH do\
\009\009\009\009local st = tostring(tScreen[x][y].start)\
\009\009\009\009if not(st == \"zz\" or st == \"nil\") then\
\009\009\009\009\009local Cr = string.sub(st,2,2)\
\009\009\009\009\009local sSide = string.sub(st,1,1)\
\009\009\009\009\009addRobot(x,y,sSide,Cr)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009elseif sContext == \"tick\" then\
\009\009buMap()\
        for x=1,SizeW do\
            for y=1,SizeH do\
                local rb = tostring(oScreen[x][y].robot)\
                if not(rb == \"zz\" or rb == \"nil\") then\
                    local Cr = string.sub(rb,2,2)\
                    local sSide = string.sub(rb,1,1)\
                    local sobj = oScreen[x][y]\
                    if sobj.space == true then\
                        tScreen[x][y].robot = \"zz\"\
                        if not sSide == \"g\" then\
                            addRobot(x,y,\"g\",Cr)\
                        end\
                    elseif sobj.exit == Cr then\
                        if sSide == \"a\" or sSide == \"b\" or sSide == \"c\" or sSide == \"d\" then\
                        tScreen[x][y].robot = \"zz\"\
                        addRobot(x,y,\"g\",Cr)\
                        aExits = aExits-1\
                        end\
                    elseif sSide == \"a\" then\
                        local obj = isBrick(x,y-1)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x,y-1,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x-1,y)\
                            local obj3 = isBrick(x+1,y)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"c\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"b\" then\
                        local obj = isBrick(x+1,y)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x+1,y,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x,y-1)\
                            local obj3 = isBrick(x,y+1)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"d\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"c\" then\
                        local obj = isBrick(x,y+1)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x,y+1,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x-1,y)\
                            local obj3 = isBrick(x+1,y)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"b\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"d\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"a\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"d\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"b\",Cr)\
                                end\
                            end\
                        end\
                    elseif sSide == \"d\" then\
                        local obj = isBrick(x-1,y)\
                        tScreen[x][y].robot = \"zz\"\
                        if not obj == true then\
                            addRobot(x-1,y,sSide,Cr)\
                        else\
                            local obj2 = isBrick(x,y-1)\
                            local obj3 = isBrick(x,y+1)\
                            if not obj2 == true and not obj3 == true then\
                                if Cr == \"a\" then\
                                    addRobot(x,y,\"c\",Cr)\
                                elseif Cr == \"b\" then\
                                    addRobot(x,y,\"a\",Cr)\
                                end\
                            elseif obj == true and obj2 == true and obj3 == true then\
                                addRobot(x,y,\"b\",Cr)\
                            else\
                                if obj3 == true then\
                                    addRobot(x,y,\"a\",Cr)\
                                elseif obj2 == true then\
                                    addRobot(x,y,\"c\",Cr)\
                                end\
                            end\
                        end\
                    else\
                        addRobot(x,y,sSide,\"g\")\
                    end\
                end\
            end\
        end\
    end\
end\
\
function InterFace.drawBar()\
\009term.setBackgroundColor( colors.black )\
\009term.setTextColor( InterFace.cTitle )\
\009printCentred( 1, \"  \"..sLevelTitle..\"  \" )\
\009\
\009term.setCursorPos(1,1)\
\009term.setBackgroundColor( cW )\
\009write( \" \" )\
\009term.setBackgroundColor( colors.black )\
\009write( \" x \"..tostring(Blocks)..\" \" )\
\009\
\009term.setCursorPos( TermW-8,TermH )\
\009term.setBackgroundColor( colors.black )\
    term.setTextColour(InterFace.cSpeedD)\
\009write(\" <<\" )\
\009if bPaused then\
\009\009term.setTextColour(InterFace.cSpeedA)\
\009else\
\009\009term.setTextColour(InterFace.cSpeedD)\
\009end\
\009write(\" ||\")\
\009if fSpeedS then\
\009\009term.setTextColour(InterFace.cSpeedA)\
\009else\
\009\009term.setTextColour(InterFace.cSpeedD)\
\009end\
\009write(\" >>\")\
\
\009term.setCursorPos( TermW-1, 1 )\
\009term.setBackgroundColor( colors.black )\
\009term.setTextColour( InterFace.cExit )\
\009write(\" X\")\
\009term.setBackgroundColor(colors.black)\
end\
\
function InterFace.render()\
\009local id,p1,p2,p3 = os.pullEvent()\
\009if id == \"mouse_click\" then\
\009\009if p3 == 1 and p2 == TermW then\
            return \"end\"\
        elseif p3 == TermH and p2 >= TermW-7 and p2 <= TermW-6 then\
            return \"retry\"\
        elseif p3 == TermH and p2 >= TermW-4 and p2 <= TermW-3 then\
            bPaused = not bPaused\
            fSpeedS = false\
            Speed = (bPaused and 0) or nSpeed\
            if Speed > 0 then\
                Tick = os.startTimer(Speed)\
            else\
                Tick = nil\
            end\
            InterFace.drawBar()\
        elseif p3 == TermH and p2 >= TermW-1 then\
            bPaused = false\
            fSpeedS = not fSpeedS\
            Speed = (fSpeedS and fSpeed) or nSpeed\
            Tick = os.startTimer(Speed)\
            InterFace.drawBar()\
\009\009elseif p3-1 < YOrgin+SizeH+1 and p3-1 > YOrgin and\
               p2 < XOrgin+SizeW+1 and p2 > XOrgin then\
            local eobj = tScreen[p2-XOrgin][p3-YOrgin-1]\
            local erobj = tostring(tScreen[p2-XOrgin][p3-YOrgin-1].robot)\
            if (erobj == \"zz\" or erobj == \"nil\") and not eobj.wall == true and not eobj.space == true and Blocks > 0 then\
                addWall(p2-XOrgin,p3-YOrgin-1)\
                Blocks = Blocks-1\
                InterFace.drawBar()\
                drawMap()\
            end\
\009\009end\
\009elseif id == \"timer\" and p1 == Tick then\
\009\009gRender(\"tick\")\
        drawMap()\
        if Speed > 0 then\
            Tick = os.startTimer(Speed)\
        else\
            Tick = nil\
        end\
\009end\
end\
\
local function startG(LevelN)\
\009drawStars()\
\009loadLevel(LevelN)\
\009centerOrgin()\
\009local create = true\
\009drawMap()\
\009InterFace.drawBar()\
\009gRender(\"start\")\
\009drawMap()\
\009\
\009local NExit = true\
\009if aExits == 0 then\
\009\009NExit = false\
\009end\
\009\
\009while true do\
\009\009local isExit = InterFace.render()\
\009\009if isExit == \"end\" then\
\009\009    return nil\
\009\009elseif isExit == \"retry\" then\
\009\009    return LevelN\
\009\009elseif fExit == \"yes\" then\
\009\009\009if fs.exists( fs.getDir( shell.getRunningProgram() ) .. \"/levels/\" .. tostring(LevelN + 1) ) then\
\009\009\009    return LevelN + 1\
\009\009\009else\
\009\009\009    return nil\
\009\009\009end\
\009\009end\
\009\009if aExits == 0 and NExit == true then\
\009\009\009fExit = \"yes\"\
\009\009end\
\009end\
end\
\
local ok, err = true, nil\
\
--Menu--\
local sStartLevel = tArgs[1]\
if ok and not sStartLevel then\
    ok, err = pcall( function()\
        term.setTextColor(colors.white)\
        term.setBackgroundColor( colors.black )\
        term.clear()\
        drawStars()\
        term.setTextColor( colors.red )\
        printCentred( TermH/2 - 1, \"  REDIRECTION  \" )\
        printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
        term.setTextColor( colors.yellow )\
        printCentred( TermH/2 + 2, \"  Click to Begin  \" )\
        os.pullEvent( \"mouse_click\" )\
    end )\
end\
\
--Game--\
if ok then\
    ok,err = pcall( function()\
        local nLevel\
        if sStartLevel then\
            nLevel = tonumber( sStartLevel )\
        else\
            nLevel = 1\
        end\
        while nLevel do\
            reset()\
            nLevel = startG(nLevel)\
        end\
    end )\
end\
\
--Upsell screen--\
if ok then\
    ok, err = pcall( function()\
        term.setTextColor(colors.white)\
        term.setBackgroundColor( colors.black )\
        term.clear()\
        drawStars()\
        term.setTextColor( colors.red )\
        if TermW >= 40 then\
            printCentred( TermH/2 - 1, \"  Thank you for playing Redirection  \" )\
            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\
            term.setTextColor( colors.yellow )\
            printCentred( TermH/2 + 3, \"  http://www.redirectiongame.com  \" )\
        else\
            printCentred( TermH/2 - 2, \"  Thank you for  \" )\
            printCentred( TermH/2 - 1, \"  playing Redirection  \" )\
            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\
            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\
            term.setTextColor( colors.yellow )\
            printCentred( TermH/2 + 3, \"  www.redirectiongame.com  \" )\
        end\
        parallel.waitForAll(\
            function() sleep(2) end,\
            function() os.pullEvent( \"mouse_click\" ) end\
        )\
    end )\
end\
\
--Clear and exit--\
term.setCursorPos(1,1)\
term.setTextColor(colors.white)\
term.setBackgroundColor(colors.black)\
term.clear()\
if not ok then\
    if err == \"Terminated\" then\
        print( \"Check out the full version of Redirection:\" )\
        print( \"http://www.redirectiongame.com\" )\
    else\
        printError( err )\
    end\
end",
      "-- Paint created by nitrogenfingers (edited by dan200)\
-- http://www.youtube.com/user/NitrogenFingers\
\
------------\
-- Fields --\
------------\
\
-- The width and height of the terminal\
local w,h = term.getSize()\
\
-- The selected colours on the left and right mouse button, and the colour of the canvas\
local leftColour, rightColour = colours.white, nil\
local canvasColour = colours.black\
\
-- The values stored in the canvas\
local canvas = {}\
\
-- The menu options\
local mChoices = { \"Save\",\"Exit\" }\
\
-- The message displayed in the footer bar\
local fMessage = \"Press Ctrl to access menu\"\
\
-------------------------\
-- Initialisation --\
-------------------------\
\
-- Determine if we can even run this\
if not term.isColour() then\
\009print(\"Requires an Advanced Computer\")\
\009return\
end\
\
-- Determines if the file exists, and can be edited on this computer\
local tArgs = {...}\
if #tArgs == 0 then\
\009print(\"Usage: paint <path>\")\
\009return\
end\
local sPath = shell.resolve(tArgs[1])\
local bReadOnly = fs.isReadOnly(sPath)\
if fs.exists(sPath) and fs.isDir(sPath) then\
\009print(\"Cannot edit a directory.\")\
\009return\
end\
\
---------------\
-- Functions --\
---------------\
\
local function getCanvasPixel( x, y )\
    if canvas[y] then\
        return canvas[y][x]\
    end\
    return nil\
end\
\
--[[\
\009Converts a colour value to a text character\
\009params: colour = the number to convert to a hex value\
\009returns: a string representing the chosen colour\
]]\
local function getCharOf( colour )\
\009-- Incorrect values always convert to nil\
\009if type(colour) == \"number\" then\
\009\009local value = math.floor( math.log(colour) / math.log(2) ) + 1\
\009\009if value >= 1 and value <= 16 then\
\009\009\009return string.sub( \"0123456789abcdef\", value, value )\
\009\009end\
\009end\
\009return \" \"\
end\009\
\
--[[\
\009Converts a text character to colour value\
\009params: char = the char (from string.byte) to convert to number\
\009returns: the colour number of the hex value\
]]\
local tColourLookup = {}\
for n=1,16 do\
\009tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\
end\
local function getColourOf( char )\
\009-- Values not in the hex table are transparent (canvas coloured)\
\009return tColourLookup[char]\
end\
\
--[[ \
\009Loads the file into the canvas\
\009params: path = the path of the file to open\
\009returns: nil\
]]\
local function load(path)\
\009-- Load the file\
\009if fs.exists(path) then\
\009\009local file = fs.open(sPath, \"r\")\
\009\009local sLine = file.readLine()\
\009\009while sLine do\
\009\009\009local line = {}\
\009\009\009for x=1,w-2 do\
\009\009\009\009line[x] = getColourOf( string.byte(sLine,x,x) )\
\009\009\009end\
\009\009\009table.insert( canvas, line )\
\009\009\009sLine = file.readLine()\
\009\009end\
\009\009file.close()\
\009end\
end\
\
--[[  \
\009Saves the current canvas to file  \
\009params: path = the path of the file to save\
\009returns: true if save was successful, false otherwise\
]]\
local function save(path)\
    -- Open file\
\009local sDir = string.sub(sPath, 1, #sPath - #fs.getName(sPath))\
\009if not fs.exists(sDir) then\
\009\009fs.makeDir(sDir)\
\009end\
\
\009local file = fs.open( path, \"w\" )\
\009if not file then\
\009    return false\
\009end\
\
    -- Encode (and trim)\
\009local tLines = {}\
\009local nLastLine = 0\
\009for y=1,h-1 do\
\009    local sLine = \"\"\
\009    local nLastChar = 0\
\009\009for x=1,w-2 do\
\009\009    local c = getCharOf( getCanvasPixel( x, y ) )\
\009\009    sLine = sLine .. c\
\009\009    if c ~= \" \" then\
\009\009        nLastChar = x\
\009\009    end\
\009\009end\
\009\009sLine = string.sub( sLine, 1, nLastChar )\
\009\009tLines[y] = sLine\
\009\009if string.len( sLine ) > 0 then\
\009\009    nLastLine = y\
\009\009end\
\009end\
\
    -- Save out\
\009for n=1,nLastLine do\
   \009    file.writeLine( tLines[ n ] )\
\009end\
\009file.close()\
\009return true\
end\
\
--[[  \
\009Draws colour picker sidebar, the pallette and the footer\
\009returns: nil\
]]\
local function drawInterface()\
\009-- Footer\
\009term.setCursorPos(1, h)\
\009term.setBackgroundColour(colours.black)\
\009term.setTextColour(colours.yellow)\
\009term.clearLine()\
\009term.write(fMessage)\
\009\
\009-- Colour Picker\
\009for i=1,16 do\
\009\009term.setCursorPos(w-1, i)\
\009\009term.setBackgroundColour( 2^(i-1) )\
\009\009term.write(\"  \")\
\009end\
\
\009term.setCursorPos(w-1, 17)\
\009term.setBackgroundColour( canvasColour )\
\009term.setTextColour( colours.grey )\
\009term.write(\"\\127\\127\")\
\009\009\009\
\009-- Left and Right Selected Colours\
\009for i=18,18 do\
\009\009term.setCursorPos(w-1, i)\
\009\009if leftColour ~= nil then\
\009\009\009term.setBackgroundColour( leftColour )\
\009\009\009term.write(\" \")\
\009\009else\
\009\009\009term.setBackgroundColour( canvasColour )\
\009\009\009term.setTextColour( colours.grey )\
\009\009\009term.write(\"\\127\")\
\009\009end\
\009\009if rightColour ~= nil then\
\009\009\009term.setBackgroundColour( rightColour )\
\009\009\009term.write(\" \")\
\009\009else\
\009\009\009term.setBackgroundColour( canvasColour )\
\009\009\009term.setTextColour( colours.grey )\
\009\009\009term.write(\"\\127\")\
\009\009end\
\009end\
\
\009-- Padding\
\009term.setBackgroundColour( canvasColour )\
\009for i=20,h-1 do\
\009\009term.setCursorPos(w-1, i)\
\009\009term.write(\"  \")\
\009end\
end\
\
--[[  \
\009Converts a single pixel of a single line of the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvasPixel( x, y )\
\009local pixel = getCanvasPixel( x, y )\
\009if pixel then\
\009\009term.setBackgroundColour( pixel or canvasColour )\
\009\009term.setCursorPos(x, y)\
\009\009term.write(\" \")\
\009else\
\009\009term.setBackgroundColour( canvasColour )\
\009\009term.setTextColour( colours.grey )\
\009\009term.setCursorPos(x, y)\
        term.write(\"\\127\")\
\009end\
end\
\
--[[  \
\009Converts each colour in a single line of the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvasLine( y )\
\009for x = 1, w-2 do\
\009\009drawCanvasPixel( x, y )\
\009end\
end\
\
--[[  \
\009Converts each colour in the canvas and draws it\
\009returns: nil\
]]\
local function drawCanvas()\
\009for y = 1, h-1 do\
\009\009drawCanvasLine( y )\
\009end\
end\
\
--[[\
\009Draws menu options and handles input from within the menu.\
\009returns: true if the program is to be exited; false otherwise\
]]\
local function accessMenu()\
\009-- Selected menu option\
\009local selection = 1\
\009\
\009term.setBackgroundColour(colours.black)\
\009while true do\
\009\009-- Draw the menu\
\009\009term.setCursorPos(1,h)\
\009\009term.clearLine()\
\009\009term.setTextColour(colours.white)\
\009\009for k,v in pairs(mChoices) do\
\009\009\009if selection==k then \
\009\009\009\009term.setTextColour(colours.yellow)\
\009\009\009\009local ox,_ = term.getCursorPos()\
\009\009\009\009term.write(\"[\"..string.rep(\" \",#v)..\"]\")\
\009\009\009\009term.setCursorPos(ox+1,h)\
\009\009\009\009term.setTextColour(colours.white)\
\009\009\009\009term.write(v)\
\009\009\009\009term.setCursorPos(term.getCursorPos()+1,h)\
\009\009\009else\
\009\009\009\009term.write(\" \"..v..\" \")\
\009\009\009end\
\009\009end\
\009\009\
\009\009-- Handle input in the menu\
\009\009local id,key = os.pullEvent(\"key\")\
\009\009if id == \"key\" then\
\009\009\009-- S and E are shortcuts\
\009\009\009if key == keys.s then\
\009\009\009\009selection = 1\
\009\009\009\009key = keys.enter\
\009\009\009elseif key == keys.e then\
\009\009\009\009selection = 2\
\009\009\009\009key = keys.enter\
\009\009\009end\
\009\009\
\009\009\009if key == keys.right then\
\009\009\009\009-- Move right\
\009\009\009\009selection = selection + 1\
\009\009\009\009if selection > #mChoices then\
\009\009\009\009\009selection = 1\
\009\009\009\009end\
\009\009\009\009\
\009\009\009elseif key == keys.left and selection > 1 then\
\009\009\009\009-- Move left\
\009\009\009\009selection = selection - 1\
\009\009\009\009if selection < 1 then\
\009\009\009\009\009selection = #mChoices\
\009\009\009\009end\
\009\009\009\009\
\009\009\009elseif key == keys.enter then\
\009\009\009\009-- Select an option\
\009\009\009\009if mChoices[selection]==\"Save\" then \
\009\009\009\009\009if bReadOnly then \
\009\009\009\009\009\009fMessage = \"Access Denied\"\
\009\009\009\009\009\009return false\
\009\009\009\009\009end\
\009\009\009\009\009local success = save(sPath)\
\009\009\009\009\009if success then\
\009\009\009\009\009\009fMessage = \"Saved to \"..sPath\
\009\009\009\009\009else\
\009\009\009\009\009\009fMessage = \"Error saving to \"..sPath\
\009\009\009\009\009end\
\009\009\009\009\009return false\
\009\009\009\009elseif mChoices[selection]==\"Exit\" then \
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009elseif key == keys.leftCtrl or keys == keys.rightCtrl then\
\009\009\009\009-- Cancel the menu\
\009\009\009\009return false \
\009\009\009end\
\009\009end\
\009end\
end\
\
--[[  \
\009Runs the main thread of execution. Draws the canvas and interface, and handles\
\009mouse and key events.\
\009returns: nil\
]]\
local function handleEvents()\
\009local programActive = true\
\009while programActive do\
\009\009local id,p1,p2,p3 = os.pullEvent()\
\009\009if id==\"mouse_click\" or id==\"mouse_drag\" then\
\009\009\009if p2 >= w-1 and p3 >= 1 and p3 <= 17 then\
\009\009\009\009if id ~= \"mouse_drag\" then\
\009\009\009\009\009-- Selecting an items in the colour picker\
\009\009\009\009\009if p3 <= 16 then\
\009\009\009\009\009\009if p1==1 then\
\009\009\009\009\009\009\009leftColour = 2^(p3-1)\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009rightColour = 2^(p3-1)\
\009\009\009\009\009\009end\
\009\009\009\009\009else\
\009\009\009\009\009\009if p1==1 then\
\009\009\009\009\009\009\009leftColour = nil\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009rightColour = nil\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009\009--drawCanvas()\
\009\009\009\009\009drawInterface()\
\009\009\009\009end\
\009\009\009elseif p2 < w-1 and p3 <= h-1 then\
\009\009\009\009-- Clicking on the canvas\
\009\009\009\009local paintColour = nil\
\009\009\009\009if p1==1 then\
\009\009\009\009\009paintColour = leftColour\
\009\009\009\009elseif p1==2 then\
\009\009\009\009\009paintColour = rightColour\
\009\009\009\009end\
\009\009\009\009if not canvas[p3] then\
                    canvas[p3] = {}\
    \009\009\009end\
                canvas[p3][p2] = paintColour\
\
\009\009\009\009drawCanvasPixel( p2, p3 )\
\009\009\009end\
\009\009elseif id==\"key\" then\
\009\009\009if p1==keys.leftCtrl or p1==keys.rightCtrl then\
\009\009\009\009programActive = not accessMenu()\
\009\009\009\009drawInterface()\
\009\009\009end\
\009\009elseif id==\"term_resize\" then\
\009\009    w,h = term.getSize()\
            drawCanvas()\
            drawInterface()\
        end\
\009end\
end\
\
-- Init\
load(sPath)\
drawCanvas()\
drawInterface()\
\
-- Main loop\
handleEvents()\
\
-- Shutdown\
term.setBackgroundColour(colours.black)\
term.setTextColour(colours.white)\
term.clear()\
term.setCursorPos(1,1)",
      "\
-- Display the start screen\
local w,h = term.getSize()\
\
local titleColour, headingColour, textColour, wormColour, fruitColour\
if term.isColour() then\
    titleColour = colours.red\
\009headingColour = colours.yellow\
\009textColour = colours.white\
\009wormColour = colours.green\
\009fruitColour = colours.red\
else\
    titleColour = colours.white\
\009headingColour = colours.white\
\009textColour = colours.white\
\009wormColour = colours.white\
\009fruitColour = colours.white\
end\
\
local function printCentred( y, s )\
\009local x = math.floor((w - string.len(s)) / 2)\
\009term.setCursorPos(x,y)\
\009--term.clearLine()\
\009term.write( s )\
end\
\
local xVel,yVel = 1,0\
local xPos, yPos = math.floor(w/2), math.floor(h/2)\
local pxVel, pyVel = nil, nil\
\
local nLength = 1\
local nExtraLength = 6\
local bRunning = true\
\
local tailX,tailY = xPos,yPos\
local nScore = 0\
local nDifficulty = 2\
local nSpeed, nInterval\
\
-- Setup the screen\
local screen = {}\
for x=1,w do\
\009screen[x] = {}\
\009for y=1,h do\
\009\009screen[x][y] = {}\
\009end\
end\
screen[xPos][yPos] = { snake = true }\
\
local nFruit = 1\
local tFruits = {\
\009\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\
\009\"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\
\009\"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\
\009\"Y\", \"Z\",\
\009\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\
\009\"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\",\
\009\"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\",\
\009\"y\", \"z\",\
\009\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\",\
\009\"@\", \"$\", \"%\", \"#\", \"&\", \"!\", \"?\", \"+\", \"*\", \"~\"\
}\
\
local function addFruit()\
\009while true do\
\009\009local x = math.random(1,w)\
\009\009local y = math.random(2,h)\
\009\009local fruit = screen[x][y]\
\009\009if fruit.snake == nil and fruit.wall == nil and fruit.fruit == nil then\
\009\009\009screen[x][y] = { fruit = true }\
\009\009\009term.setCursorPos(x,y)\
\009\009\009term.setBackgroundColour( fruitColour )\
\009\009\009term.write(\" \")\
\009\009\009term.setBackgroundColour( colours.black )\
\009\009\009break\
\009\009end\
\009end\
\009\
\009nFruit = nFruit + 1\
\009if nFruit > #tFruits then\
\009\009nFruit = 1\
\009end\
end\
\
local function drawMenu()\
\009term.setTextColour( headingColour )\
\009term.setCursorPos(1,1)\
\009term.write( \"SCORE \" )\
\009\
\009term.setTextColour( textColour )\
\009term.setCursorPos(7,1)\
\009term.write( tostring(nScore) )\
\
\009term.setTextColour( headingColour )\
\009term.setCursorPos(w-11,1)\
\009term.write( \"DIFFICULTY \")\
\
\009term.setTextColour( textColour )\
\009term.setCursorPos(w,1)\
\009term.write( tostring(nDifficulty or \"?\") ) \
\
\009term.setTextColour( colours.white )\
end\
\
local function update( )\
\009local x,y = xPos,yPos\
\009if pxVel and pyVel then\
\009\009xVel, yVel = pxVel, pyVel\
\009\009pxVel, pyVel = nil, nil\
\009end\
\
\009-- Remove the tail\
\009if nExtraLength == 0 then\
\009\009local tail = screen[tailX][tailY]\
\009\009screen[tailX][tailY] = {}\
\009\009term.setCursorPos(tailX,tailY)\
\009\009term.write(\" \")\
\009\009tailX = tail.nextX\
\009\009tailY = tail.nextY\
\009else\
\009\009nExtraLength = nExtraLength - 1\
\009end\
\009\
\009-- Update the head\
\009local head = screen[xPos][yPos]\
\009local newXPos = xPos + xVel\
\009local newYPos = yPos + yVel\
\009if newXPos < 1 then\
\009\009newXPos = w\
\009elseif newXPos > w then\
\009\009newXPos = 1\
\009end\
\009if newYPos < 2 then\
\009\009newYPos = h\
\009elseif newYPos > h then\
\009\009newYPos = 2\
\009end\
\009\
\009local newHead = screen[newXPos][newYPos]\
\009term.setCursorPos(1,1);\
\009print( newHead.snake )\
\009if newHead.snake == true or newHead.wall == true then\
\009\009bRunning = false\
\009\009\
\009else\
\009\009if newHead.fruit == true then\
\009\009\009nScore = nScore + 10\
\009\009\009nExtraLength = nExtraLength + 1\
\009\009\009addFruit()\
\009\009end\
\009\009xPos = newXPos\
\009\009yPos = newYPos\
\009\009head.nextX = newXPos\
\009\009head.nextY = newYPos\
\009\009screen[newXPos][newYPos] = { snake = true }\
\009\009\
\009end\
\009\
\009term.setCursorPos(xPos,yPos)\
\009term.setBackgroundColour( wormColour )\
\009term.write(\" \")\
\009term.setBackgroundColour( colours.black )\
\
\009drawMenu()\
end\
\
-- Display the frontend\
term.clear()\
local function drawFrontend()\
\009--term.setTextColour( titleColour )\
    --printCentred( math.floor(h/2) - 4, \" W O R M \" )\
\
\009term.setTextColour( headingColour )\
\009printCentred( math.floor(h/2) - 3, \"\" )\
\009printCentred( math.floor(h/2) - 2, \" SELECT DIFFICULTY \" )\
\009printCentred( math.floor(h/2) - 1, \"\" )\
\009\
\009printCentred( math.floor(h/2) + 0, \"            \" )\
\009printCentred( math.floor(h/2) + 1, \"            \" )\
\009printCentred( math.floor(h/2) + 2, \"            \" )\
\009printCentred( math.floor(h/2) - 1 + nDifficulty, \" [        ] \" )\
\
\009term.setTextColour( textColour )\
\009printCentred( math.floor(h/2) + 0, \"EASY\" )\
\009printCentred( math.floor(h/2) + 1, \"MEDIUM\" )\
\009printCentred( math.floor(h/2) + 2, \"HARD\" )\
\009printCentred( math.floor(h/2) + 3, \"\" )\
\
\009term.setTextColour( colours.white )\
end\
\
drawMenu()\
drawFrontend()\
while true do\
\009local e,key = os.pullEvent( \"key\" )\
\009if key == keys.up or key == keys.w then\
\009\009-- Up\
\009\009if nDifficulty > 1 then\
\009\009\009nDifficulty = nDifficulty - 1\
\009\009\009drawMenu()\
\009\009\009drawFrontend()\
\009\009end\
\009elseif key == keys.down or key == keys.s then\
\009\009-- Down\
\009\009if nDifficulty < 3 then\
\009\009\009nDifficulty = nDifficulty + 1\
\009\009\009drawMenu()\
\009\009\009drawFrontend()\
\009\009end\
\009elseif key == keys.enter then\
\009\009-- Enter\
\009\009break\
\009end\
end\
\
local tSpeeds = { 5, 10, 25 }\
nSpeed = tSpeeds[nDifficulty]\
nInterval = 1 / nSpeed\
\
-- Grow the snake to its intended size\
term.clear()\
drawMenu()\
screen[tailX][tailY].snake = true\
while nExtraLength > 0 do\
\009update()\
end\
addFruit()\
addFruit()\
\
-- Play the game\
local timer = os.startTimer(0)\
while bRunning do\
\009local event, p1, p2 = os.pullEvent()\
\009if event == \"timer\" and p1 == timer then\
\009\009timer = os.startTimer(nInterval)\
\009\009update( false )\
\009\
\009elseif event == \"key\" then\
\009\009local key = p1\
\009\009if key == keys.up or key == keys.w then\
\009\009\009-- Up\
\009\009\009if yVel == 0 then\
\009\009\009\009pxVel,pyVel = 0,-1\
\009\009\009end\
\009\009elseif key == keys.down or key == keys.s then\
\009\009\009-- Down\
\009\009\009if yVel == 0 then\
\009\009\009\009pxVel,pyVel = 0,1\
\009\009\009end\
\009\009elseif key == keys.left or key == keys.a then\
\009\009\009-- Left\
\009\009\009if xVel == 0 then\
\009\009\009\009pxVel,pyVel = -1,0\
\009\009\009end\
\009\009\
\009\009elseif key == keys.right or key == keys.d then\
\009\009\009-- Right\
\009\009\009if xVel == 0 then\
\009\009\009\009pxVel,pyVel = 1,0\
\009\009\009end\
\009\009\
\009\009end\009\
\009end\
end\
\
-- Display the gameover screen\
term.setTextColour( headingColour )\
printCentred( math.floor(h/2) - 2, \"                   \" )\
printCentred( math.floor(h/2) - 1, \" G A M E   O V E R \" )\
\
term.setTextColour( textColour )\
printCentred( math.floor(h/2) + 0, \"                 \" )\
printCentred( math.floor(h/2) + 1, \" FINAL SCORE \"..nScore..\" \" )\
printCentred( math.floor(h/2) + 2, \"                 \" )\
term.setTextColour( colours.white )\
\
local timer = os.startTimer(2.5)\
repeat\
\009local e,p = os.pullEvent()\
\009if e == \"timer\" and p == timer then\
\009\009term.setTextColour( textColour )\
\009\009printCentred( math.floor(h/2) + 2, \" PRESS ANY KEY \" )\
\009\009printCentred( math.floor(h/2) + 3, \"               \" )\
\009\009term.setTextColour( colours.white )\
\009end\
until e == \"char\"\
\
term.clear()\
term.setCursorPos(1,1)\
\
\009\009",
      "if term.isColour() then\
\009term.setTextColour( 2^math.random(0,15) )\
end\
textutils.slowPrint( \"Hello World!\" )\
term.setTextColour( colours.white )",
      "--[[\
Falling - Based on Tetris by Alexey Pajitnov\
This version written by Gopher, at the request of Dan200, for\
ComputerCraft v1.6. No particular rights are reserved.\
--]]\
\
local function colorass(c,bw)\
  return term.isColor() and c or bw\
end\
\
local block_s1= {\
    {\
      { 1,0,0,0, },\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 0,1,1,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"{}\"),\
    fg=colorass(colors.blue,colors.black),\
    bg=colorass(colors.cyan,colors.white),\
  }\
local block_s2= {\
    {\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 1,0,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,0,0, },\
      { 0,1,1,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"{}\"),\
    fg=colorass(colors.green,colors.black),\
    bg=colorass(colors.lime,colors.white),\
  }\
local block_line = {\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,1, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"[]\"),\
    fg=colorass(colors.pink,colors.black),\
    bg=colorass(colors.red,colors.white),\
  }\
local block_square = {\
    {\
      { 1,1,0,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"[]\"),\
    fg=colorass(colors.lightBlue,colors.black),\
    bg=colorass(colors.blue,colors.white),\
  }\
local block_L1 = {\
    {\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 1,0,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,1,1,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,1,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"()\"),\
    fg=colorass(colors.orange,colors.black),\
    bg=colorass(colors.yellow,colors.white),\
  }\
local block_L2 = {\
    {\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 0,0,1,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,1,0, },\
      { 0,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 1,0,0,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"()\"),\
    fg=colorass(colors.brown,colors.black),\
    bg=colorass(colors.orange,colors.white),\
  }\
local block_T = {\
    {\
      { 0,1,0,0, },\
      { 1,1,0,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,0,0,0, },\
      { 1,1,1,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 0,1,1,0, },\
      { 0,1,0,0, },\
      { 0,0,0,0, },\
    },\
    {\
      { 0,1,0,0, },\
      { 1,1,1,0, },\
      { 0,0,0,0, },\
      { 0,0,0,0, },\
    },\
    ch=colorass(\"  \",\"<>\"),\
    fg=colorass(colors.cyan,colors.black),\
    bg=colorass(colors.purple,colors.white),\
  }\
\
local blocks={ block_line, block_square, block_s1, block_s2, block_L1, block_L2, block_T}\
\
local points={4,10,30,120}\
\
local function lpad(text,amt)\
  text=tostring(text)\
  return string.rep(\" \",amt-#text)..text\
end\
\
local width,height=term.getSize()\
\
if height<19 or width<26 then\
  print(\"Your screen is too small to play :(\")\
  return\
end\
\
\
local speedsByLevel={\
  1.2,\
  1.0,\
   .8,\
   .65,\
   .5,\
   .4,\
   .3,\
   .25,\
   .2,\
   .15,\
   .1,\
   .05,}\
\
local level=1\
\
local function playGame()\
  local score=0\
  local lines=0\
  local initialLevel=level\
  local next=blocks[math.random(1,#blocks)]\
\
  local pit={}\
\
\
  local heightAdjust=0\
\
  if height<=19 then\
    heightAdjust=1\
  end\
\
\
\
  local function drawScreen()\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    term.clear()\
\
    term.setTextColor(colors.black)\
    term.setBackgroundColor(colorass(colors.lightGray, colors.white))\
    term.setCursorPos(22,2)\
    term.write(\"Score\") --score\
    term.setCursorPos(22,5)\
    term.write(\"Level\")  --level\
    term.setCursorPos(22,8)\
    term.write(\"Lines\")  --lines\
    term.setCursorPos(22,12)\
    term.write(\"Next\") --next\
\
    term.setCursorPos(21,1)\
    term.write(\"      \")\
    term.setCursorPos(21,2)\
    term.write(\" \") --score\
    term.setCursorPos(21,3)\
    term.write(\" \")\
    term.setCursorPos(21,4)\
    term.write(\"      \")\
    term.setCursorPos(21,5)\
    term.write(\" \")  --level\
    term.setCursorPos(21,6)\
    term.write(\" \")\
    term.setCursorPos(21,7)\
    term.write(\"      \")\
    term.setCursorPos(21,8)\
    term.write(\" \")  --lines\
    term.setCursorPos(21,9)\
    term.write(\" \")\
    term.setCursorPos(21,10)\
    term.write(\"      \")\
    term.setCursorPos(21,11)\
    term.write(\"      \")\
    term.setCursorPos(21,12)\
    term.write(\" \") --next\
    term.setCursorPos(26,12)\
    term.write(\" \") --next\
    term.setCursorPos(21,13)\
    term.write(\"      \")\
    term.setCursorPos(21,14)\
    term.write(\" \")\
    term.setCursorPos(21,15)\
    term.write(\" \")\
    term.setCursorPos(21,16)\
    term.write(\" \")\
    term.setCursorPos(21,17)\
    term.write(\" \")\
    term.setCursorPos(21,18)\
    term.write(\" \")\
    term.setCursorPos(21,19)\
    term.write(\"      \")\
    term.setCursorPos(21,20)\
    term.write(\"      \")\
  end\
\
  local function updateNumbers()\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
\
    term.setCursorPos(22,3)\
    term.write(lpad(score,5)) --score\
    term.setCursorPos(22,6)\
    term.write(lpad(level,5))  --level\
    term.setCursorPos(22,9)\
    term.write(lpad(lines,5))  --lines\
  end\
\
  local function drawBlockAt(block,xp,yp,rot)\
    term.setTextColor(block.fg)\
    term.setBackgroundColor(block.bg)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\
          term.write(block.ch)\
        end\
      end\
    end\
  end\
\
  local function eraseBlockAt(block,xp,yp,rot)\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\
          term.write(\"  \")\
        end\
      end\
    end\
  end\
\
  local function testBlockAt(block,xp,yp,rot)\
    for y=1,4 do\
      local ty=yp+y-1\
      for x=1,4 do\
        local tx=xp+x-1\
        if block[rot][y][x]==1 then\
          if tx>10 or tx<1 or ty>20 or pit[ty][tx]~=0 then\
            return true\
          end\
        end\
      end\
    end\
  end\
\
  local function pitBlock(block,xp,yp,rot)\
    for y=1,4 do\
      for x=1,4 do\
        if block[rot][y][x]==1 then\
          pit[yp+y-1][xp+x-1]=block\
        end\
      end\
    end\
  end\
\
\
  local function clearPit()\
    for row=1,20 do\
      pit[row]={}\
      for col=1,10 do\
        pit[row][col]=0\
      end\
    end\
  end\
\
\
\
  drawScreen()\
  updateNumbers()\
\
  --declare & init the pit\
  clearPit()\
\
\
\
  local halt=false\
  local dropSpeed=speedsByLevel[math.min(level,12)]\
\
\
  local curBlock=next\
  next=blocks[math.random(1,7)]\
\
  local curX, curY, curRot=4, 1, 1\
  local dropTimer=os.startTimer(dropSpeed)\
\
  drawBlockAt(next,11.5,15+heightAdjust,1)\
  drawBlockAt(curBlock,curX,curY,curRot)\
\
  local function redrawPit()\
    for r=1+heightAdjust,20 do\
      term.setCursorPos(1,r-heightAdjust)\
      for c=1,10 do\
        if pit[r][c]==0 then\
          term.setTextColor(colors.black)\
          term.setBackgroundColor(colors.black)\
          term.write(\"  \")\
        else\
          term.setTextColor(pit[r][c].fg)\
          term.setBackgroundColor(pit[r][c].bg)\
          term.write(pit[r][c].ch)\
        end\
      end\
    end\
  end\
\
  local function hidePit()\
    for r=1+heightAdjust,20 do\
      term.setCursorPos(1,r-heightAdjust)\
      term.setTextColor(colors.black)\
      term.setBackgroundColor(colors.black)\
      term.write(\"                    \")\
    end\
  end\
\
  local function msgBox(message)\
    local x=math.floor((17-#message)/2)\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
    term.setTextColor(colors.black)\
    term.setCursorPos(x,9)\
    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\
    term.setCursorPos(x,10)\
    term.write(\"|\")\
    term.setCursorPos(x+#message+3,10)\
    term.write(\"|\")\
    term.setCursorPos(x,11)\
    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\
    term.setTextColor(colors.white)\
    term.setBackgroundColor(colors.black)\
    term.setCursorPos(x+1,10)\
    term.write(\" \"..message..\" \")\
  end\
\
  local function clearRows()\
    local rows={}\
    for r=1,20 do\
      local count=0\
      for c=1,10 do\
        if pit[r][c]~=0 then\
          count=count+1\
        else\
          break\
        end\
      end\
      if count==10 then\
        rows[#rows+1]=r\
      end\
    end\
\
    if #rows>0 then\
      for i=1,4 do\
        sleep(.1)\
        for r=1,#rows do\
          r=rows[r]\
          term.setCursorPos(1,r-heightAdjust)\
          for c=1,10 do\
            term.setTextColor(pit[r][c].bg)\
            term.setBackgroundColor(pit[r][c].fg)\
            term.write(pit[r][c].ch)\
          end\
        end\
        sleep(.1)\
        for r=1,#rows do\
          r=rows[r]\
          term.setCursorPos(1,r-heightAdjust)\
          for c=1,10 do\
            term.setTextColor(pit[r][c].fg)\
            term.setBackgroundColor(pit[r][c].bg)\
            term.write(pit[r][c].ch)\
          end\
        end\
      end\
      --now remove the rows and drop everythign else\
      term.setBackgroundColor(colors.black)\
      for r=1,#rows do\
        r=rows[r]\
        term.setCursorPos(1,r-heightAdjust)\
        term.write(\"                    \")\
      end\
      sleep(.25)\
      for r=1,#rows do\
        table.remove(pit,rows[r])\
        table.insert(pit,1,{0,0,0,0,0,0,0,0,0,0})\
      end\
      redrawPit()\
      lines=lines+#rows\
      score=score+points[#rows]*math.min(level,20)\
      level=math.floor(lines/10)+initialLevel\
      dropSpeed=speedsByLevel[math.min(level,12)]\
      updateNumbers()\
    end\
    sleep(.25)\
  end\
\
  local function blockFall()\
    local result = false\
    if testBlockAt(curBlock,curX,curY+1,curRot) then\
      pitBlock(curBlock,curX,curY,curRot)\
      --detect rows that clear\
      clearRows(rows)\
\
      curBlock=next\
      curX=4\
      curY=1\
      curRot=1\
      if testBlockAt(curBlock,curX,curY,curRot) then\
        halt=true\
      end\
      drawBlockAt(curBlock,curX,curY,curRot)\
      eraseBlockAt(next,11.5,15+heightAdjust,1)\
      next=blocks[math.random(1,7)]\
      drawBlockAt(next,11.5,15+heightAdjust,1)\
      return true\
    else\
      eraseBlockAt(curBlock,curX,curY,curRot)\
      curY=curY+1\
      drawBlockAt(curBlock,curX,curY,curRot)\
      return false\
    end\
  end\
\
\
  while not halt do\
    local e={os.pullEvent()}\
    if e[1]==\"timer\" then\
      if e[2]==dropTimer then\
        blockFall()\
        dropTimer=os.startTimer(dropSpeed)\
      end\
    elseif e[1]==\"key\" then\
      local key=e[2]\
      local dx,dy,dr=0,0,0\
      if key==keys.left or key==keys.a then\
        dx=-1\
      elseif key==keys.right or key==keys.d then\
        dx=1\
      elseif key==keys.up or key==keys.w then\
        dr=1\
      elseif key==keys.down or key==keys.s then\
        while not blockFall() do end\
        dropTimer=os.startTimer(dropSpeed)\
      elseif key==keys.space then\
        hidePit()\
        msgBox(\"Paused\")\
        while ({os.pullEvent(\"key\")})[2]~=keys.space do end\
        redrawPit()\
        drawBlockAt(curBlock,curX,curY,curRot)\
        dropTimer=os.startTimer(dropSpeed)\
      end\
      if dx+dr~=0 then\
        if not testBlockAt(curBlock,curX+dx,curY+dy,(dr>0 and curRot%#curBlock+dr or curRot)) then\
          eraseBlockAt(curBlock,curX,curY,curRot)\
          curX=curX+dx\
          curY=curY+dy\
          curRot=dr==0 and curRot or (curRot%#curBlock+dr)\
          drawBlockAt(curBlock,curX,curY,curRot)\
        end\
      end\
    elseif e[1]==\"term_resize\" then\
      local w,h=term.getSize()\
      if h==20 then\
        heightAdjust=0\
      else\
        heightAdjust=1\
      end\
      redrawPit()\
      drawBlockAt(curBlock,curX,curY,curRot)\
    end\
  end\
\
  msgBox(\"Game Over!\")\
  while true do\
    local _,k=os.pullEvent(\"key\")\
    if k==keys.space or k==keys.enter then\
      break\
    end\
  end\
\
  level = math.min(level,9)\
end\
\
\
local selected=1\
local playersDetected=false\
\
local function drawMenu()\
  term.setBackgroundColor(colors.black)\
  term.setTextColor(colorass(colors.red,colors.white))\
  term.clear()\
\
  local cx,cy=math.floor(width/2),math.floor(height/2)\
\
  term.setCursorPos(cx-6,cy-2)\
  term.write(\"F A L L I N G\")\
\
  if playersDetected then\
    if selected==0 then\
      term.setTextColor(colorass(colors.blue,colors.black))\
      term.setBackgroundColor(colorass(colors.gray,colors.white))\
    else\
      term.setTextColor(colorass(colors.lightBlue,colors.white))\
      term.setBackgroundColor(colors.black)\
    end\
    term.setCursorPos(cx-12,cy)\
    term.write(\" Play head-to-head game! \")\
  end\
\
  term.setCursorPos(cx-10,cy+1)\
  if selected==1 then\
    term.setTextColor(colorass(colors.blue,colors.black))\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
  else\
    term.setTextColor(colorass(colors.lightBlue,colors.white))\
    term.setBackgroundColor(colors.black)\
  end\
  term.write(\" Play from level: <\" .. level .. \"> \")\
\
  term.setCursorPos(cx-3,cy+3)\
  if selected==2 then\
    term.setTextColor(colorass(colors.blue,colors.black))\
    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\
  else\
    term.setTextColor(colorass(colors.lightBlue,colors.white))\
    term.setBackgroundColor(colors.black)\
  end\
  term.write(\" Quit \")\
end\
\
\
local function runMenu()\
  drawMenu()\
\
  while true do\
    local event={os.pullEvent()}\
    if event[1]==\"key\" then\
      local key=event[2]\
      if key==keys.right or key==keys.d and selected==1 then\
        level=math.min(level+1,9)\
        drawMenu()\
      elseif key==keys.left or key==keys.a and selected==1 then\
        level=math.max(level-1,1)\
        drawMenu()\
      elseif key>=keys.one and key<=keys.nine and selected==1 then\
        level=(key-keys.one) + 1\
        drawMenu()\
      elseif key==keys.up or key==keys.w then\
        selected=selected-1\
        if selected==0 then\
          selected=2\
        end\
        drawMenu()\
      elseif key==keys.down or key==keys.s then\
        selected=selected%2+1\
        drawMenu()\
      elseif key==keys.enter or key==keys.space then\
        break --begin play!\
      end\
    end\
  end\
end\
\
while true do\
  runMenu()\
  if selected==2 then\
    break\
  end\
\
  playGame()\
end\
\
\
term.setTextColor(colors.white)\
term.setBackgroundColor(colors.black)\
term.clear()\
term.setCursorPos(1,1)",
      "\
local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: mv <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
local tFiles = fs.find( sSource )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        if fs.isDir( sDest ) then\
            fs.move( sFile, fs.combine( sDest, fs.getName(sFile) ) )\
        elseif #tFiles == 1 then\
            fs.move( sFile, sDest )\
        else\
            printError( \"Cannot overwrite file multiple times\" )\
            return\
        end\
    end\
else\
    printError( \"No matching files\" )\
end",
      "local nTime = os.time()\
local nDay = os.day()\
print( \"The time is \"..textutils.formatTime( nTime, false )..\" on Day \"..nDay )",
      "\
local tArgs = { ... }\
if #tArgs > 2 then\
\009print( \"Usage: alias <alias> <program>\" )\
\009return\
end\
\
local sAlias = tArgs[1]\
local sProgram = tArgs[2]\
\
if sAlias and sProgram then\
\009-- Set alias\
\009shell.setAlias( sAlias, sProgram )\
elseif sAlias then\
\009-- Clear alias\
\009shell.clearAlias( sAlias )\
else\
\009-- List aliases\
\009local tAliases = shell.aliases()\
\009local tList = {}\
\009for sAlias, sCommand in pairs( tAliases ) do\
\009\009table.insert( tList, sAlias )\
\009end\
\009table.sort( tList )\
\009textutils.pagedTabulate( tList )\
end\
\009",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: type <path>\" )\
  \009return\
end\
\
local sPath = shell.resolve( tArgs[1] )\
if fs.exists( sPath ) then\
\009if fs.isDir( sPath ) then\
\009\009print( \"directory\" )\
\009else\
\009\009print( \"file\" )\
\009end\
else\
\009print( \"No such path\" )\
end",
      "\
local function printUsage()\
    print( \"Usage:\" )\
    print( \"wget <url> <filename>\" )\
end\
 \
local tArgs = { ... }\
if #tArgs < 2 then\
    printUsage()\
    return\
end\
 \
if not http then\
    printError( \"wget requires http API\" )\
    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\
    return\
end\
 \
local function get( sUrl )\
    write( \"Connecting to \" .. sUrl .. \"... \" )\
\
    local ok, err = http.checkURL( sUrl )\
    if not ok then\
        print( \"Failed.\" )\
        if err then\
            printError( err )\
        end\
        return nil\
    end\
\
    local response = http.get( sUrl )\
    if not response then\
        print( \"Failed.\" )\
        return nil\
    end\
\
    print( \"Success.\" )\
\
    local sResponse = response.readAll()\
    response.close()\
    return sResponse\
end\
 \
-- Determine file to download\
local sUrl = tArgs[1]\
local sFile = tArgs[2]\
local sPath = shell.resolve( sFile )\
if fs.exists( sPath ) then\
    print( \"File already exists\" )\
    return\
end\
\
-- Do the get\
local res = get( sUrl )\
if res then\
    local file = fs.open( sPath, \"w\" )\
    file.write( res )\
    file.close()\
\
    print( \"Downloaded as \"..sFile )\
end",
      "\
local function printUsage()\
    print( \"Usages:\" )\
    print( \"pastebin put <filename>\" )\
    print( \"pastebin get <code> <filename>\" )\
    print( \"pastebin run <code> <arguments>\" )\
end\
 \
local tArgs = { ... }\
if #tArgs < 2 then\
    printUsage()\
    return\
end\
 \
if not http then\
    printError( \"Pastebin requires http API\" )\
    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\
    return\
end\
 \
local function get(paste)\
    write( \"Connecting to pastebin.com... \" )\
    local response = http.get(\
        \"http://pastebin.com/raw/\"..textutils.urlEncode( paste )\
    )\
        \
    if response then\
        print( \"Success.\" )\
        \
        local sResponse = response.readAll()\
        response.close()\
        return sResponse\
    else\
        print( \"Failed.\" )\
    end\
end\
 \
local sCommand = tArgs[1]\
if sCommand == \"put\" then\
    -- Upload a file to pastebin.com\
    -- Determine file to upload\
    local sFile = tArgs[2]\
    local sPath = shell.resolve( sFile )\
    if not fs.exists( sPath ) or fs.isDir( sPath ) then\
        print( \"No such file\" )\
        return\
    end\
    \
    -- Read in the file\
    local sName = fs.getName( sPath )\
    local file = fs.open( sPath, \"r\" )\
    local sText = file.readAll()\
    file.close()\
    \
    -- POST the contents to pastebin\
    write( \"Connecting to pastebin.com... \" )\
    local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\
    local response = http.post(\
        \"http://pastebin.com/api/api_post.php\", \
        \"api_option=paste&\"..\
        \"api_dev_key=\"..key..\"&\"..\
        \"api_paste_format=lua&\"..\
        \"api_paste_name=\"..textutils.urlEncode(sName)..\"&\"..\
        \"api_paste_code=\"..textutils.urlEncode(sText)\
    )\
        \
    if response then\
        print( \"Success.\" )\
        \
        local sResponse = response.readAll()\
        response.close()\
                \
        local sCode = string.match( sResponse, \"[^/]+$\" )\
        print( \"Uploaded as \"..sResponse )\
        print( \"Run \\\"pastebin get \"..sCode..\"\\\" to download anywhere\" )\
 \
    else\
        print( \"Failed.\" )\
    end\
    \
elseif sCommand == \"get\" then\
    -- Download a file from pastebin.com\
    if #tArgs < 3 then\
        printUsage()\
        return\
    end\
 \
    -- Determine file to download\
    local sCode = tArgs[2]\
    local sFile = tArgs[3]\
    local sPath = shell.resolve( sFile )\
    if fs.exists( sPath ) then\
        print( \"File already exists\" )\
        return\
    end\
    \
    -- GET the contents from pastebin\
    local res = get(sCode)\
    if res then        \
        local file = fs.open( sPath, \"w\" )\
        file.write( res )\
        file.close()\
        \
        print( \"Downloaded as \"..sFile )\
    end \
elseif sCommand == \"run\" then\
    local sCode = tArgs[2]\
 \
    local res = get(sCode)\
    if res then\
        local func, err = load(res, sCode, \"t\", _ENV)\
        if not func then\
            printError( err )\
            return\
        end\
        local success, msg = pcall(func, table.unpack(tArgs, 3))\
        if not success then\
            printError( msg )\
        end\
    end\
else\
    printUsage()\
    return\
end",
      "\
local tArgs = { ... }\
if #tArgs > 0 then\
\009print( \"This is an interactive Lua prompt.\" )\
\009print( \"To run a lua program, just type its name.\" )\
\009return\
end\
\
local bRunning = true\
local tCommandHistory = {}\
local tEnv = {\
\009[\"exit\"] = function()\
\009\009bRunning = false\
\009end,\
\009[\"_echo\"] = function( ... )\
\009    return ...\
\009end,\
}\
setmetatable( tEnv, { __index = _ENV } )\
\
if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Interactive Lua prompt.\" )\
print( \"Call exit() to exit.\" )\
term.setTextColour( colours.white )\
\
while bRunning do\
\009--if term.isColour() then\
\009--\009term.setTextColour( colours.yellow )\
\009--end\
\009write( \"lua> \" )\
\009--term.setTextColour( colours.white )\
\
\009local s = read( nil, tCommandHistory, function( sLine )\
\009\009if settings.get( \"lua.autocomplete\" ) then\
\009\009    local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.]+$\" )\
\009\009    if nStartPos then\
\009\009        sLine = string.sub( sLine, nStartPos )\
\009\009    end\
\009\009    if #sLine > 0 then\
\009            return textutils.complete( sLine, tEnv )\
\009        end\
\009\009end\
        return nil\
\009end )\
\009table.insert( tCommandHistory, s )\
\009\
\009local nForcePrint = 0\
\009local func, e = load( s, \"lua\", \"t\", tEnv )\
\009local func2, e2 = load( \"return _echo(\"..s..\");\", \"lua\", \"t\", tEnv )\
\009if not func then\
\009\009if func2 then\
\009\009\009func = func2\
\009\009\009e = nil\
\009\009\009nForcePrint = 1\
\009\009end\
\009else\
\009\009if func2 then\
\009\009\009func = func2\
\009\009end\
\009end\
\009\
\009if func then\
        local tResults = { pcall( func ) }\
        if tResults[1] then\
        \009local n = 1\
        \009while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do\
        \009    local value = tResults[ n + 1 ]\
        \009    if type( value ) == \"table\" then\
        \009        local metatable = getmetatable( value )\
        \009        if type(metatable) == \"table\" and type(metatable.__tostring) == \"function\" then\
        \009            print( tostring( value ) )\
        \009        else\
                        local ok, serialised = pcall( textutils.serialise, value )\
                        if ok then\
                            print( serialised )\
                        else\
                            print( tostring( value ) )\
                        end\
            \009    end\
            \009else\
            \009    print( tostring( value ) )\
            \009end\
        \009\009n = n + 1\
        \009end\
        else\
        \009printError( tResults[2] )\
        end\
    else\
    \009printError( e )\
    end\
    \
end",
      "if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Goodbye\" )\
term.setTextColour( colours.white )\
\
sleep( 1 )\
os.reboot()",
      "\
local bAll = false\
local tArgs = { ... }\
if #tArgs > 0 and tArgs[1] == \"all\" then\
\009bAll = true\
end\
\
local tPrograms = shell.programs( bAll )\
textutils.pagedTabulate( tPrograms )",
      "\
local tArgs = { ... }\
\
-- Get all the files in the directory\
local sDir = shell.dir()\
if tArgs[1] ~= nil then\
\009sDir = shell.resolve( tArgs[1] )\
end\
\
-- Sort into dirs/files, and calculate column count\
local tAll = fs.list( sDir )\
local tFiles = {}\
local tDirs = {}\
\
local bShowHidden = settings.get( \"list.show_hidden\" )\
for n, sItem in pairs( tAll ) do\
\009if bShowHidden or string.sub( sItem, 1, 1 ) ~= \".\" then\
\009\009local sPath = fs.combine( sDir, sItem )\
\009\009if fs.isDir( sPath ) then\
\009\009\009table.insert( tDirs, sItem )\
\009\009else\
\009\009\009table.insert( tFiles, sItem )\
\009\009end\
\009end\
end\
table.sort( tDirs )\
table.sort( tFiles )\
\
if term.isColour() then\
\009textutils.pagedTabulate( colors.green, tDirs, colors.white, tFiles )\
else\
\009textutils.pagedTabulate( tDirs, tFiles )\
end",
      "\
local tArgs = { ... }\
if #tArgs == 0 then\
\009-- \"set\"\
\009for n,sName in ipairs( settings.getNames() ) do\
\009\009print( textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName)) )\
\009end\
\
elseif #tArgs == 1 then\
\009-- \"set foo\"\
\009local sName = tArgs[1]\
    print( textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName)) )\
\
else\
\009-- \"set foo bar\"\
\009local sName = tArgs[1]\
\009local sValue = tArgs[2]\
\009local value\
\009if sValue == \"true\" then\
\009\009value = true\
\009elseif sValue == \"false\" then\
\009\009value = false\
\009elseif sValue == \"nil\" then\
\009\009value = nil\
\009elseif tonumber(sValue) then\
\009\009value = tonumber(sValue)\
\009else\
\009\009value = sValue\
\009end\
\
\009local oldValue = settings.get( sValue )\
\009if value ~= nil then\
\009\009settings.set( sName, value )\
\009\009print( textutils.serialize(sName) .. \" set to \" .. textutils.serialize(value) )\
\009else\
\009\009settings.unset( sName )\
\009\009print( textutils.serialize(sName) .. \" unset\" )\
\009end\
\009if value ~= oldValue then\
\009\009settings.save( \".settings\" )\
\009end\
end",
      "\
-- Find modems\
local tModems = {}\
for n,sModem in ipairs( peripheral.getNames() ) do\
    if peripheral.getType( sModem ) == \"modem\" then\
        table.insert( tModems, sModem )\
    end\
end\
if #tModems == 0 then\
    print( \"No modems found.\" )\
    return\
elseif #tModems == 1 then\
    print( \"1 modem found.\" )\
else\
    print( #tModems .. \" modems found.\" )\
end\
\
function open( nChannel )\
    for n=1,#tModems do\
        local sModem = tModems[n]\
        peripheral.call( sModem, \"open\", nChannel )\
    end\
end\
\
function close( nChannel )\
    for n=1,#tModems do\
        local sModem = tModems[n]\
        peripheral.call( sModem, \"close\", nChannel )\
    end\
end\
\
-- Open channels\
print( \"0 messages repeated.\" )\
open( rednet.CHANNEL_REPEAT )\
\
-- Main loop (terminate to break)\
local ok, error = pcall( function()\
    local tReceivedMessages = {}\
    local tReceivedMessageTimeouts = {}\
    local nTransmittedMessages = 0\
\
    while true do\
        local sEvent, sModem, nChannel, nReplyChannel, tMessage = os.pullEvent()\
        if sEvent == \"modem_message\" then\
            -- Got a modem message, rebroadcast it if it's a rednet thing\
            if nChannel == rednet.CHANNEL_REPEAT then\
                if type( tMessage ) == \"table\" and tMessage.nMessageID and tMessage.nRecipient then\
                    if not tReceivedMessages[ tMessage.nMessageID ] then\
                        -- Ensure we only repeat a message once\
                        tReceivedMessages[ tMessage.nMessageID ] = true\
                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID\
\
                        -- Send on all other open modems, to the target and to other repeaters\
                        for n=1,#tModems do\
                            local sOtherModem = tModems[n]\
                            peripheral.call( sOtherModem, \"transmit\", rednet.CHANNEL_REPEAT, nReplyChannel, tMessage )\
                            peripheral.call( sOtherModem, \"transmit\", tMessage.nRecipient, nReplyChannel, tMessage )\
                        end\
\
                        -- Log the event\
                        nTransmittedMessages = nTransmittedMessages + 1\
                        local x,y = term.getCursorPos()\
                        term.setCursorPos( 1, y - 1 )\
                        term.clearLine()\
                        if nTransmittedMessages == 1 then\
                            print( nTransmittedMessages .. \" message repeated.\" )\
                        else\
                            print( nTransmittedMessages .. \" messages repeated.\" )\
                        end\
                    end\
                end\
            end\
\
        elseif sEvent == \"timer\" then\
            -- Got a timer event, use it to clear the message history\
            local nTimer = sModem\
            local nMessageID = tReceivedMessageTimeouts[ nTimer ]\
            if nMessageID then\
                tReceivedMessageTimeouts[ nTimer ] = nil\
                tReceivedMessages[ nMessageID ] = nil\
            end\
\
        end\
    end\
end )\
if not ok then\
    printError( error )\
end\
\
-- Close channels\
close( rednet.CHANNEL_REPEAT )",
      "\
local tArgs = { ... }\
\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"chat host <hostname>\" )\
\009print( \"chat join <hostname> <nickname>\" )\
end\
\
local sOpenedModem = nil\
local function openModem()\
    for n,sModem in ipairs( peripheral.getNames() ) do\
        if peripheral.getType( sModem ) == \"modem\" then\
            if not rednet.isOpen( sModem ) then\
                rednet.open( sModem )\
                sOpenedModem = sModem\
            end\
            return true\
        end\
    end\
    print( \"No modems found.\" )\
    return false\
end\
\
local function closeModem()\
    if sOpenedModem ~= nil then\
        rednet.close( sOpenedModem )\
        sOpenedModem = nil\
    end\
end\
\
-- Colours\
local highlightColour, textColour\
if term.isColour() then\
\009textColour = colours.white\
\009highlightColour = colours.yellow\
else\
\009textColour = colours.white\
\009highlightColour = colours.white\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"host\" then\
    -- \"chat host\"\
    -- Get hostname\
    local sHostname = tArgs[2]\
    if sHostname == nil then\
        printUsage()\
        return\
    end\
\
    -- Host server\
    if not openModem() then\
        return\
    end\
    rednet.host( \"chat\", sHostname )\
    print( \"0 users connected.\" )\
\
    local tUsers = {}\
    local nUsers = 0\
    function send( sText, nUserID )\
        if nUserID then\
            local tUser = tUsers[ nUserID ]\
            if tUser then\
                rednet.send( tUser.nID, {\
                    sType = \"text\",\
                    nUserID = nUserID,\
                    sText = sText,\
                }, \"chat\" )\
            end\
        else\
            for nUserID, tUser in pairs( tUsers ) do\
                rednet.send( tUser.nID, {\
                    sType = \"text\",\
                    nUserID = nUserID,\
                    sText = sText,\
                }, \"chat\" )\
            end\
        end\
    end\
\
    -- Setup ping pong\
    local tPingPongTimer = {}\
    function ping( nUserID )\
        local tUser = tUsers[ nUserID ]\
        rednet.send( tUser.nID, {\
            sType = \"ping to client\",\
            nUserID = nUserID,\
        }, \"chat\" )\
\
        local timer = os.startTimer( 15 )\
        tUser.bPingPonged = false\
        tPingPongTimer[ timer ] = nUserID\
    end\
\
    function printUsers()\
        local x,y = term.getCursorPos()\
        term.setCursorPos( 1, y - 1 )\
        term.clearLine()\
        if nUsers == 1 then\
            print( nUsers .. \" user connected.\" )\
        else\
            print( nUsers .. \" users connected.\" )\
        end\
    end\
\
    -- Handle messages\
    local ok, error = pcall( function()\
        parallel.waitForAny( function()\
            while true do\
                local sEvent, timer = os.pullEvent( \"timer\" )\
                local nUserID = tPingPongTimer[ timer ]\
                if nUserID and tUsers[ nUserID ] then\
                    local tUser = tUsers[ nUserID ]\
                    if tUser then\
                        if not tUser.bPingPonged then\
                            send( \"* \"..tUser.sUsername..\" has timed out\" )\
                            tUsers[ nUserID ] = nil\
                            nUsers = nUsers - 1\
                            printUsers()\
                        else\
                            ping( nUserID )\
                        end\
                    end\
                end\
            end\
        end,\
        function()\
            while true do\
                local tCommands\
                tCommands = {\
                    [\"me\"] = function( tUser, sContent )\
                        if string.len(sContent) > 0 then\
                            send( \"* \"..tUser.sUsername..\" \"..sContent )\
                        else\
                            send( \"* Usage: /me [words]\", tUser.nUserID )\
                        end\
                    end,\
                    [\"nick\"] = function( tUser, sContent )\
                        if string.len(sContent) > 0 then\
                            local sOldName = tUser.sUsername\
                            tUser.sUsername = sContent\
                            send( \"* \"..sOldName..\" is now known as \"..tUser.sUsername )\
                        else\
                            send( \"* Usage: /nick [nickname]\", tUser.nUserID )\
                        end\
                    end,\
                    [\"users\"] = function( tUser, sContent )\
                        send( \"* Connected Users:\", tUser.nUserID )\
                        local sUsers = \"*\"\
                        for nUserID, tUser in pairs( tUsers ) do\
                            sUsers = sUsers .. \" \" .. tUser.sUsername\
                        end\
                        send( sUsers, tUser.nUserID )\
                    end,\
                    [\"help\"] = function( tUser, sContent )\
                        send( \"* Available commands:\", tUser.nUserID )\
                        local sCommands = \"*\"\
                        for sCommand, fnCommand in pairs( tCommands ) do\
                            sCommands = sCommands .. \" /\" .. sCommand\
                        end\
                        send( sCommands..\" /logout\", tUser.nUserID )\
                    end,\
                }\
\
                local nSenderID, tMessage = rednet.receive( \"chat\" )\
                if type( tMessage ) == \"table\" then\
                    if tMessage.sType == \"login\" then\
                        -- Login from new client\
                        local nUserID = tMessage.nUserID\
                        local sUsername = tMessage.sUsername\
                        if nUserID and sUsername then\
                            tUsers[ nUserID ] = {\
                                nID = nSenderID,\
                                nUserID = nUserID,\
                                sUsername = sUsername,\
                            }\
                            nUsers = nUsers + 1\
                            printUsers()\
                            send( \"* \"..sUsername..\" has joined the chat\" )\
                            ping( nUserID )\
                        end\
\
                    else\
                        -- Something else from existing client\
                        local nUserID = tMessage.nUserID\
                        local tUser = tUsers[ nUserID ]\
                        if tUser and tUser.nID == nSenderID then\
                            if tMessage.sType == \"logout\" then\
                                send( \"* \"..tUser.sUsername..\" has left the chat\" )\
                                tUsers[ nUserID ] = nil\
                                nUsers = nUsers - 1\
                                printUsers()\
\
                            elseif tMessage.sType == \"chat\" then\
                                local sMessage = tMessage.sText\
                                if sMessage then\
                                    local sCommand = string.match( sMessage, \"^/([a-z]+)\" )\
                                    if sCommand then\
                                        local fnCommand = tCommands[ sCommand ]\
                                        if fnCommand then\
                                            local sContent = string.sub( sMessage, string.len(sCommand)+3 )\
                                            fnCommand( tUser, sContent )\
                                        else\
                                            send( \"* Unrecognised command: /\"..sCommand, tUser.nUserID )\
                                        end\
                                    else\
                                        send( \"<\"..tUser.sUsername..\"> \"..tMessage.sText )\
                                    end\
                                end\
\
                            elseif tMessage.sType == \"ping to server\" then\
                                rednet.send( tUser.nID, {\
                                    sType = \"pong to client\",\
                                    nUserID = nUserID,\
                                }, \"chat\" )\
\
                            elseif tMessage.sType == \"pong to server\" then\
                                tUser.bPingPonged = true\
\
                            end\
                        end\
                    end\
                 end\
            end\
        end )\
    end )\
    if not ok then\
        printError( error )\
    end\
\
    -- Unhost server\
    for nUserID, tUser in pairs( tUsers ) do\
        rednet.send( tUser.nID, {\
            sType = \"kick\",\
            nUserID = nUserID,\
        }, \"chat\" )\
    end\
    rednet.unhost( \"chat\" )\
    closeModem()\
\
elseif sCommand == \"join\" then\
    -- \"chat join\"\
    -- Get hostname and username\
    local sHostname = tArgs[2]\
    local sUsername = tArgs[3]\
    if sHostname == nil or sUsername == nil then\
        printUsage()\
        return\
    end\
\
    -- Connect\
    if not openModem() then\
        return\
    end\
    write( \"Looking up \" .. sHostname .. \"... \" )\
    local nHostID = rednet.lookup( \"chat\", sHostname )\
    if nHostID == nil then\
        print( \"Failed.\" )\
        return\
    else\
        print( \"Success.\" )\
    end\
\
    -- Login\
    local nUserID = math.random( 1, 2147483647 )\
    rednet.send( nHostID, {\
        sType = \"login\",\
        nUserID = nUserID,\
        sUsername = sUsername,\
    }, \"chat\" )\
\
    -- Setup ping pong\
    local bPingPonged = true\
    local pingPongTimer = os.startTimer( 0 )\
\
    function ping()\
        rednet.send( nHostID, {\
            sType = \"ping to server\",\
            nUserID = nUserID,\
        }, \"chat\" )\
        bPingPonged = false\
        pingPongTimer = os.startTimer( 15 )\
    end\
\
    -- Handle messages\
    local w,h = term.getSize()\
    local parentTerm = term.current()\
    local titleWindow = window.create( parentTerm, 1, 1, w, 1, true )\
    local historyWindow = window.create( parentTerm, 1, 2, w, h-2, true )\
    local promptWindow = window.create( parentTerm, 1, h, w, 1, true )\
    historyWindow.setCursorPos( 1, h-2 )\
\
    term.clear()\
    term.setTextColour( textColour )\
    term.redirect( promptWindow )\
    promptWindow.restoreCursor()\
\
    function drawTitle()\
        local x,y = titleWindow.getCursorPos()\
        local w,h = titleWindow.getSize()\
        local sTitle = sUsername..\" on \"..sHostname\
        titleWindow.setTextColour( highlightColour )\
        titleWindow.setCursorPos( math.floor( w/2 - string.len(sTitle)/2 ), 1 )\
        titleWindow.clearLine()\
        titleWindow.write( sTitle )\
        promptWindow.restoreCursor()\
    end\
\
    function printMessage( sMessage )\
        term.redirect( historyWindow )\
        print()\
        if string.match( sMessage, \"^\\*\" ) then\
            -- Information\
            term.setTextColour( highlightColour )\
            write( sMessage )\
            term.setTextColour( textColour )\
        else\
            -- Chat\
            local sUsernameBit = string.match( sMessage, \"^\\<[^\\>]*\\>\" )\
            if sUsernameBit then\
                term.setTextColour( highlightColour )\
                write( sUsernameBit )\
                term.setTextColour( textColour )\
                write( string.sub( sMessage, string.len( sUsernameBit ) + 1 ) )\
            else\
                write( sMessage )\
            end\
        end\
        term.redirect( promptWindow )\
        promptWindow.restoreCursor()\
    end\
\
    drawTitle()\
\
    local ok, error = pcall( function()\
        parallel.waitForAny( function()\
            while true do\
                local sEvent, timer = os.pullEvent()\
                if sEvent == \"timer\" then\
                    if timer == pingPongTimer then\
                        if not bPingPonged then\
                            printMessage( \"Server timeout.\" )\
                            return\
                        else\
                            ping()\
                        end\
                    end\
\
                elseif sEvent == \"term_resize\" then\
                    local w,h = parentTerm.getSize()\
                    titleWindow.reposition( 1, 1, w, 1 )\
                    historyWindow.reposition( 1, 2, w, h-2 )\
                    promptWindow.reposition( 1, h, w, 1 )\
\
                end\
            end\
        end,\
        function()\
            while true do\
                local nSenderID, tMessage = rednet.receive( \"chat\" )\
                if nSenderID == nHostID and type( tMessage ) == \"table\" and tMessage.nUserID == nUserID then\
                    if tMessage.sType == \"text\" then\
                        local sText = tMessage.sText\
                        if sText then\
                            printMessage( sText )\
                        end\
\
                    elseif tMessage.sType == \"ping to client\" then\
                        rednet.send( nSenderID, {\
                            sType = \"pong to server\",\
                            nUserID = nUserID,\
                        }, \"chat\" )\
\
                    elseif tMessage.sType == \"pong to client\" then\
                        bPingPonged = true\
\
                    elseif tMessage.sType == \"kick\" then\
                        return\
\
                    end\
                end\
            end\
        end,\
        function()\
            local tSendHistory = {}\
            while true do\
                promptWindow.setCursorPos( 1,1 )\
                promptWindow.clearLine()\
                promptWindow.setTextColor( highlightColour )\
                promptWindow.write( \": \")\
                promptWindow.setTextColor( textColour )\
\
                local sChat = read( nil, tSendHistory )\
                if string.match( sChat, \"^/logout\" ) then\
                    break\
                else\
                    rednet.send( nHostID, {\
                        sType = \"chat\",\
                        nUserID = nUserID,\
                        sText = sChat,\
                    }, \"chat\" )\
                    table.insert( tSendHistory, sChat )\
                end\
            end\
        end )\
    end )\
\
    -- Close the windows\
    term.redirect( parentTerm )\
\
    -- Print error notice\
    local w,h = term.getSize()\
    term.setCursorPos( 1, h )\
    term.clearLine()\
    term.setCursorBlink( false )\
    if not ok then\
        printError( error )\
    end\
\
    -- Logout\
    rednet.send( nHostID, {\
        sType = \"logout\",\
        nUserID = nUserID,\
    }, \"chat\" )\
    closeModem()\
\
    -- Print disconnection notice\
    print( \"Disconnected.\" )\
\
else\
    -- \"chat somethingelse\"\
    printUsage()\
\
end",
      "\
local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: rm <path>\" )\
\009return\
end\
\
local sPath = shell.resolve( tArgs[1] )\
local tFiles = fs.find( sPath )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        fs.delete( sFile )\
    end\
else\
    printError( \"No matching files\" )\
end",
      "\
local tArgs = { ... }\
\
local function printUsage()\
    print( \"Usages:\" )\
    print( \"redstone probe\" )\
    print( \"redstone set <side> <value>\" )\
    print( \"redstone set <side> <color> <value>\" )\
    print( \"redstone pulse <side> <count> <period>\" )\
end\
\
local sCommand = tArgs[1]\
if sCommand == \"probe\" then\
    -- \"redstone probe\"\
    -- Regular input\
    print( \"Redstone inputs: \" )\
\
    local count = 0\
    local bundledCount = 0\
    for n,sSide in ipairs( redstone.getSides() ) do\
        if redstone.getBundledInput( sSide ) > 0 then\
            bundledCount = bundledCount + 1\
        end\
        if redstone.getInput( sSide ) then\
            if count > 0 then\
                io.write( \", \" )\
            end\
            io.write( sSide )\
            count = count + 1\
        end\
    end\
    if count > 0 then\
        print( \".\" )\
    else\
        print( \"None.\" )\
    end\
\
    -- Bundled input\
    if bundledCount > 0 then\
        print()\
        print( \"Bundled inputs:\" )\
        for i,sSide in ipairs( redstone.getSides() ) do\
            local nInput = redstone.getBundledInput( sSide )\
            if nInput ~= 0 then\
                write( sSide..\": \" )\
                local count = 0\
                for sColour,nColour in pairs( colors ) do\
                    if type( nColour ) == \"number\" and colors.test( nInput, nColour ) then\
                        if count > 0 then\
                            write( \", \" )\
                        end\
                        if term.isColour() then\
                            term.setTextColour( nColour )\
                        end\
                        write( sColour )\
                        if term.isColour() then\
                            term.setTextColour( colours.white )\
                        end\
                        count = count + 1\
                    end\
                end\
                print( \".\" )\
            end\
        end\
    end\
\
elseif sCommand == \"pulse\" then\
    -- \"redstone pulse\"\
    local sSide = tArgs[2]\
    local nCount = tonumber( tArgs[3] ) or 1\
    local nPeriod = tonumber( tArgs[4] ) or 0.5\
    for n=1,nCount do\
        redstone.setOutput( sSide, true )\
        sleep( nPeriod / 2 )\
        redstone.setOutput( sSide, false )\
        sleep( nPeriod / 2 )\
    end\
\
elseif sCommand == \"set\" then\
    -- \"redstone set\"\
    local sSide = tArgs[2]\
    if #tArgs > 3 then\
        -- Bundled cable output\
        local sColour = tArgs[3]\
        local nColour = colors[sColour] or colours[sColour]\
        if type(nColour) ~= \"number\" then\
            printError( \"No such color\" )\
            return\
        end\
\
        local sValue = tArgs[4]\
        if sValue == \"true\" then\
            rs.setBundledOutput( sSide, colors.combine( rs.getBundledOutput( sSide ), nColour ) )\
        elseif sValue == \"false\" then\
            rs.setBundledOutput( sSide, colors.subtract( rs.getBundledOutput( sSide ), nColour ) )\
        else\
            print( \"Value must be boolean\" )\
        end\
    else\
        -- Regular output\
        local sValue = tArgs[3]\
        local nValue = tonumber(sValue)\
        if sValue == \"true\" then\
            rs.setOutput( sSide, true )\
        elseif sValue == \"false\" then\
            rs.setOutput( sSide, false )\
        elseif nValue and nValue >= 0 and nValue <= 15 then\
            rs.setAnalogOutput( sSide, nValue )\
        else\
            print( \"Value must be boolean or 0-15\" )\
        end\
    end\
\
else\
    -- Something else\
    printUsage()\
\
end",
      "\
-- Setup process switching\
local parentTerm = term.current()\
local w,h = parentTerm.getSize()\
\
local tProcesses = {}\
local nCurrentProcess = nil\
local nRunningProcess = nil\
local bShowMenu = false\
local bWindowsResized = false\
\
local function selectProcess( n )\
    if nCurrentProcess ~= n then\
        if nCurrentProcess then\
            local tOldProcess = tProcesses[ nCurrentProcess ]\
            tOldProcess.window.setVisible( false )\
        end\
        nCurrentProcess = n\
        if nCurrentProcess then\
            local tNewProcess = tProcesses[ nCurrentProcess ]\
            tNewProcess.window.setVisible( true )\
            tNewProcess.bInteracted = true\
        end\
    end\
end\
\
local function setProcessTitle( n, sTitle )\
    tProcesses[ n ].sTitle = sTitle\
end\
\
local function resumeProcess( nProcess, sEvent, ... )\
    local tProcess = tProcesses[ nProcess ]\
    local sFilter = tProcess.sFilter\
    if sFilter == nil or sFilter == sEvent or sEvent == \"terminate\" then\
        local nPreviousProcess = nRunningProcess\
        nRunningProcess = nProcess\
        term.redirect( tProcess.terminal )\
        local ok, result = coroutine.resume( tProcess.co, sEvent, ... )\
        tProcess.terminal = term.current()\
        if ok then\
            tProcess.sFilter = result\
        else\
            printError( result )\
        end\
        nRunningProcess = nPreviousProcess\
    end\
end\
\
local function launchProcess( tProgramEnv, sProgramPath, ... )\
    local tProgramArgs = { ... }\
    local nProcess = #tProcesses + 1\
    local tProcess = {}\
    tProcess.sTitle = fs.getName( sProgramPath )\
    if bShowMenu then\
        tProcess.window = window.create( parentTerm, 1, 2, w, h-1, false )\
    else\
        tProcess.window = window.create( parentTerm, 1, 1, w, h, false )\
    end\
    tProcess.co = coroutine.create( function()\
        os.run( tProgramEnv, sProgramPath, table.unpack( tProgramArgs ) )\
        if not tProcess.bInteracted then\
            term.setCursorBlink( false )\
            print( \"Press any key to continue\" )\
            os.pullEvent( \"char\" )\
        end\
    end )\
    tProcess.sFilter = nil\
    tProcess.terminal = tProcess.window\
    tProcess.bInteracted = false\
    tProcesses[ nProcess ] = tProcess\
    resumeProcess( nProcess )\
    return nProcess\
end\
\
local function cullProcess( nProcess )\
    local tProcess = tProcesses[ nProcess ]\
    if coroutine.status( tProcess.co ) == \"dead\" then\
        if nCurrentProcess == nProcess then\
            selectProcess( nil )\
        end\
        table.remove( tProcesses, nProcess )\
        if nCurrentProcess == nil then\
            if nProcess > 1 then\
                selectProcess( nProcess - 1 )\
            elseif #tProcesses > 0 then\
                selectProcess( 1 )\
            end\
        end\
        return true\
    end\
    return false\
end\
\
local function cullProcesses()\
    local culled = false\
    for n=#tProcesses,1,-1 do\
        culled = culled or cullProcess( n )\
    end\
    return culled\
end\
\
-- Setup the main menu\
local menuMainTextColor, menuMainBgColor, menuOtherTextColor, menuOtherBgColor\
if parentTerm.isColor() then\
    menuMainTextColor, menuMainBgColor = colors.yellow, colors.black\
    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\
else\
    menuMainTextColor, menuMainBgColor = colors.white, colors.black\
    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\
end\
\
local function redrawMenu()\
    if bShowMenu then\
        -- Draw menu\
        parentTerm.setCursorPos( 1, 1 )\
        parentTerm.setBackgroundColor( menuOtherBgColor )\
        parentTerm.clearLine()\
        for n=1,#tProcesses do\
            if n == nCurrentProcess then\
                parentTerm.setTextColor( menuMainTextColor )\
                parentTerm.setBackgroundColor( menuMainBgColor )\
            else\
                parentTerm.setTextColor( menuOtherTextColor )\
                parentTerm.setBackgroundColor( menuOtherBgColor )\
            end\
            parentTerm.write( \" \" .. tProcesses[n].sTitle .. \" \" )\
        end\
\
        -- Put the cursor back where it should be\
        local tProcess = tProcesses[ nCurrentProcess ]\
        if tProcess then\
            tProcess.window.restoreCursor()\
        end\
    end\
end\
\
local function resizeWindows()\
    local windowY, windowHeight\
    if bShowMenu then\
        windowY = 2\
        windowHeight = h-1\
    else\
        windowY = 1\
        windowHeight = h\
    end\
    for n=1,#tProcesses do\
        local tProcess = tProcesses[n]\
        local window = tProcess.window\
        local x,y = tProcess.window.getCursorPos()\
        if y > windowHeight then\
            tProcess.window.scroll( y - windowHeight )\
            tProcess.window.setCursorPos( x, windowHeight )\
        end\
        tProcess.window.reposition( 1, windowY, w, windowHeight )\
    end\
    bWindowsResized = true\
end\
\
local function setMenuVisible( bVis )\
    if bShowMenu ~= bVis then\
        bShowMenu = bVis\
        resizeWindows()\
        redrawMenu()\
    end\
end\
\
local multishell = {}\
\
function multishell.getFocus()\
    return nCurrentProcess\
end\
\
function multishell.setFocus( n )\
    if n >= 1 and n <= #tProcesses then\
        selectProcess( n )\
        redrawMenu()\
        return true\
    end\
    return false\
end\
\
function multishell.getTitle( n )\
    if n >= 1 and n <= #tProcesses then\
        return tProcesses[n].sTitle\
    end\
    return nil\
end\
\
function multishell.setTitle( n, sTitle )\
    if n >= 1 and n <= #tProcesses then\
        setProcessTitle( n, sTitle )\
        redrawMenu()\
    end\
end\
\
function multishell.getCurrent()\
    return nRunningProcess\
end\
\
function multishell.launch( tProgramEnv, sProgramPath, ... )\
    local previousTerm = term.current()\
    setMenuVisible( (#tProcesses + 1) >= 2 )\
    local nResult = launchProcess( tProgramEnv, sProgramPath, ... )\
    redrawMenu()\
    term.redirect( previousTerm )\
    return nResult\
end\
\
function multishell.getCount()\
    return #tProcesses\
end\
\
-- Begin\
parentTerm.clear()\
setMenuVisible( false )\
selectProcess( launchProcess( {\
    [\"shell\"] = shell,\
    [\"multishell\"] = multishell,\
}, \"/rom/programs/shell\" ) )\
redrawMenu()\
\
-- Run processes\
while #tProcesses > 0 do\
    -- Get the event\
    local tEventData = { os.pullEventRaw() }\
    local sEvent = tEventData[1]\
    if sEvent == \"term_resize\" then\
        -- Resize event\
        w,h = parentTerm.getSize()\
        resizeWindows()\
        redrawMenu()\
\
    elseif sEvent == \"char\" or sEvent == \"key\" or sEvent == \"key_up\" or sEvent == \"paste\" or sEvent == \"terminate\" then\
        -- Keyboard event\
        -- Passthrough to current process\
        resumeProcess( nCurrentProcess, table.unpack( tEventData ) )\
        if cullProcess( nCurrentProcess ) then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
\
    elseif sEvent == \"mouse_click\" then\
        -- Click event\
        local button, x, y = tEventData[2], tEventData[3], tEventData[4]\
        if bShowMenu and y == 1 then\
            -- Switch process\
            local tabStart = 1\
            for n=1,#tProcesses do\
                tabEnd = tabStart + string.len( tProcesses[n].sTitle ) + 1\
                if x >= tabStart and x <= tabEnd then\
                    selectProcess( n )\
                    redrawMenu()\
                    break\
                end\
                tabStart = tabEnd + 1\
            end\
        else\
            -- Passthrough to current process\
            resumeProcess( nCurrentProcess, sEvent, button, x, (bShowMenu and y-1) or y )\
            if cullProcess( nCurrentProcess ) then\
                setMenuVisible( #tProcesses >= 2 )\
                redrawMenu()\
            end\
        end\
\
    elseif sEvent == \"mouse_drag\" or sEvent == \"mouse_up\" or sEvent == \"mouse_scroll\" then\
        -- Other mouse event\
        local p1, x, y = tEventData[2], tEventData[3], tEventData[4]\
        if not (bShowMenu and y == 1) then\
            -- Passthrough to current process\
            resumeProcess( nCurrentProcess, sEvent, p1, x, (bShowMenu and y-1) or y )\
            if cullProcess( nCurrentProcess ) then\
                setMenuVisible( #tProcesses >= 2 )\
                redrawMenu()\
            end\
        end\
\
    else\
        -- Other event\
        -- Passthrough to all processes\
        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\
        for n=1,nLimit do\
            resumeProcess( n, table.unpack( tEventData ) )\
        end\
        if cullProcesses() then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
    end\
\
    if bWindowsResized then\
        -- Pass term_resize to all processes\
        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\
        for n=1,nLimit do\
            resumeProcess( n, \"term_resize\" )\
        end\
        bWindowsResized = false\
        if cullProcesses() then\
            setMenuVisible( #tProcesses >= 2 )\
            redrawMenu()\
        end\
    end\
end\
\
-- Shutdown\
term.redirect( parentTerm )",
      "\
if not shell.openTab then\
\009printError( \"Requires multishell\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    shell.openTab( table.unpack( tArgs ) )\
else\
    shell.openTab( \"shell\" )\
end",
      "\
if not shell.openTab then\
\009printError( \"Requires multishell\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    local nTask = shell.openTab( table.unpack( tArgs ) )\
    if nTask then\
        shell.switchTab( nTask )\
    end\
else\
    local nTask = shell.openTab( \"shell\" )\
    if nTask then\
        shell.switchTab( nTask )\
    end\
end",
      "-- Get file to edit\
local tArgs = { ... }\
if #tArgs == 0 then\
\009print( \"Usage: edit <path>\" )\
\009return\
end\
\
-- Error checking\
local sPath = shell.resolve( tArgs[1] )\
local bReadOnly = fs.isReadOnly( sPath )\
if fs.exists( sPath ) and fs.isDir( sPath ) then\
\009print( \"Cannot edit a directory.\" )\
\009return\
end\
\
local x,y = 1,1\
local w,h = term.getSize()\
local scrollX, scrollY = 0,0\
\
local tLines = {}\
local bRunning = true\
\
-- Colours\
local highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour\
if term.isColour() then\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.yellow\
\009keywordColour = colours.yellow\
\009commentColour = colours.green\
\009stringColour = colours.red\
else\
\009bgColour = colours.black\
\009textColour = colours.white\
\009highlightColour = colours.white\
\009keywordColour = colours.white\
\009commentColour = colours.white\
\009stringColour = colours.white\
end\
\
-- Menus\
local bMenu = false\
local nMenuItem = 1\
local tMenuItems = {}\
if not bReadOnly then\
    table.insert( tMenuItems, \"Save\" )\
end\
if shell.openTab then\
    table.insert( tMenuItems, \"Run\" )\
end\
if peripheral.find( \"printer\" ) then\
    table.insert( tMenuItems, \"Print\" )\
end\
table.insert( tMenuItems, \"Exit\" )\
\
local sStatus = \"Press Ctrl to access menu\"\
if string.len( sStatus ) > w - 5 then\
    sStatus = \"Press Ctrl for menu\"\
end\
\
local function load( _sPath )\
\009tLines = {}\
\009if fs.exists( _sPath ) then\
\009\009local file = io.open( _sPath, \"r\" )\
\009\009local sLine = file:read()\
\009\009while sLine do\
\009\009\009table.insert( tLines, sLine )\
\009\009\009sLine = file:read()\
\009\009end\
\009\009file:close()\
\009end\
\009\
\009if #tLines == 0 then\
\009\009table.insert( tLines, \"\" )\
\009end\
end\
\
local function save( _sPath )\
\009-- Create intervening folder\
\009local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len() )\
\009if not fs.exists( sDir ) then\
\009\009fs.makeDir( sDir )\
\009end\
\
\009-- Save\
\009local file = nil\
\009local function innerSave()\
\009\009file = fs.open( _sPath, \"w\" )\
\009\009if file then\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009file.write( sLine .. \"\\n\" )\
\009\009\009end\
\009\009else\
\009\009\009error( \"Failed to open \".._sPath )\
\009\009end\
\009end\
\009\
\009local ok, err = pcall( innerSave )\
\009if file then \
\009\009file.close()\
\009end\
\009return ok, err\
end\
\
local tKeywords = {\
\009[\"and\"] = true,\
\009[\"break\"] = true,\
\009[\"do\"] = true,\
\009[\"else\"] = true,\
\009[\"elseif\"] = true,\
\009[\"end\"] = true,\
\009[\"false\"] = true,\
\009[\"for\"] = true,\
\009[\"function\"] = true,\
\009[\"if\"] = true,\
\009[\"in\"] = true,\
\009[\"local\"] = true,\
\009[\"nil\"] = true,\
\009[\"not\"] = true,\
\009[\"or\"] = true,\
\009[\"repeat\"] = true,\
\009[\"return\"] = true,\
\009[\"then\"] = true,\
\009[\"true\"] = true,\
\009[\"until\"]= true,\
\009[\"while\"] = true,\
}\
\
local function tryWrite( sLine, regex, colour )\
\009local match = string.match( sLine, regex )\
\009if match then\
\009\009if type(colour) == \"number\" then\
\009\009\009term.setTextColour( colour )\
\009\009else\
\009\009\009term.setTextColour( colour(match) )\
\009\009end\
\009\009term.write( match )\
\009\009term.setTextColour( textColour )\
\009\009return string.sub( sLine, string.len(match) + 1 )\
\009end\
\009return nil\
end\
\
local function writeHighlighted( sLine )\
\009while string.len(sLine) > 0 do\009\
\009\009sLine = \
\009\009\009tryWrite( sLine, \"^%-%-%[%[.-%]%]\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^%-%-.*\", commentColour ) or\
\009\009\009tryWrite( sLine, \"^\\\"\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\\".-[^\\\\]\\\"\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^\\'.-[^\\\\]\\'\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^%[%[.-%]%]\", stringColour ) or\
\009\009\009tryWrite( sLine, \"^[%w_]+\", function( match )\
\009\009\009\009if tKeywords[ match ] then\
\009\009\009\009\009return keywordColour\
\009\009\009\009end\
\009\009\009\009return textColour\
\009\009\009end ) or\
\009\009\009tryWrite( sLine, \"^[^%w_]\", textColour )\
\009end\
end\
\
local tCompletions\
local nCompletion\
\
local tCompleteEnv = _ENV\
local function complete( sLine )\
\009if settings.get( \"edit.autocomplete\" ) then\
\009    local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.]+$\" )\
\009    if nStartPos then\
\009        sLine = string.sub( sLine, nStartPos )\
\009    end\
\009    if #sLine > 0 then\
\009        return textutils.complete( sLine, tCompleteEnv )\
\009    end\
\009end\
    return nil\
end\
\
local function recomplete()\
    local sLine = tLines[y]\
    if not bMenu and not bReadOnly and x == string.len(sLine) + 1 then\
        tCompletions = complete( sLine )\
        if tCompletions and #tCompletions > 0 then\
            nCompletion = 1\
        else\
            nCompletion = nil\
        end\
    else\
        tCompletions = nil\
        nCompletion = nil\
    end\
end\
\
local function writeCompletion( sLine )\
    if nCompletion then\
        local sCompletion = tCompletions[ nCompletion ]\
        term.setTextColor( colours.white )\
        term.setBackgroundColor( colours.grey )\
        term.write( sCompletion )\
        term.setTextColor( textColour )\
        term.setBackgroundColor( bgColour )\
    end\
end\
\
local function redrawText()\
    local cursorX, cursorY = x, y\
\009for y=1,h-1 do\
\009\009term.setCursorPos( 1 - scrollX, y )\
\009\009term.clearLine()\
\
\009\009local sLine = tLines[ y + scrollY ]\
\009\009if sLine ~= nil then\
\009\009\009writeHighlighted( sLine )\
            if cursorY == y and cursorX == #sLine + 1 then\
                writeCompletion()\
            end\
\009\009end\
\009end\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local function redrawLine(_nY)\
\009local sLine = tLines[_nY]\
\009if sLine then\
        term.setCursorPos( 1 - scrollX, _nY - scrollY )\
        term.clearLine()\
        writeHighlighted( sLine )\
        if _nY == y and x == #sLine + 1 then\
            writeCompletion()\
        end\
        term.setCursorPos( x - scrollX, _nY - scrollY )\
    end\
end\
\
local function redrawMenu()\
    -- Clear line\
    term.setCursorPos( 1, h )\
\009term.clearLine()\
\
    -- Draw line numbers\
    term.setCursorPos( w - string.len( \"Ln \"..y ) + 1, h )\
    term.setTextColour( highlightColour )\
    term.write( \"Ln \" )\
    term.setTextColour( textColour )\
    term.write( y )\
\
    term.setCursorPos( 1, h )\
\009if bMenu then\
        -- Draw menu\
\009\009term.setTextColour( textColour )\
\009\009for nItem,sItem in pairs( tMenuItems ) do\
\009\009\009if nItem == nMenuItem then\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"[\" )\
\009\009\009\009term.setTextColour( textColour )\
\009\009\009\009term.write( sItem )\
\009\009\009\009term.setTextColour( highlightColour )\
\009\009\009\009term.write( \"]\" )\
        \009\009term.setTextColour( textColour )\
\009\009\009else\
\009\009\009\009term.write( \" \"..sItem..\" \" )\
\009\009\009end\
\009\009end\
    else\
        -- Draw status\
        term.setTextColour( highlightColour )\
        term.write( sStatus )\
        term.setTextColour( textColour )\
    end\
\
\009-- Reset cursor\
\009term.setCursorPos( x - scrollX, y - scrollY )\
end\
\
local tMenuFuncs = { \
\009Save = function()\
\009\009if bReadOnly then\
\009\009\009sStatus = \"Access denied\"\
\009\009else\
\009\009\009local ok, err = save( sPath )\
\009\009\009if ok then\
\009\009\009\009sStatus=\"Saved to \"..sPath\
\009\009\009else\
\009\009\009\009sStatus=\"Error saving to \"..sPath\
\009\009\009end\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Print = function()\
\009\009local printer = peripheral.find( \"printer\" )\
\009\009if not printer then\
\009\009\009sStatus = \"No printer attached\"\
\009\009\009return\
\009\009end\
\
\009\009local nPage = 0\
\009\009local sName = fs.getName( sPath )\
\009\009if printer.getInkLevel() < 1 then\
\009\009\009sStatus = \"Printer out of ink\"\
\009\009\009return\
\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009sStatus = \"Printer out of paper\"\
\009\009\009return\
\009\009end\
\
\009\009local screenTerminal = term.current()\
\009\009local printerTerminal = {\
\009\009\009getCursorPos = printer.getCursorPos,\
\009\009\009setCursorPos = printer.setCursorPos,\
\009\009\009getSize = printer.getPageSize,\
\009\009\009write = printer.write,\
\009\009}\
\009\009printerTerminal.scroll = function()\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\009\009\009\
\009\009\009end\
\009\009\009\
\009\009\009while not printer.newPage()\009do\
\009\009\009\009if printer.getInkLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of ink, please refill\"\
\009\009\009\009elseif printer.getPaperLevel() < 1 then\
\009\009\009\009\009sStatus = \"Printer out of paper, please refill\"\
\009\009\009\009else\
\009\009\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009\009end\
\009\
\009\009\009\009term.redirect( screenTerminal )\
\009\009\009\009redrawMenu()\
\009\009\009\009term.redirect( printerTerminal )\
\009\009\009\009\
\009\009\009\009local timer = os.startTimer(0.5)\
\009\009\009\009sleep(0.5)\
\009\009\009end\
\
\009\009\009nPage = nPage + 1\
\009\009\009if nPage == 1 then\
\009\009\009\009printer.setPageTitle( sName )\
\009\009\009else\
\009\009\009\009printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\
\009\009\009end\
\009\009end\
\009\009\
\009\009bMenu = false\
\009\009term.redirect( printerTerminal )\
\009\009local ok, error = pcall( function()\
\009\009\009term.scroll()\
\009\009\009for n, sLine in ipairs( tLines ) do\
\009\009\009\009print( sLine )\
\009\009\009end\
\009\009end )\
        term.redirect( screenTerminal )\
\009\009if not ok then\
\009\009\009print( error )\
\009\009end\
\009\009\
\009\009while not printer.endPage() do\
\009\009\009sStatus = \"Printer output tray full, please empty\"\
\009\009\009redrawMenu()\
\009\009\009sleep( 0.5 )\
\009\009end\
\009\009bMenu = true\
\009\009\009\
\009\009if nPage > 1 then\
\009\009\009sStatus = \"Printed \"..nPage..\" Pages\"\
\009\009else\
\009\009\009sStatus = \"Printed 1 Page\"\
\009\009end\
\009\009redrawMenu()\
\009end,\
\009Exit = function()\
\009\009bRunning = false\
\009end,\
\009Run = function()\
\009    local sTempPath = \"/.temp\"\
        local ok, err = save( sTempPath )\
        if ok then\
            local nTask = shell.openTab( sTempPath )\
            if nTask then\
                shell.switchTab( nTask )\
            else\
                sStatus=\"Error starting Task\"\
            end\
            fs.delete( sTempPath )\
        else\
            sStatus=\"Error saving to \"..sTempPath\
        end\
\009\009redrawMenu()\
    end\
}\
\
local function doMenuItem( _n )\
\009tMenuFuncs[tMenuItems[_n]]()\
\009if bMenu then\
\009\009bMenu = false\
\009\009term.setCursorBlink( true )\
\009end\
\009redrawMenu()\
end\
\
local function setCursor( newX, newY )\
    local oldX, oldY = x, y\
    x, y = newX, newY\
\009local screenX = x - scrollX\
\009local screenY = y - scrollY\
\009\
\009local bRedraw = false\
\009if screenX < 1 then\
\009\009scrollX = x - 1\
\009\009screenX = 1\
\009\009bRedraw = true\
\009elseif screenX > w then\
\009\009scrollX = x - w\
\009\009screenX = w\
\009\009bRedraw = true\
\009end\
\009\
\009if screenY < 1 then\
\009\009scrollY = y - 1\
\009\009screenY = 1\
\009\009bRedraw = true\
\009elseif screenY > h-1 then\
\009\009scrollY = y - (h-1)\
\009\009screenY = h-1\
\009\009bRedraw = true\
\009end\
\
\009recomplete()\
\009if bRedraw then\
\009\009redrawText()\
\009elseif y ~= oldY then\
\009    redrawLine( oldY )\
\009    redrawLine( y )\
\009else\
\009    redrawLine( y )\
\009end\
\009term.setCursorPos( screenX, screenY )\
\
\009redrawMenu()\
end\
\
-- Actual program functionality begins\
load(sPath)\
\
term.setBackgroundColour( bgColour )\
term.clear()\
term.setCursorPos(x,y)\
term.setCursorBlink( true )\
\
recomplete()\
redrawText()\
redrawMenu()\
\
local function acceptCompletion()\
    if nCompletion then\
        -- Append the completion\
        local sCompletion = tCompletions[ nCompletion ]\
        tLines[y] = tLines[y] .. sCompletion\
        setCursor( x + string.len( sCompletion ), y )\
    end\
end\
\
-- Handle input\
while bRunning do\
\009local sEvent, param, param2, param3 = os.pullEvent()\
\009if sEvent == \"key\" then\
\009    local oldX, oldY = x, y\
\009\009if param == keys.up then\
\009\009\009-- Up\
\009\009\009if not bMenu then\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion - 1\
                    if nCompletion < 1 then\
                        nCompletion = #tCompletions\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009setCursor(\
\009\009\009\009\009    math.min( x, string.len( tLines[y - 1] ) + 1 ),\
\009\009\009\009\009    y - 1\
\009\009\009\009\009)\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.down then\
\009\009\009-- Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor down\
\009\009\009    if nCompletion then\
\009\009\009        -- Cycle completions\
                    nCompletion = nCompletion + 1\
                    if nCompletion > #tCompletions then\
                        nCompletion = 1\
                    end\
                    redrawLine(y)\
\
\009\009\009\009elseif y < #tLines then\
\009\009\009\009    -- Move cursor down\
\009\009\009\009\009setCursor(\
                        math.min( x, string.len( tLines[y + 1] ) + 1 ),\
                        y + 1\
                    )\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.tab then\
\009\009\009-- Tab\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    if nCompletion and x == string.len(tLines[y]) + 1 then\
\009\009\009        -- Accept autocomplete\
                    acceptCompletion()\
                else\
                    -- Indent line\
                    local sLine = tLines[y]\
                    tLines[y] = string.sub(sLine,1,x-1) .. \"  \" .. string.sub(sLine,x)\
                    setCursor( x + 2, y )\
                end\
\009\009\009end\
\
\009\009elseif param == keys.pageUp then\
\009\009\009-- Page Up\
\009\009\009if not bMenu then\
\009\009\009\009-- Move up a page\
\009\009\009\009local newY\
\009\009\009\009if y - (h - 1) >= 1 then\
\009\009\009\009\009newY = y - (h - 1)\
\009\009\009\009else\
\009\009\009\009    newY = 1\
\009\009\009\009end\
                setCursor(\
\009\009\009\009    math.min( x, string.len( tLines[newY] ) + 1 ),\
\009\009\009\009    newY\
\009\009\009\009)\
\009\009\009end\
\
\009\009elseif param == keys.pageDown then\
\009\009\009-- Page Down\
\009\009\009if not bMenu then\
\009\009\009\009-- Move down a page\
\009\009\009\009local newY\
\009\009\009\009if y + (h - 1) <= #tLines then\
\009\009\009\009\009newY = y + (h - 1)\
\009\009\009\009else\
\009\009\009\009\009newY = #tLines\
\009\009\009\009end\
\009\009\009\009local newX = math.min( x, string.len( tLines[newY] ) + 1 )\
\009\009\009\009setCursor( newX, newY )\
\009\009\009end\
\
\009\009elseif param == keys.home then\
\009\009\009-- Home\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the beginning\
\009\009\009\009if x > 1 then\
                    setCursor(1,y)\
                end\
\009\009\009end\
\
\009\009elseif param == keys[\"end\"] then\
\009\009\009-- End\
\009\009\009if not bMenu then\
\009\009\009\009-- Move cursor to the end\
\009\009\009\009local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
    \009\009\009\009setCursor( nLimit, y )\
    \009\009    end\
\009\009\009end\
\
\009\009elseif param == keys.left then\
\009\009\009-- Left\
\009\009\009if not bMenu then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Move cursor left\
    \009\009\009\009setCursor( x - 1, y )\
\009\009\009\009elseif x==1 and y>1 then\
    \009\009\009\009setCursor( string.len( tLines[y-1] ) + 1, y - 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu left\
\009\009\009\009nMenuItem = nMenuItem - 1\
\009\009\009\009if nMenuItem < 1 then\
\009\009\009\009\009nMenuItem = #tMenuItems\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.right then\
\009\009\009-- Right\
\009\009\009if not bMenu then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009-- Move cursor right\
\009\009\009\009\009setCursor( x + 1, y )\
\009\009\009    elseif nCompletion and x == string.len(tLines[y]) + 1 then\
                    -- Accept autocomplete\
                    acceptCompletion()\
\009\009\009\009elseif x==nLimit and y<#tLines then\
\009\009\009\009    -- Go to next line\
\009\009\009\009    setCursor( 1, y + 1 )\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009-- Move menu right\
\009\009\009\009nMenuItem = nMenuItem + 1\
\009\009\009\009if nMenuItem > #tMenuItems then\
\009\009\009\009\009nMenuItem = 1\
\009\009\009\009end\
\009\009\009\009redrawMenu()\
\009\009\009end\
\
\009\009elseif param == keys.delete then\
\009\009\009-- Delete\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009    local nLimit = string.len( tLines[y] ) + 1\
\009\009\009\009if x < nLimit then\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawLine(y)\
\009\009\009\009elseif y<#tLines then\
\009\009\009\009\009tLines[y] = tLines[y] .. tLines[y+1]\
\009\009\009\009\009table.remove( tLines, y+1 )\
\009\009\009\009\009recomplete()\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.backspace then\
\009\009\009-- Backspace\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009if x > 1 then\
\009\009\009\009\009-- Remove character\
\009\009\009\009\009local sLine = tLines[y]\
\009\009\009\009\009tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)\
\009\009\009        setCursor( x - 1, y )\
\009\009\009\009elseif y > 1 then\
\009\009\009\009\009-- Remove newline\
\009\009\009\009\009local sPrevLen = string.len( tLines[y-1] )\
\009\009\009\009\009tLines[y-1] = tLines[y-1] .. tLines[y]\
\009\009\009\009\009table.remove( tLines, y )\
\009\009\009\009\009setCursor( sPrevLen + 1, y - 1 )\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif param == keys.enter then\
\009\009\009-- Enter\
\009\009\009if not bMenu and not bReadOnly then\
\009\009\009\009-- Newline\
\009\009\009\009local sLine = tLines[y]\
\009\009\009\009local _,spaces=string.find(sLine,\"^[ ]+\")\
\009\009\009\009if not spaces then\
\009\009\009\009\009spaces=0\
\009\009\009\009end\
\009\009\009\009tLines[y] = string.sub(sLine,1,x-1)\
\009\009\009\009table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )\
\009\009\009\009setCursor( spaces + 1, y + 1 )\
\009\009\009\009redrawText()\
\
\009\009\009elseif bMenu then\
\009\009\009\009-- Menu selection\
\009\009\009\009doMenuItem( nMenuItem )\
\
\009\009\009end\
\
\009\009elseif param == keys.leftCtrl or param == keys.rightCtrl or param == keys.rightAlt then\
\009\009\009-- Menu toggle\
\009\009\009bMenu = not bMenu\
\009\009\009if bMenu then\
\009\009\009\009term.setCursorBlink( false )\
\009\009\009else\
\009\009\009\009term.setCursorBlink( true )\
\009\009\009end\
\009\009\009redrawMenu()\
\
\009\009end\
\009\009\
\009elseif sEvent == \"char\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + 1, y )\
\
\009\009elseif bMenu then\
\009\009\009-- Select menu items\
\009\009\009for n,sMenuItem in ipairs( tMenuItems ) do\
\009\009\009\009if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then\
\009\009\009\009\009doMenuItem( n )\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"paste\" then\
\009\009if not bMenu and not bReadOnly then\
\009\009\009-- Input text\
\009\009\009local sLine = tLines[y]\
\009\009\009tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\
\009\009\009setCursor( x + string.len( param ), y )\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_click\" then\
\009\009if not bMenu then\
\009\009\009if param == 1 then\
\009\009\009\009-- Left click\
\009\009\009\009local cx,cy = param2, param3\
\009\009\009\009if cy < h then\
\009\009\009\009\009local newY = math.min( math.max( scrollY + cy, 1 ), #tLines )\
\009\009\009\009\009local newX = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[newY] ) + 1 )\
\009\009\009\009\009setCursor( newX, newY )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009\
\009elseif sEvent == \"mouse_scroll\" then\
\009\009if not bMenu then\
\009\009\009if param == -1 then\
\009\009\009\009-- Scroll up\
\009\009\009\009if scrollY > 0 then\
\009\009\009\009\009-- Move cursor up\
\009\009\009\009\009scrollY = scrollY - 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\
\009\009\009elseif param == 1 then\
\009\009\009\009-- Scroll down\
\009\009\009\009local nMaxScroll = #tLines - (h-1)\
\009\009\009\009if scrollY < nMaxScroll then\
\009\009\009\009\009-- Move cursor down\
\009\009\009\009\009scrollY = scrollY + 1\
\009\009\009\009\009redrawText()\
\009\009\009\009end\
\009\009\009\009\
\009\009\009end\
\009\009end\
\
\009elseif sEvent == \"term_resize\" then\
\009    w,h = term.getSize()\
        setCursor( x, y )\
        redrawMenu()\
        redrawText()\
\
\009end\
end\
\
-- Cleanup\
term.clear()\
term.setCursorBlink( false )\
term.setCursorPos( 1, 1 )",
      "shell.exit()",
      "\
local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: cp <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
local tFiles = fs.find( sSource )\
if #tFiles > 0 then\
    for n,sFile in ipairs( tFiles ) do\
        if fs.isDir( sDest ) then\
            fs.copy( sFile, fs.combine( sDest, fs.getName(sFile) ) )\
        elseif #tFiles == 1 then\
            fs.copy( sFile, sDest )\
        else\
            printError( \"Cannot overwrite file multiple times\" )\
            return\
        end\
    end\
else\
    printError( \"No matching files\" )\
end",
      "\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"label get\" )\
\009print( \"label get <drive>\" )\
\009print( \"label set <text>\" )\
\009print( \"label set <drive> <text>\" )\
\009print( \"label clear\" )\
\009print( \"label clear <drive>\" )\
end\
\
local function checkDrive( sDrive )\
    if peripheral.getType( sDrive ) == \"drive\" then\
        -- Check the disk exists\
        local bData = disk.hasData( sDrive )\
        if not bData then\
            print( \"No disk in \"..sDrive..\" drive\" )\
            return false\
        end\
    else\
\009    print( \"No disk drive named \"..sDrive )\
        return false\
\009end\
\009return true\
end\
\
local function get( sDrive )\
\009if sDrive ~= nil then\
\009    if checkDrive( sDrive ) then\
            local sLabel = disk.getLabel( sDrive )\
            if sLabel then\
                print( \"Disk label is \\\"\"..sLabel..\"\\\"\" )\
            else\
                print( \"No Disk label\" )\
            end\
        end\
\009else\
\009\009local sLabel = os.getComputerLabel()\
\009\009if sLabel then\
\009\009\009print( \"Computer label is \\\"\"..sLabel..\"\\\"\" )\
\009\009else\
\009\009\009print( \"No Computer label\" )\
\009\009end\
\009end\
end\
\
local function set( sDrive, sText )\
\009if sDrive ~= nil then\
\009    if checkDrive( sDrive ) then\
            disk.setLabel( sDrive, sText )\
            local sLabel = disk.getLabel( sDrive )\
            if sLabel then\
                print( \"Disk label set to \\\"\"..sLabel..\"\\\"\" )\
            else\
                print( \"Disk label cleared\" )\
            end\
        end\
\009else\
\009\009os.setComputerLabel( sText )\
\009\009local sLabel = os.getComputerLabel()\
\009\009if sLabel then\
\009\009\009print( \"Computer label set to \\\"\"..sLabel..\"\\\"\" )\
\009\009else\
\009\009\009print( \"Computer label cleared\" )\
\009\009end\
\009end\
end\
\
local tArgs = { ... }\
local sCommand = tArgs[1]\
if sCommand == \"get\" then\
    -- Get a label\
    if #tArgs == 1 then\
        get( nil )\
    elseif #tArgs == 2 then\
        get( tArgs[2] )\
    else\
        printUsage()\
    end\
elseif sCommand == \"set\" then\
    -- Set a label\
    if #tArgs == 2 then\
        set( nil, tArgs[2] )\
    elseif #tArgs == 3 then\
        set( tArgs[2], tArgs[3] )\
    else\
        printUsage()\
    end\
elseif sCommand == \"clear\" then\
    -- Clear a label\
    if #tArgs == 1 then\
        set( nil, nil )\
    elseif #tArgs == 2 then\
        set( tArgs[2], nil )\
    else\
        printUsage()\
    end\
else\
    printUsage()\
end",
      "local tArgs = { ... }\
\
-- Get where a directory is mounted\
local sPath = shell.dir()\
if tArgs[1] ~= nil then\
\009sPath = shell.resolve( tArgs[1] )\
end\
\
if fs.exists( sPath ) then\
\009write( fs.getDrive( sPath ) .. \" (\" )\
\009local nSpace = fs.getFreeSpace( sPath )\
\009if nSpace >= 1000 * 1000 then\
\009\009print( (math.floor( nSpace / (100 * 1000) ) / 10) .. \"MB remaining)\" )\
\009elseif nSpace >= 1000 then\
\009\009print( (math.floor( nSpace / 100 ) / 10) .. \"KB remaining)\" )\
\009else\
\009\009print( nSpace .. \"B remaining)\" )\
\009end\
else\
\009print( \"No such path\" )\
end",
      "if term.isColour() then\
\009term.setTextColour( colours.yellow )\
end\
print( \"Goodbye\" )\
term.setTextColour( colours.white )\
\
sleep( 1 )\
os.shutdown()",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: mkdir <path>\" )\
\009return\
end\
\
local sNewDir = shell.resolve( tArgs[1] )\
fs.makeDir( sNewDir )",
      "\
local function printUsage()\
\009print( \"Usages:\" )\
\009print( \"gps host\" )\
\009print( \"gps host <x> <y> <z>\" )\
\009print( \"gps locate\" )\
end\
\
local tArgs = { ... }\
if #tArgs < 1 then\
\009printUsage()\
\009return\
end\
\009\
 local sCommand = tArgs[1]\
if sCommand == \"locate\" then\
\009-- \"gps locate\"\
\009-- Just locate this computer (this will print the results)\
\009gps.locate( 2, true )\
\009\
elseif sCommand == \"host\" then\
\009-- \"gps host\"\
\009-- Act as a GPS host\
\009if pocket then\
\009    print( \"GPS Hosts must be stationary\" )\
\009    return\
\009end\
\
\009-- Find a modem\
\009local sModemSide = nil\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\009\
\009\009\009sModemSide = sSide\
\009\009\009break\
\009\009end\
\009end\
\
\009if sModemSide == nil then\
\009\009print( \"No wireless modems found. 1 required.\" )\
\009\009return\
\009end\
\
\009-- Determine position\
\009local x,y,z\
\009if #tArgs >= 4 then\
\009\009-- Position is manually specified\
\009\009x = tonumber(tArgs[2])\
\009\009y = tonumber(tArgs[3])\
\009\009z = tonumber(tArgs[4])\
\009\009if x == nil or y == nil or z == nil then\
\009\009\009printUsage()\
\009\009\009return\
\009\009end\
\009\009print( \"Position is \"..x..\",\"..y..\",\"..z )\
\009else\
\009\009-- Position is to be determined using locate\009\009\
\009\009x,y,z = gps.locate( 2, true )\
\009\009if x == nil then\
\009\009\009print( \"Run \\\"gps host <x> <y> <z>\\\" to set position manually\" )\
\009\009\009if bCloseChannel then\
\009\009\009\009print( \"Closing GPS channel\" )\
\009\009\009\009modem.close( gps.CHANNEL_GPS )\
\009\009\009end\
\009\009\009return\
\009\009end\
\009end\
\009\
\009-- Open a channel\
\009local modem = peripheral.wrap( sModemSide )\
    print( \"Opening channel on modem \"..sModemSide )\
    modem.open( gps.CHANNEL_GPS )\
\
\009-- Serve requests indefinately\
\009local nServed = 0\
\009while true do\
\009\009local e, p1, p2, p3, p4, p5 = os.pullEvent( \"modem_message\" )\
\009\009if e == \"modem_message\" then\
\009\009\009-- We received a message from a modem\
\009\009\009local sSide, sChannel, sReplyChannel, sMessage, nDistance = p1, p2, p3, p4, p5\
\009\009\009if sSide == sModemSide and sChannel == gps.CHANNEL_GPS and sMessage == \"PING\" and nDistance then\
\009\009\009\009-- We received a ping message on the GPS channel, send a response\
\009\009\009\009modem.transmit( sReplyChannel, gps.CHANNEL_GPS, { x, y, z } )\
\009\009\009\
\009\009\009\009-- Print the number of requests handled\
\009\009\009\009nServed = nServed + 1\
\009\009\009\009if nServed > 1 then\
\009\009\009\009\009local x,y = term.getCursorPos()\
\009\009\009\009\009term.setCursorPos(1,y-1)\
\009\009\009\009end\
\009\009\009\009print( nServed..\" GPS requests served\" )\
\009\009\009end\
\009\009end\
\009end\
\
\009-- Close the channel\
    print( \"Closing channel\" )\
    modem.close( gps.CHANNEL_GPS )\
\
else\
\009-- \"gps somethingelse\"\
\009-- Error\
\009printUsage()\
\009\
end",
      "\
-- Get arguments\
local tArgs = { ... }\
if #tArgs == 0 then\
\009print( \"Usage: eject <drive>\" )\
\009return\
end\
\
local sDrive = tArgs[1]\
\
-- Check the disk exists\
local bPresent = disk.isPresent( sDrive )\
if not bPresent then\
\009print( \"Nothing in \"..sDrive..\" drive\" )\
\009return\
end\
\
disk.eject( sDrive )",
      "local tPeripherals = peripheral.getNames()\
print( \"Attached Peripherals:\" )\
if #tPeripherals > 0 then\
\009for n=1,#tPeripherals do\
\009\009local sPeripheral = tPeripherals[n]\
\009\009print( sPeripheral .. \" (\" .. peripheral.getType( sPeripheral ) .. \")\" )\
\009end\
else\
\009print( \"None\" )\
end",
      "\
if not commands then\
    printError( \"Requires a Command Computer.\" )\
    return\
end\
\
local tCommands = commands.list()\
table.sort( tCommands )\
\
if term.isColor() then\
    term.setTextColor( colors.green )\
end\
print( \"Available commands:\" )\
term.setTextColor( colors.white )\
\
textutils.pagedTabulate( tCommands )",
      "\
local tArgs = { ... }\
if not commands then\
    printError( \"Requires a Command Computer.\" )\
    return\
end\
if #tArgs == 0 then\
    printError( \"Usage: exec <command>\" )\
    return\
end\
\
local function printSuccess( text )\
    if term.isColor() then\
        term.setTextColor( colors.green )\
    end\
    print( text )\
    term.setTextColor( colors.white )\
end\
\
local sCommand = string.lower( tArgs[1] )\
for n=2,#tArgs do\
    sCommand = sCommand .. \" \" .. tArgs[n]\
end\
\
local bResult, tOutput = commands.exec( sCommand )\
if bResult then\
    printSuccess( \"Success\" )\
    if #tOutput > 0 then\
        for n=1,#tOutput do\
            print( tOutput[n] )\
        end\
    end\
else\
    printError( \"Failed\" )\
    if #tOutput > 0 then\
        for n=1,#tOutput do\
            print( tOutput[n] )\
        end\
    end\
end",
      "\
local function printUsage()\
\009print( \"Usage: monitor <name> <program> <arguments>\" )\
\009return\
end\
\
local tArgs = { ... }\
if #tArgs < 2 then\
\009printUsage()\
\009return\
end\
\
local sName = tArgs[1]\
if peripheral.getType( sName ) ~= \"monitor\" then\
\009print( \"No monitor named \".. sName )\
\009return\
end\
\
local sProgram = tArgs[2]\
local sPath = shell.resolveProgram( sProgram )\
if sPath == nil then\
\009print( \"No such program: \"..sProgram )\
\009return\
end\
\
print( \"Running \"..sProgram..\" on monitor \"..sName )\
\
local monitor = peripheral.wrap( sName )\
local previousTerm = term.redirect( monitor )\
\
local co = coroutine.create( function()\
    shell.run( sProgram, table.unpack( tArgs, 3 ) )\
end )\
\
local function resume( ... )\
    local ok, param = coroutine.resume( co, ... )\
    if not ok then\
    \009printError( param )\
    end\
    return param\
end\
\
local ok, param = pcall( function()\
\009local sFilter = resume()\
\009while coroutine.status( co ) ~= \"dead\" do\
\009\009local tEvent = { os.pullEventRaw() }\
\009\009if sFilter == nil or tEvent[1] == sFilter or tEvent[1] == \"terminate\" then\
\009\009\009sFilter = resume( table.unpack( tEvent ) )\
\009\009end\
\009\009if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"mouse_click\") then\
\009\009\009if tEvent[1] == \"monitor_touch\" and tEvent[2] == sName then\
\009\009\009\009sFilter = resume( \"mouse_click\", 1, table.unpack( tEvent, 3 ) )\
\009\009\009end\
\009\009end\
\009\009if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"term_resize\") then\
\009\009\009if tEvent[1] == \"monitor_resize\" and tEvent[2] == sName then\
\009\009\009\009sFilter = resume( \"term_resize\" )\
\009\009\009end\
\009\009end\
\009end\
end )\
\
term.redirect( previousTerm )\
if not ok then\
\009printError( param )\
end\
\009",
      "\
local sDrive = nil\
local tArgs = { ... }\
if #tArgs > 0 then\
\009sDrive = tostring( tArgs[1] )\
end\
\
if sDrive == nil then\
\009print( \"This is computer #\"..os.getComputerID() )\
\009\
\009local label = os.getComputerLabel()\
\009if label then\
\009\009print( \"This computer is labelled \\\"\"..label..\"\\\"\" )\
\009end\
\
else\
\009local bData = disk.hasData( sDrive )\
\009if not bData then\
\009\009print( \"No disk in drive \"..sDrive )\
\009\009return\
\009end\
\009\
\009print( \"The disk is #\"..disk.getID( sDrive ) )\
\
\009local label = disk.getLabel( sDrive )\
\009if label then\
\009\009print( \"The disk is labelled \\\"\"..label..\"\\\"\" )\
\009end\
end",
      "\
local tApis = {}\
for k,v in pairs( _G ) do\
\009if type(k) == \"string\" and type(v) == \"table\" and k ~= \"_G\" then\
\009\009table.insert( tApis, k )\
\009end\
end\
table.insert( tApis, \"shell\" )\
table.sort( tApis )\
\
textutils.pagedTabulate( tApis )",
      "local tArgs = { ... }\
if #tArgs < 2 then\
\009print( \"Usage: rename <source> <destination>\" )\
\009return\
end\
\
local sSource = shell.resolve( tArgs[1] )\
local sDest = shell.resolve( tArgs[2] )\
fs.move( sSource, sDest )",
      "term.clear()\
term.setCursorPos( 1, 1 )",
      "local colours = _G.colors\
local function write(string)\
    return term.write(string)\
end\
local multishell = multishell\
local parentShell = shell\
local parentTerm = term.current()\
\
if multishell then\
    multishell.setTitle( multishell.getCurrent(), \"shell\" )\
end\
\
local bExit = false\
local sDir = (parentShell and parentShell.dir()) or \"\"\
local sPath = (parentShell and parentShell.path()) or \".:/rom/programs\"\
local tAliases = (parentShell and parentShell.aliases()) or {}\
local tCompletionInfo = (parentShell and parentShell.getCompletionInfo()) or {}\
local tProgramStack = {}\
\
local shell = {}\
local tEnv = {\
\009[ \"shell\" ] = shell,\
\009[ \"multishell\" ] = multishell,\
}\
\
-- Colours\
local promptColour, textColour, bgColour\
if term.isColour() then\
\009promptColour = colours.yellow\
\009textColour = colours.white\
\009bgColour = colours.black\
else\
\009promptColour = colours.white\
\009textColour = colours.white\
\009bgColour = colours.black\
end\
\
local function run( _sCommand, ... )\
\009local sPath = shell.resolveProgram( _sCommand )\
\009if sPath ~= nil then\
\009\009tProgramStack[#tProgramStack + 1] = sPath\
\009\009if multishell then\
\009\009    multishell.setTitle( multishell.getCurrent(), fs.getName( sPath ) )\
\009\009end\
   \009\009local result = os.run( tEnv, sPath, ... )\
\009\009tProgramStack[#tProgramStack] = nil\
\009\009if multishell then\
\009\009    if #tProgramStack > 0 then\
    \009\009    multishell.setTitle( multishell.getCurrent(), fs.getName( tProgramStack[#tProgramStack] ) )\
    \009\009else\
    \009\009    multishell.setTitle( multishell.getCurrent(), \"shell\" )\
    \009\009end\
\009\009end\
\009\009return result\
   \009else\
    \009printError( \"No such program\" )\
    \009return false\
    end\
end\
\
local function tokenise( ... )\
    local sLine = table.concat( { ... }, \" \" )\
\009local tWords = {}\
    local bQuoted = false\
    for match in string.gmatch( sLine .. \"\\\"\", \"(.-)\\\"\" ) do\
        if bQuoted then\
            table.insert( tWords, match )\
        else\
            for m in string.gmatch( match, \"[^ \\t]+\" ) do\
                table.insert( tWords, m )\
            end\
        end\
        bQuoted = not bQuoted\
    end\
    return tWords\
end\
\
-- Install shell API\
function shell.run( ... )\
\009local tWords = tokenise( ... )\
\009local sCommand = tWords[1]\
\009if sCommand then\
\009\009return run( sCommand, table.unpack( tWords, 2 ) )\
\009end\
\009return false\
end\
\
function shell.exit()\
    bExit = true\
end\
\
function shell.dir()\
\009return sDir\
end\
\
function shell.setDir( _sDir )\
\009sDir = _sDir\
end\
\
function shell.path()\
\009return sPath\
end\
\
function shell.setPath( _sPath )\
\009sPath = _sPath\
end\
\
function shell.resolve( _sPath )\
\009local sStartChar = string.sub( _sPath, 1, 1 )\
\009if sStartChar == \"/\" or sStartChar == \"\\\\\" then\
\009\009return fs.combine( \"\", _sPath )\
\009else\
\009\009return fs.combine( sDir, _sPath )\
\009end\
end\
\
function shell.resolveProgram( _sCommand )\
\009-- Substitute aliases firsts\
\009if tAliases[ _sCommand ] ~= nil then\
\009\009_sCommand = tAliases[ _sCommand ]\
\009end\
\
    -- If the path is a global path, use it directly\
    local sStartChar = string.sub( _sCommand, 1, 1 )\
    if sStartChar == \"/\" or sStartChar == \"\\\\\" then\
    \009local sPath = fs.combine( \"\", _sCommand )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
\009\009return nil\
    end\
    \
 \009-- Otherwise, look on the path variable\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = fs.combine( shell.resolve( sPath ), _sCommand )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
    end\
\009\
\009-- Not found\
\009return nil\
end\
\
function shell.programs( _bIncludeHidden )\
\009local tItems = {}\
\009\
\009-- Add programs from the path\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = shell.resolve( sPath )\
\009\009if fs.isDir( sPath ) then\
\009\009\009local tList = fs.list( sPath )\
            for n=1,#tList do\
                local sFile = tList[n]\
\009\009\009\009if not fs.isDir( fs.combine( sPath, sFile ) ) and\
\009\009\009\009   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= \".\") then\
\009\009\009\009\009tItems[ sFile ] = true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    end\009\
\
\009-- Sort and return\
\009local tItemList = {}\
\009for sItem, b in pairs( tItems ) do\
\009\009table.insert( tItemList, sItem )\
\009end\
\009table.sort( tItemList )\
\009return tItemList\
end\
\
local function completeProgram( sLine )\
\009if #sLine > 0 and string.sub( sLine, 1, 1 ) == \"/\" then\
\009    -- Add programs from the root\
\009    return fs.complete( sLine, \"\", true, false )\
\
    else\
        local tResults = {}\
        local tSeen = {}\
\
        -- Add aliases\
        for sAlias, sCommand in pairs( tAliases ) do\
            if #sAlias > #sLine and string.sub( sAlias, 1, #sLine ) == sLine then\
                local sResult = string.sub( sAlias, #sLine + 1 )\
                if not tSeen[ sResult ] then\
                    table.insert( tResults, sResult )\
                    tSeen[ sResult ] = true\
                end\
            end\
        end\
\
        -- Add programs from the path\
        local tPrograms = shell.programs()\
        for n=1,#tPrograms do\
            local sProgram = tPrograms[n]\
            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then\
                local sResult = string.sub( sProgram, #sLine + 1 )\
                if not tSeen[ sResult ] then\
                    table.insert( tResults, sResult )\
                    tSeen[ sResult ] = true\
                end\
            end\
        end\
\
        -- Sort and return\
        table.sort( tResults )\
        return tResults\
    end\
end\
\
local function completeProgramArgument( sProgram, nArgument, sPart, tPreviousParts )\
    local tInfo = tCompletionInfo[ sProgram ]\
    if tInfo then\
        return tInfo.fnComplete( shell, nArgument, sPart, tPreviousParts )\
    end\
    return nil\
end\
\
function shell.complete( sLine )\
    if #sLine > 0 then\
        local tWords = tokenise( sLine )\
        local nIndex = #tWords\
        if string.sub( sLine, #sLine, #sLine ) == \" \" then\
            nIndex = nIndex + 1\
        end\
        if nIndex == 1 then\
            local sBit = tWords[1] or \"\"\
            local sPath = shell.resolveProgram( sBit )\
            if tCompletionInfo[ sPath ] then\
                return { \" \" }\
            else\
                local tResults = completeProgram( sBit )\
                for n=1,#tResults do\
                    local sResult = tResults[n]\
                    local sPath = shell.resolveProgram( sBit .. sResult )\
                    if tCompletionInfo[ sPath ] then\
                        tResults[n] = sResult .. \" \"\
                    end\
                end\
                return tResults\
            end\
\
        elseif nIndex > 1 then\
            local sPath = shell.resolveProgram( tWords[1] )\
            local sPart = tWords[nIndex] or \"\"\
            local tPreviousParts = tWords\
            tPreviousParts[nIndex] = nil\
            return completeProgramArgument( sPath , nIndex - 1, sPart, tPreviousParts )\
\
        end\
    end\
\009return nil\
end\
\
function shell.completeProgram( sProgram )\
    return completeProgram( sProgram )\
end\
\
function shell.setCompletionFunction( sProgram, fnComplete )\
    tCompletionInfo[ sProgram ] = {\
        fnComplete = fnComplete\
    }\
end\
\
function shell.getCompletionInfo()\
    return tCompletionInfo\
end\
\
function shell.getRunningProgram()\
\009if #tProgramStack > 0 then\
\009\009return tProgramStack[#tProgramStack]\
\009end\
\009return nil\
end\
\
function shell.setAlias( _sCommand, _sProgram )\
\009tAliases[ _sCommand ] = _sProgram\
end\
\
function shell.clearAlias( _sCommand )\
\009tAliases[ _sCommand ] = nil\
end\
\
function shell.aliases()\
\009-- Copy aliases\
\009local tCopy = {}\
\009for sAlias, sCommand in pairs( tAliases ) do\
\009\009tCopy[sAlias] = sCommand\
\009end\
\009return tCopy\
end\
\
if multishell then\
    function shell.openTab( ... )\
        local tWords = tokenise( ... )\
        local sCommand = tWords[1]\
        if sCommand then\
        \009local sPath = shell.resolveProgram( sCommand )\
        \009if sPath == \"rom/programs/shell\" then\
                return multishell.launch( tEnv, sPath, table.unpack( tWords, 2 ) )\
            elseif sPath ~= nil then\
                return multishell.launch( tEnv, \"rom/programs/shell\", sCommand, table.unpack( tWords, 2 ) )\
            else\
                printError( \"No such program\" )\
            end\
        end\
    end\
\
    function shell.switchTab( nID )\
        multishell.setFocus( nID )\
    end\
end\
\
local tArgs = { ... }\
if #tArgs > 0 then\
    -- \"shell x y z\"\
    -- Run the program specified on the commandline\
    shell.run( ... )\
\
else\
    -- \"shell\"\
    -- Print the header\
    term.setBackgroundColor( bgColour )\
    term.setTextColour( promptColour )\
    print( os.version() )\
    term.setTextColour( textColour )\
\
    -- Run the startup program\
    if parentShell == nil then\
        shell.run( \"/rom/startup\" )\
    end\
\
    -- Read commands and execute them\
    local tCommandHistory = {}\
    while not bExit do\
        term.redirect( parentTerm )\
        term.setBackgroundColor( bgColour )\
        term.setTextColour( promptColour )\
        write( shell.dir() .. \"> \" )\
        term.setTextColour( textColour )\
\
\
        local sLine\
        if settings.get( \"shell.autocomplete\" ) then\
            sLine = read( nil, tCommandHistory, shell.complete )\
        else\
            sLine = read( nil, tCommandHistory )\
        end\
        table.insert( tCommandHistory, sLine )\
        shell.run( sLine )\
    end\
end",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: go <direction> <distance>\" )\
\009return\
end\
\
local tHandlers = {\
\009[\"fd\"] = turtle.forward,\
\009[\"forward\"] = turtle.forward,\
\009[\"forwards\"] = turtle.forward,\
\009[\"bk\"] = turtle.back,\
\009[\"back\"] = turtle.back,\
\009[\"up\"] = turtle.up,\
\009[\"dn\"] = turtle.down,\
\009[\"down\"] = turtle.down,\
\009[\"lt\"] = turtle.turnLeft,\
\009[\"left\"] = turtle.turnLeft,\
\009[\"rt\"] = turtle.turnRight,\
\009[\"right\"] = turtle.turnRight,\
}\
\
local nArg = 1\
while nArg <= #tArgs do\
\009local sDirection = tArgs[nArg]\
\009local nDistance = 1\
\009if nArg < #tArgs then\
\009\009local num = tonumber( tArgs[nArg + 1] )\
\009\009if num then\
\009\009\009nDistance = num\
\009\009\009nArg = nArg + 1\
\009\009end\
\009end\
\009nArg = nArg + 1\
\
\009local fnHandler = tHandlers[string.lower(sDirection)]\
\009if fnHandler then\
\009\009while nDistance > 0 do\
\009\009\009if fnHandler() then\
\009\009\009\009nDistance = nDistance - 1\
\009\009\009elseif turtle.getFuelLevel() == 0 then\
\009\009\009\009print( \"Out of fuel\" )\
\009\009\009\009return\
\009\009\009else\
\009\009\009\009sleep(0.5)\
\009\009\009end\
\009\009end\
\009else\
\009\009print( \"No such direction: \"..sDirection )\
\009\009print( \"Try: forward, back, up, down\" )\
\009\009return\
\009end\
\
end",
      "\
local tArgs = { ... }\
if #tArgs ~= 1 then\
\009print( \"Usage: tunnel <length>\" )\
\009return\
end\
\
-- Mine in a quarry pattern until we hit something we can't dig\
local length = tonumber( tArgs[1] )\
if length < 1 then\
\009print( \"Tunnel length must be positive\" )\
\009return\
end\
\009\
local depth = 0\
local collected = 0\
\
local function collect()\
\009collected = collected + 1\
\009if math.fmod(collected, 25) == 0 then\
\009\009print( \"Mined \"..collected..\" items.\" )\
\009end\
end\
\
local function tryDig()\
\009while turtle.detect() do\
\009\009if turtle.dig() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDigUp()\
\009while turtle.detectUp() do\
\009\009if turtle.digUp() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDigDown()\
\009while turtle.detectDown() do\
\009\009if turtle.digDown() then\
\009\009\009collect()\
\009\009\009sleep(0.5)\
\009\009else\
\009\009\009return false\
\009\009end\
\009end\
\009return true\
end\
\
local function refuel()\
\009local fuelLevel = turtle.getFuelLevel()\
\009if fuelLevel == \"unlimited\" or fuelLevel > 0 then\
\009\009return\
\009end\
\009\
\009local function tryRefuel()\
\009\009for n=1,16 do\
\009\009\009if turtle.getItemCount(n) > 0 then\
\009\009\009\009turtle.select(n)\
\009\009\009\009if turtle.refuel(1) then\
\009\009\009\009\009turtle.select(1)\
\009\009\009\009\009return true\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009turtle.select(1)\
\009\009return false\
\009end\
\009\
\009if not tryRefuel() then\
\009\009print( \"Add more fuel to continue.\" )\
\009\009while not tryRefuel() do\
\009\009\009os.pullEvent( \"turtle_inventory\" )\
\009\009end\
\009\009print( \"Resuming Tunnel.\" )\
\009end\
end\
\
local function tryUp()\
\009refuel()\
\009while not turtle.up() do\
\009\009if turtle.detectUp() then\
\009\009\009if not tryDigUp() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackUp() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
local function tryDown()\
\009refuel()\
\009while not turtle.down() do\
\009\009if turtle.detectDown() then\
\009\009\009if not tryDigDown() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackDown() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
local function tryForward()\
\009refuel()\
\009while not turtle.forward() do\
\009\009if turtle.detect() then\
\009\009\009if not tryDig() then\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attack() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009return true\
end\
\
print( \"Tunnelling...\" )\
\
for n=1,length do\
\009turtle.placeDown()\
\009tryDigUp()\
\009turtle.turnLeft()\
\009tryDig()\
\009tryUp()\
\009tryDig()\
\009turtle.turnRight()\
\009turtle.turnRight()\
\009tryDig()\
\009tryDown()\
\009tryDig()\
\009turtle.turnLeft()\
\009\
\009if n<length then\
\009\009tryDig()\
\009\009if not tryForward() then\
\009\009\009print( \"Aborting Tunnel.\" )\
\009\009\009break\
\009\009end\
\009else\
\009\009print( \"Tunnel complete.\" )\
\009end\
\
end\
\
--[[\
print( \"Returning to start...\" )\
\
-- Return to where we started\
turtle.turnLeft()\
turtle.turnLeft()\
while depth > 0 do\
\009if turtle.forward() then\
\009\009depth = depth - 1\
\009else\
\009\009turtle.dig()\
\009end\
end\
turtle.turnRight()\
turtle.turnRight()\
]]\
\
print( \"Tunnel complete.\" )\
print( \"Mined \"..collected..\" items total.\" )",
      "\
if not turtle.craft then\
    print( \"Requires a Crafty Turtle\" )\
    return\
end\
\
local tArgs = { ... }\
local nLimit = nil\
if #tArgs < 1 then\
\009print( \"Usage: craft [number]\" )\
\009return\
else\
\009nLimit = tonumber( tArgs[1] )\
end\
\
local nCrafted = 0\
local nOldCount = turtle.getItemCount( turtle.getSelectedSlot() )\
if turtle.craft( nLimit ) then\
    local nNewCount = turtle.getItemCount( turtle.getSelectedSlot() )\
    if nOldCount <= nLimit then\
        nCrafted = nNewCount\
    else\
        nCrafted = nOldCount - nNewCount\
    end\
end\
\
if nCrafted > 1 then\
    print( nCrafted..\" items crafted\" )\
elseif nCrafted == 1 then\
    print( \"1 item crafted\" )\
else\
    print( \"No items crafted\" )\
end",
      "\
local tArgs = { ... }\
if #tArgs ~= 1 then\
\009print( \"Usage: excavate <diameter>\" )\
\009return\
end\
\
-- Mine in a quarry pattern until we hit something we can't dig\
local size = tonumber( tArgs[1] )\
if size < 1 then\
\009print( \"Excavate diameter must be positive\" )\
\009return\
end\
\009\
local depth = 0\
local unloaded = 0\
local collected = 0\
\
local xPos,zPos = 0,0\
local xDir,zDir = 0,1\
\
local goTo -- Filled in further down\
local refuel -- Filled in further down\
 \
local function unload( _bKeepOneFuelStack )\
\009print( \"Unloading items...\" )\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nCount > 0 then\
\009\009\009turtle.select(n)\009\009\009\
\009\009\009local bDrop = true\
\009\009\009if _bKeepOneFuelStack and turtle.refuel(0) then\
\009\009\009\009bDrop = false\
\009\009\009\009_bKeepOneFuelStack = false\
\009\009\009end\009\009\009\
\009\009\009if bDrop then\
\009\009\009\009turtle.drop()\
\009\009\009\009unloaded = unloaded + nCount\
\009\009\009end\
\009\009end\
\009end\
\009collected = 0\
\009turtle.select(1)\
end\
\
local function returnSupplies()\
\009local x,y,z,xd,zd = xPos,depth,zPos,xDir,zDir\
\009print( \"Returning to surface...\" )\
\009goTo( 0,0,0,0,-1 )\
\009\
\009local fuelNeeded = 2*(x+y+z) + 1\
\009if not refuel( fuelNeeded ) then\
\009\009unload( true )\
\009\009print( \"Waiting for fuel\" )\
\009\009while not refuel( fuelNeeded ) do\
\009\009\009os.pullEvent( \"turtle_inventory\" )\
\009\009end\
\009else\
\009\009unload( true )\009\
\009end\
\009\
\009print( \"Resuming mining...\" )\
\009goTo( x,y,z,xd,zd )\
end\
\
local function collect()\009\
\009local bFull = true\
\009local nTotalItems = 0\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nCount == 0 then\
\009\009\009bFull = false\
\009\009end\
\009\009nTotalItems = nTotalItems + nCount\
\009end\
\009\
\009if nTotalItems > collected then\
\009\009collected = nTotalItems\
\009\009if math.fmod(collected + unloaded, 50) == 0 then\
\009\009\009print( \"Mined \"..(collected + unloaded)..\" items.\" )\
\009\009end\
\009end\
\009\
\009if bFull then\
\009\009print( \"No empty slots left.\" )\
\009\009return false\
\009end\
\009return true\
end\
\
function refuel( ammount )\
\009local fuelLevel = turtle.getFuelLevel()\
\009if fuelLevel == \"unlimited\" then\
\009\009return true\
\009end\
\009\
\009local needed = ammount or (xPos + zPos + depth + 2)\
\009if turtle.getFuelLevel() < needed then\
\009\009local fueled = false\
\009\009for n=1,16 do\
\009\009\009if turtle.getItemCount(n) > 0 then\
\009\009\009\009turtle.select(n)\
\009\009\009\009if turtle.refuel(1) then\
\009\009\009\009\009while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do\
\009\009\009\009\009\009turtle.refuel(1)\
\009\009\009\009\009end\
\009\009\009\009\009if turtle.getFuelLevel() >= needed then\
\009\009\009\009\009\009turtle.select(1)\
\009\009\009\009\009\009return true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009turtle.select(1)\
\009\009return false\
\009end\
\009\
\009return true\
end\
\
local function tryForwards()\
\009if not refuel() then\
\009\009print( \"Not enough Fuel\" )\
\009\009returnSupplies()\
\009end\
\009\
\009while not turtle.forward() do\
\009\009if turtle.detect() then\
\009\009\009if turtle.dig() then\
\009\009\009\009if not collect() then\
\009\009\009\009\009returnSupplies()\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attack() then\
\009\009\009if not collect() then\
\009\009\009\009returnSupplies()\
\009\009\009end\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009\
\009xPos = xPos + xDir\
\009zPos = zPos + zDir\
\009return true\
end\
\
local function tryDown()\
\009if not refuel() then\
\009\009print( \"Not enough Fuel\" )\
\009\009returnSupplies()\
\009end\
\009\
\009while not turtle.down() do\
\009\009if turtle.detectDown() then\
\009\009\009if turtle.digDown() then\
\009\009\009\009if not collect() then\
\009\009\009\009\009returnSupplies()\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return false\
\009\009\009end\
\009\009elseif turtle.attackDown() then\
\009\009\009if not collect() then\
\009\009\009\009returnSupplies()\
\009\009\009end\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\
\009depth = depth + 1\
\009if math.fmod( depth, 10 ) == 0 then\
\009\009print( \"Descended \"..depth..\" metres.\" )\
\009end\
\
\009return true\
end\
\
local function turnLeft()\
\009turtle.turnLeft()\
\009xDir, zDir = -zDir, xDir\
end\
\
local function turnRight()\
\009turtle.turnRight()\
\009xDir, zDir = zDir, -xDir\
end\
\
function goTo( x, y, z, xd, zd )\
\009while depth > y do\
\009\009if turtle.up() then\
\009\009\009depth = depth - 1\
\009\009elseif turtle.digUp() or turtle.attackUp() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\
\009if xPos > x then\
\009\009while xDir ~= -1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while xPos > x do\
\009\009\009if turtle.forward() then\
\009\009\009\009xPos = xPos - 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009elseif xPos < x then\
\009\009while xDir ~= 1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while xPos < x do\
\009\009\009if turtle.forward() then\
\009\009\009\009xPos = xPos + 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009end\
\009\
\009if zPos > z then\
\009\009while zDir ~= -1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while zPos > z do\
\009\009\009if turtle.forward() then\
\009\009\009\009zPos = zPos - 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\
\009elseif zPos < z then\
\009\009while zDir ~= 1 do\
\009\009\009turnLeft()\
\009\009end\
\009\009while zPos < z do\
\009\009\009if turtle.forward() then\
\009\009\009\009zPos = zPos + 1\
\009\009\009elseif turtle.dig() or turtle.attack() then\
\009\009\009\009collect()\
\009\009\009else\
\009\009\009\009sleep( 0.5 )\
\009\009\009end\
\009\009end\009\
\009end\
\009\
\009while depth < y do\
\009\009if turtle.down() then\
\009\009\009depth = depth + 1\
\009\009elseif turtle.digDown() or turtle.attackDown() then\
\009\009\009collect()\
\009\009else\
\009\009\009sleep( 0.5 )\
\009\009end\
\009end\
\009\
\009while zDir ~= zd or xDir ~= xd do\
\009\009turnLeft()\
\009end\
end\
\
if not refuel() then\
\009print( \"Out of Fuel\" )\
\009return\
end\
\
print( \"Excavating...\" )\
\
local reseal = false\
turtle.select(1)\
if turtle.digDown() then\
\009reseal = true\
end\
\
local alternate = 0\
local done = false\
while not done do\
\009for n=1,size do\
\009\009for m=1,size-1 do\
\009\009\009if not tryForwards() then\
\009\009\009\009done = true\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009if done then\
\009\009\009break\
\009\009end\
\009\009if n<size then\
\009\009\009if math.fmod(n + alternate,2) == 0 then\
\009\009\009\009turnLeft()\
\009\009\009\009if not tryForwards() then\
\009\009\009\009\009done = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009\009turnLeft()\
\009\009\009else\
\009\009\009\009turnRight()\
\009\009\009\009if not tryForwards() then\
\009\009\009\009\009done = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009\009turnRight()\
\009\009\009end\
\009\009end\
\009end\
\009if done then\
\009\009break\
\009end\
\009\
\009if size > 1 then\
\009\009if math.fmod(size,2) == 0 then\
\009\009\009turnRight()\
\009\009else\
\009\009\009if alternate == 0 then\
\009\009\009\009turnLeft()\
\009\009\009else\
\009\009\009\009turnRight()\
\009\009\009end\
\009\009\009alternate = 1 - alternate\
\009\009end\
\009end\
\009\
\009if not tryDown() then\
\009\009done = true\
\009\009break\
\009end\
end\
\
print( \"Returning to surface...\" )\
\
-- Return to where we started\
goTo( 0,0,0,0,-1 )\
unload( false )\
goTo( 0,0,0,0,1 )\
\
-- Seal the hole\
if reseal then\
\009turtle.placeDown()\
end\
\
print( \"Mined \"..(collected + unloaded)..\" items total.\" )",
      "\
local tArgs = { ... }\
local function printUsage()\
\009print( \"Usage: unequip <side>\" )\
end\
\
if #tArgs ~= 1 then\
    printUsage()\
\009return\
end\
\
local function unequip( fnEquipFunction )\
    for nSlot=1,16 do\
        local nOldCount = turtle.getItemCount( nSlot )\
        if nOldCount == 0 then\
            turtle.select( nSlot )\
            if fnEquipFunction() then\
                local nNewCount = turtle.getItemCount( nSlot )\
                if nNewCount > 0 then\
                    print( \"Item unequipped\" )\
                    return\
                else\
                    print( \"Nothing to unequip\" )\
                    return\
                end\
            end\
        end\
    end\
    print( \"No space to unequip item\" )\
end\
\
local sSide = tArgs[1]\
if sSide == \"left\" then\
    unequip( turtle.equipLeft )\
elseif sSide == \"right\" then\
    unequip( turtle.equipRight )\
else\
    printUsage()\
    return\
end",
      "local tArgs = { ... }\
if #tArgs < 1 then\
\009print( \"Usage: turn <direction> <turns>\" )\
\009return\
end\
\
local tHandlers = {\
\009[\"lt\"] = turtle.turnLeft,\
\009[\"left\"] = turtle.turnLeft,\
\009[\"rt\"] = turtle.turnRight,\
\009[\"right\"] = turtle.turnRight,\
}\
\
local nArg = 1\
while nArg <= #tArgs do\
\009local sDirection = tArgs[nArg]\
\009local nDistance = 1\
\009if nArg < #tArgs then\
\009\009local num = tonumber( tArgs[nArg + 1] )\
\009\009if num then\
\009\009\009nDistance = num\
\009\009\009nArg = nArg + 1\
\009\009end\
\009end\
\009nArg = nArg + 1\
\
\009local fnHandler = tHandlers[string.lower(sDirection)]\
\009if fnHandler then\
\009\009for n=1,nDistance do\
\009\009\009fnHandler( nArg )\
\009\009end\
\009else\
\009\009print( \"No such direction: \"..sDirection )\
\009\009print( \"Try: left, right\" )\
\009\009return\
\009end\
\009\
end",
      "\
local tArgs = { ... }\
local nLimit = 1\
if #tArgs > 1 then\
\009print( \"Usage: refuel [number]\" )\
\009return\
elseif #tArgs > 0 then\
\009if tArgs[1] == \"all\" then\
\009\009nLimit = 64 * 16\
\009else\
\009\009nLimit = tonumber( tArgs[1] )\
\009end\
end\
\
if turtle.getFuelLevel() ~= \"unlimited\" then\
\009for n=1,16 do\
\009\009local nCount = turtle.getItemCount(n)\
\009\009if nLimit > 0 and nCount > 0 and turtle.getFuelLevel() < turtle.getFuelLimit() then\
\009\009    local nBurn = math.min( nLimit, nCount )\
\009\009\009turtle.select( n )\
\009\009\009if turtle.refuel( nBurn ) then\
\009\009\009    local nNewCount = turtle.getItemCount(n)\
    \009\009\009nLimit = nLimit - (nCount - nNewCount)\
    \009\009end\
\009\009end\
\009end\
    print( \"Fuel level is \"..turtle.getFuelLevel() )\
    if turtle.getFuelLevel() == turtle.getFuelLimit() then\
        print( \"Fuel limit reached\" )\
    end\
else\
    print( \"Fuel level is unlimited\" )\
end",
      "\
local tMoves = {\
\009function()\
\009\009turtle.up()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.up()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.up()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.down()\
\009end,\
\009function()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009end,\
\009function()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009end,\
\009function()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009\009turtle.back()\
\009\009turtle.turnLeft()\
\009end,\
\009function()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009\009turtle.back()\
\009\009turtle.turnRight()\
\009end,\
}\
\
textutils.slowWrite( \"Preparing to get down.\" )\
textutils.slowPrint( \"..\", 0.75 )\
\
local sAudio = nil\
for n,sName in pairs( peripheral.getNames() ) do\
\009if disk.hasAudio( sName ) then\
\009\009disk.playAudio( sName )\
\009\009print( \"Jamming to \"..disk.getAudioTitle( sName ) )\
\009\009sAudio = sName\
\009\009break\
\009end\
end\
\
print( \"Press any key to stop the groove\" )\
\
local bEnd = false\
parallel.waitForAll(\
\009function()\
\009\009while not bEnd do\
\009\009\009local event, key = os.pullEvent(\"key\")\
\009\009\009if key ~= keys.escape then\
\009\009\009\009bEnd = true\
\009\009\009end\
\009\009end\009\009\
\009end,\
\009function()\
\009\009while not bEnd do\
\009\009\009local fnMove = tMoves[math.random(1,#tMoves)]\
\009\009\009fnMove()\
\009\009end\
\009end\
)\
\
if sAudio then\
\009disk.stopAudio( sAudio )\
end",
      "\
local tArgs = { ... }\
local function printUsage()\
\009print( \"Usage: equip <slot> <side>\" )\
end\
\
if #tArgs ~= 2 then\
    printUsage()\
\009return\
end\
\
local function equip( nSlot, fnEquipFunction )\
    turtle.select( nSlot )\
    local nOldCount = turtle.getItemCount( nSlot )\
    if nOldCount == 0 then\
        print( \"Nothing to equip\" )\
    elseif fnEquipFunction() then\
        local nNewCount = turtle.getItemCount( nSlot )\
        if nNewCount > 0 then\
            print( \"Items swapped\" )\
        else\
            print( \"Item equipped\" )\
        end\
    else\
        print( \"Item not equippable\" )\
    end\
end\
\
local nSlot = tonumber( tArgs[1] )\
local sSide = tArgs[2]\
if sSide == \"left\" then\
    equip( nSlot, turtle.equipLeft )\
elseif sSide == \"right\" then\
    equip( nSlot, turtle.equipRight )\
else\
    printUsage()\
    return\
end",
      "print(tostring(term))\
-- Setup paths\
local sPath = \".:/rom/programs\"\
if term.isColor() then\
\009sPath = sPath..\":/rom/programs/advanced\"\
end\
if turtle then\
\009sPath = sPath..\":/rom/programs/turtle\"\
else\
    sPath = sPath..\":/rom/programs/rednet:/rom/programs/fun\"\
    if term.isColor() then\
    \009sPath = sPath..\":/rom/programs/fun/advanced\"\
    end\
end\
if pocket then\
    sPath = sPath..\":/rom/programs/pocket\"\
end\
if commands then\
    sPath = sPath..\":/rom/programs/command\"\
end\
if http then\
\009sPath = sPath..\":/rom/programs/http\"\
end\
shell.setPath( sPath )\
help.setPath( \"/rom/help\" )\
\
-- Setup aliases\
shell.setAlias( \"ls\", \"list\" )\
shell.setAlias( \"dir\", \"list\" )\
shell.setAlias( \"cp\", \"copy\" )\
shell.setAlias( \"mv\", \"move\" )\
shell.setAlias( \"rm\", \"delete\" )\
shell.setAlias( \"clr\", \"clear\" )\
shell.setAlias( \"rs\", \"redstone\" )\
shell.setAlias( \"sh\", \"shell\" )\
if term.isColor() then\
    shell.setAlias( \"background\", \"bg\" )\
    shell.setAlias( \"foreground\", \"fg\" )\
end\
\
-- Setup completion functions\
local function completeMultipleChoice( sText, tOptions, bAddSpaces )\
    local tResults = {}\
    for n=1,#tOptions do\
        local sOption = tOptions[n]\
        if #sOption + (bAddSpaces and 1 or 0) > #sText and string.sub( sOption, 1, #sText ) == sText then\
            local sResult = string.sub( sOption, #sText + 1 )\
            if bAddSpaces then\
                table.insert( tResults, sResult .. \" \" )\
            else\
                table.insert( tResults, sResult )\
            end\
        end\
    end\
    return tResults\
end\
local function completePeripheralName( sText, bAddSpaces )\
    return completeMultipleChoice( sText, peripheral.getNames(), bAddSpaces )\
end\
--disable redstone, not available in cVM\
--[[local tRedstoneSides = redstone.getSides()\
local function completeSide( sText, bAddSpaces )\
    return completeMultipleChoice( sText, tRedstoneSides, bAddSpaces )\
end]]\
local function completeFile( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), true, false )\
    end\
end\
local function completeDir( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), false, true )\
    end\
end\
local function completeEither( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return fs.complete( sText, shell.dir(), true, true )\
    end\
end\
local function completeEitherEither( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        local tResults = fs.complete( sText, shell.dir(), true, true )\
        for n=1,#tResults do\
            local sResult = tResults[n]\
            if string.sub( sResult, #sResult, #sResult ) ~= \"/\" then\
                tResults[n] = sResult .. \" \"\
            end\
        end\
        return tResults\
    elseif nIndex == 2 then\
        return fs.complete( sText, shell.dir(), true, true )\
    end\
end\
local function completeProgram( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return shell.completeProgram( sText )\
    end\
end\
local function completeHelp( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return help.completeTopic( sText )\
    end\
end\
local function completeAlias( shell, nIndex, sText, tPreviousText )\
    if nIndex == 2 then\
        return shell.completeProgram( sText )\
    end\
end\
local function completePeripheral( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completePeripheralName( sText )\
    end\
end\
local tGPSOptions = { \"host\", \"host \", \"locate\" }\
local function completeGPS( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tGPSOptions )\
    end\
end\
local tLabelOptions = { \"get\", \"get \", \"set \", \"clear\", \"clear \" }\
local function completeLabel( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tLabelOptions )\
    elseif nIndex == 2 then\
        return completePeripheralName( sText )\
    end\
end\
local function completeMonitor( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completePeripheralName( sText, true )\
    elseif nIndex == 2 then\
        return shell.completeProgram( sText )\
    end\
end\
local tRedstoneOptions = { \"probe\", \"set \", \"pulse \" }\
local function completeRedstone( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tRedstoneOptions )\
    elseif nIndex == 2 then\
        return completeSide( sText )\
    end\
end\
local tDJOptions = { \"play\", \"play \", \"stop \" }\
local function completeDJ( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tDJOptions )\
    elseif nIndex == 2 then\
        return completePeripheralName( sText )\
    end\
end\
local tPastebinOptions = { \"put \", \"get \", \"run \" }\
local function completePastebin( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tPastebinOptions )\
    elseif nIndex == 2 then\
        if tPreviousText[2] == \"put\" then\
            return fs.complete( sText, shell.dir(), true, false )\
        end\
    end\
end\
local tChatOptions = { \"host \", \"join \" }\
local function completeChat( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, tChatOptions )\
    end\
end\
local function completeSet( shell, nIndex, sText, tPreviousText )\
    if nIndex == 1 then\
        return completeMultipleChoice( sText, settings.getNames(), true )\
    end\
end\
shell.setCompletionFunction( \"rom/programs/alias\", completeAlias )\
shell.setCompletionFunction( \"rom/programs/cd\", completeDir )\
shell.setCompletionFunction( \"rom/programs/copy\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/delete\", completeEither )\
shell.setCompletionFunction( \"rom/programs/drive\", completeDir )\
shell.setCompletionFunction( \"rom/programs/edit\", completeFile )\
shell.setCompletionFunction( \"rom/programs/eject\", completePeripheral )\
shell.setCompletionFunction( \"rom/programs/gps\", completeGPS )\
shell.setCompletionFunction( \"rom/programs/help\", completeHelp )\
shell.setCompletionFunction( \"rom/programs/id\", completePeripheral )\
shell.setCompletionFunction( \"rom/programs/label\", completeLabel )\
shell.setCompletionFunction( \"rom/programs/list\", completeDir )\
shell.setCompletionFunction( \"rom/programs/mkdir\", completeFile )\
shell.setCompletionFunction( \"rom/programs/monitor\", completeMonitor )\
shell.setCompletionFunction( \"rom/programs/move\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/redstone\", completeRedstone )\
shell.setCompletionFunction( \"rom/programs/rename\", completeEitherEither )\
shell.setCompletionFunction( \"rom/programs/shell\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/type\", completeEither )\
shell.setCompletionFunction( \"rom/programs/set\", completeSet )\
shell.setCompletionFunction( \"rom/programs/advanced/bg\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/advanced/fg\", completeProgram )\
shell.setCompletionFunction( \"rom/programs/fun/dj\", completeDJ )\
shell.setCompletionFunction( \"rom/programs/fun/advanced/paint\", completeFile )\
shell.setCompletionFunction( \"rom/programs/http/pastebin\", completePastebin )\
shell.setCompletionFunction( \"rom/programs/rednet/chat\", completeChat )\
\
-- Run autorun files\
if fs.exists( \"/rom/autorun\" ) and fs.isDir( \"/rom/autorun\" ) then\
\009local tFiles = fs.list( \"/rom/autorun\" )\
\009table.sort( tFiles )\
\009for n, sFile in ipairs( tFiles ) do\
\009\009if string.sub( sFile, 1, 1 ) ~= \".\" then\
\009\009\009local sPath = \"/rom/autorun/\"..sFile\
\009\009\009if not fs.isDir( sPath ) then\
\009\009\009\009shell.run( sPath )\
\009\009\009end\
\009\009end\
\009end\
end\
\
-- Run the user created startup, either from disk drives or the root\
local sUserStartup = nil\
if settings.get( \"shell.allow_startup\" ) then\
    sUserStartup = shell.resolveProgram( \"/startup\" )\
end\
if settings.get( \"shell.allow_disk_startup\" ) then\
    for n,sName in pairs( peripheral.getNames() ) do\
        if disk.isPresent( sName ) and disk.hasData( sName ) then\
            local sDiskStartup = shell.resolveProgram( \"/\" .. disk.getMountPath( sName ) .. \"/startup\" )\
            if sDiskStartup then\
                sUserStartup = sDiskStartup\
                break\
            end\
        end\
    end\
end\
if sUserStartup then\
    shell.run( sUserStartup )\
end",
      "\
local sPath = \"/rom/help\"\
\
function path()\
\009return sPath\
end\
\
function setPath( _sPath )\
\009sPath = _sPath\
end\
\
function lookup( _sTopic )\
 \009-- Look on the path variable\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
    \009sPath = fs.combine( sPath, _sTopic )\
    \009if fs.exists( sPath ) and not fs.isDir( sPath ) then\
\009\009\009return sPath\
    \009end\
    end\
\009\
\009-- Not found\
\009return nil\
end\
\
function topics()\
    -- Add index\
\009local tItems = {\
\009    [ \"index\" ] = true\
\009}\
\009\
\009-- Add topics from the path\
    for sPath in string.gmatch(sPath, \"[^:]+\") do\
\009\009if fs.isDir( sPath ) then\
\009\009\009local tList = fs.list( sPath )\
\009\009\009for n,sFile in pairs( tList ) do\
\009\009\009\009if string.sub( sFile, 1, 1 ) ~= \".\" then\
\009\009\009\009\009if not fs.isDir( fs.combine( sPath, sFile ) ) then\
\009\009\009\009\009\009tItems[ sFile ] = true\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    end\009\
\
\009-- Sort and return\
\009local tItemList = {}\
\009for sItem, b in pairs( tItems ) do\
\009\009table.insert( tItemList, sItem )\
\009end\
\009table.sort( tItemList )\
\009return tItemList\
end\
\
function completeTopic( sText )\
    local tTopics = topics()\
    local tResults = {}\
    for n=1,#tTopics do\
        local sTopic = tTopics[n]\
        if #sTopic > #sText and string.sub( sTopic, 1, #sText ) == sText then\
            table.insert( tResults, string.sub( sTopic, #sText + 1 ) )\
        end\
    end\
\009return tResults\
end",
      "\
-- Minecraft key code bindings\
-- See http://www.minecraftwiki.net/wiki/Key_codes for more info\
\
local tKeys = {\
\009nil,\009 \009\"one\", \009\009\"two\", \009\009\"three\", \009\"four\",\009\009\009-- 1\
\009\"five\", \009\"six\", \009\009\"seven\", \009\"eight\", \009\"nine\",\009\009\009-- 6\
\009\"zero\", \009\"minus\", \009\"equals\", \009\"backspace\",\"tab\",\009\009\009-- 11\
\009\"q\", \009\009\"w\", \009\009\"e\", \009\009\"r\",\009\009\"t\",\009\009\009-- 16\
\009\"y\",\009\009\"u\",\009\009\"i\",\009\009\"o\",\009\009\"p\",\009\009\009-- 21\
\009\"leftBracket\",\"rightBracket\",\"enter\",\"leftCtrl\",\"a\",\009\009\009-- 26\
\009\"s\",\009\009\"d\",\009\009\"f\",\009\009\"g\",\009\009\"h\",\009\009\009-- 31\
\009\"j\",\009\009\"k\",\009\009\"l\",\009\009\"semiColon\",\"apostrophe\",\009-- 36\
\009\"grave\",\009\"leftShift\",\"backslash\",\"z\",\009\009\"x\",\009\009\009-- 41\
\009\"c\",\009\009\"v\",\009\009\"b\",\009\009\"n\",\009\009\"m\",\009\009\009-- 46\
\009\"comma\",\009\"period\",\009\"slash\",\009\"rightShift\",\"multiply\",\009-- 51\
\009\"leftAlt\",\009\"space\",\009\"capsLock\",\009\"f1\",\009\009\"f2\",\009\009\009-- 56\
\009\"f3\",\009\009\"f4\",\009\009\"f5\",\009\009\"f6\",\009\009\"f7\",\009\009\009-- 61\
\009\"f8\",\009\009\"f9\",\009\009\"f10\",\009\009\"numLock\",\009\"scollLock\",\009-- 66\009\
\009\"numPad7\",\009\"numPad8\",\009\"numPad9\",\009\"numPadSubtract\",\"numPad4\",\009-- 71\
\009\"numPad5\",\009\"numPad6\",\009\"numPadAdd\",\"numPad1\",\009\"numPad2\",\009\009-- 76\
\009\"numPad3\",\009\"numPad0\",\009\"numPadDecimal\",nil,\009nil,\009\009\009-- 81\
\009nil,\009 \009\"f11\",\009\009\"f12\",\009\009nil,\009\009nil,\009\009\009-- 86\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 91\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\"f13\",\009\009\009-- 96\
\009\"f14\",\009\009\"f15\",\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 101\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 106\
\009nil,\009\009\"kana\",\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 111\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 116\009\
\009\"convert\",\009nil,\009\009\"noconvert\",nil,\009\009\"yen\",\009\009\009-- 121\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 126\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 131\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 136\
\009\"numPadEquals\",nil,\009\009nil,\009\009\"cimcumflex\",\"at\",\009\009\009-- 141\
\009\"colon\",\009\"underscore\",\"kanji\",\009\"stop\",\009\009\"ax\",\009\009\009-- 146\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 151\
\009\"numPadEnter\",\"rightCtrl\",nil,      nil,\009\009nil,\009\009\009-- 156\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 161\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 166\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 171\
\009nil,\009\009nil,\009\009nil,\009\009\"numPadComma\",nil,\009\009\009-- 176\
\009\"numPadDivide\",nil,\009\009nil,\009\009\"rightAlt\",\009nil,\009\009\009-- 181\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 186\
\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009nil,\009\009\009-- 191\
\009nil,\009\009\"pause\",\009nil,\009\009\"home\",\009\009\"up\",\009\009\009-- 196\
\009\"pageUp\",\009nil,\009\009\"left\",\009\009nil,\009\009\"right\",\009\009-- 201\
\009nil,\009\009\"end\",\009\009\"down\",\009\009\"pageDown\",\009\"insert\",\009\009-- 206\
\009\"delete\"\009\009\009\009\009\009\009\009\009\009\009\009\009\009-- 211\
}\
\
local keys = _ENV\
for nKey, sKey in pairs( tKeys ) do\
\009keys[sKey] = nKey\
end\
keys[\"return\"] = keys.enter\
\
function getName( _nKey )\
\009return tKeys[ _nKey ]\
end",
      "\
local vector = {\
\009add = function( self, o )\
\009\009return vector.new(\
\009\009\009self.x + o.x,\
\009\009\009self.y + o.y,\
\009\009\009self.z + o.z\
\009\009)\
\009end,\
\009sub = function( self, o )\
\009\009return vector.new(\
\009\009\009self.x - o.x,\
\009\009\009self.y - o.y,\
\009\009\009self.z - o.z\
\009\009)\
\009end,\
\009mul = function( self, m )\
\009\009return vector.new(\
\009\009\009self.x * m,\
\009\009\009self.y * m,\
\009\009\009self.z * m\
\009\009)\
\009end,\
\009div = function( self, m )\
\009\009return vector.new(\
\009\009\009self.x / m,\
\009\009\009self.y / m,\
\009\009\009self.z / m\
\009\009)\
\009end,\
\009unm = function( self )\
\009\009return vector.new(\
\009\009\009-self.x,\
\009\009\009-self.y,\
\009\009\009-self.z\
\009\009)\
\009end,\
\009dot = function( self, o )\
\009\009return self.x*o.x + self.y*o.y + self.z*o.z\
\009end,\
\009cross = function( self, o )\
\009\009return vector.new(\
\009\009\009self.y*o.z - self.z*o.y,\
\009\009\009self.z*o.x - self.x*o.z,\
\009\009\009self.x*o.y - self.y*o.x\
\009\009)\
\009end,\
\009length = function( self )\
\009\009return math.sqrt( self.x*self.x + self.y*self.y + self.z*self.z )\
\009end,\
\009normalize = function( self )\
\009\009return self:mul( 1 / self:length() )\
\009end,\
\009round = function( self, nTolerance )\
\009    nTolerance = nTolerance or 1.0\
\009\009return vector.new(\
\009\009\009math.floor( (self.x + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\
\009\009\009math.floor( (self.y + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\
\009\009\009math.floor( (self.z + (nTolerance * 0.5)) / nTolerance ) * nTolerance\
\009\009)\
\009end,\
\009tostring = function( self )\
\009\009return self.x..\",\"..self.y..\",\"..self.z\
\009end,\
}\
\
local vmetatable = {\
\009__index = vector,\
\009__add = vector.add,\
\009__sub = vector.sub,\
\009__mul = vector.mul,\
\009__div = vector.div,\
\009__unm = vector.unm,\
\009__tostring = vector.tostring,\
}\
\
function new( x, y, z )\
\009local v = {\
\009\009x = x or 0,\
\009\009y = y or 0,\
\009\009z = z or 0\
\009}\
\009setmetatable( v, vmetatable )\
\009return v\
end",
      "\
local native = (term.native and term.native()) or term\
local redirectTarget = native\
\
local function wrap( _sFunction )\
\009return function( ... )\
\009\009return redirectTarget[ _sFunction ]( ... )\
\009end\
end\
\
local term = {}\
\
term.redirect = function( target )\
\009if target == nil or type( target ) ~= \"table\" then\
\009\009error( \"Invalid redirect target\", 2 )\
\009end\
    if target == term then\
        error( \"term is not a recommended redirect target, try term.current() instead\", 2 )\
    end\
\009for k,v in pairs( native ) do\
\009\009if type( k ) == \"string\" and type( v ) == \"function\" then\
\009\009\009if type( target[k] ) ~= \"function\" then\
\009\009\009\009target[k] = function()\
\009\009\009\009\009error( \"Redirect object is missing method \"..k..\".\", 2 )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009local oldRedirectTarget = redirectTarget\
\009redirectTarget = target\
\009return oldRedirectTarget\
end\
\
term.current = function()\
    return redirectTarget\
end\
\
term.native = function()\
    -- NOTE: please don't use this function unless you have to.\
    -- If you're running in a redirected or multitasked enviorment, term.native() will NOT be\
    -- the current terminal when your program starts up. It is far better to use term.current()\
    return native\
end\
\
for k,v in pairs( native ) do\
\009if type( k ) == \"string\" and type( v ) == \"function\" then\
\009\009if term[k] == nil then\
\009\009\009term[k] = wrap( k )\
\009\009end\
\009end\
end\
\009\
local env = _ENV\
for k,v in pairs( term ) do\
\009env[k] = v\
end",
      "-- Definition for the IO API\
\
local g_defaultInput = {\
\009bFileHandle = true,\
\009bClosed = false,\
\009close = function( self )\
\009end,\
\009read = function( self, _sFormat )\
\009\009if _sFormat and _sFormat ~= \"*l\" then\
\009\009\009error( \"Unsupported format\" )\
\009\009end\
\009\009return _G.read()\
\009end,\
\009lines = function( self )\
\009\009return function()\
\009\009\009return _G.read()\
\009\009end\
\009end,\
}\
\
local g_defaultOutput = {\
\009bFileHandle = true,\
\009bClosed = false,\
\009close = function( self )\
\009end,\
\009write = function( self, _sText )\
\009\009_G.write( _sText )\
\009end,\
\009flush = function( self )\
\009end,\
}\
\
local g_currentInput = g_defaultInput\
local g_currentOutput = g_defaultOutput\
\
function close( _file )\
\009(_file or g_currentOutput):close()\
end\
\
function flush()\
\009g_currentOutput:flush()\
end\
\
function input( _arg )\
\009if _G.type( _arg ) == \"string\" then\
\009\009g_currentInput = open( _arg, \"r\" )\
\009elseif _G.type( _arg ) == \"table\" then\
\009\009g_currentInput = _arg\
\009elseif _G.type( _arg ) == \"nil\" then\
\009\009return g_currentInput\
\009else\
\009\009error( \"Expected file name or file handle\" )\
\009end\
end\
\
function lines( _sFileName )\
\009if _sFileName then\
\009\009return open( _sFileName, \"r\" ):lines()\
\009else\
\009\009return g_currentInput:lines()\
\009end\
end\
\
function open( _sPath, _sMode )\
\009local sMode = _sMode or \"r\"\
\009local file = fs.open( _sPath, sMode )\
\009if not file then\
\009\009return nil\
\009end\
\009\
\009if sMode == \"r\"then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009read = function( self, _sFormat )\
\009\009\009\009local sFormat = _sFormat or \"*l\"\
\009\009\009\009if sFormat == \"*l\" then\
\009\009\009\009\009return file.readLine()\
\009\009\009\009elseif sFormat == \"*a\" then\
\009\009\009\009\009return file.readAll()\
\009\009\009\009else\
\009\009\009\009\009error( \"Unsupported format\" )\
\009\009\009\009end\
\009\009\009\009return nil\
\009\009\009end,\
\009\009\009lines = function( self )\
\009\009\009\009return function()\
\009\009\009\009\009local sLine = file.readLine()\
\009\009\009\009\009if sLine == nil then\
\009\009\009\009\009\009file.close()\
\009\009\009\009\009\009self.bClosed = true\
\009\009\009\009\009end\
\009\009\009\009\009return sLine\
\009\009\009\009end\
\009\009\009end,\
\009\009}\
\009elseif sMode == \"w\" or sMode == \"a\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009write = function( self, _sText )\
\009\009\009\009file.write( _sText )\
\009\009\009end,\
\009\009\009flush = function( self )\
\009\009\009\009file.flush()\
\009\009\009end,\
\009\009}\
\009\
\009elseif sMode == \"rb\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009read = function( self )\
\009\009\009\009return file.read()\
\009\009\009end,\
\009\009}\
\009\009\
\009elseif sMode == \"wb\" or sMode == \"ab\" then\
\009\009return {\
\009\009\009bFileHandle = true,\
\009\009\009bClosed = false,\009\009\009\009\
\009\009\009close = function( self )\
\009\009\009\009file.close()\
\009\009\009\009self.bClosed = true\
\009\009\009end,\
\009\009\009write = function( self, _number )\
\009\009\009\009file.write( _number )\
\009\009\009end,\
\009\009\009flush = function( self )\
\009\009\009\009file.flush()\
\009\009\009end,\
\009\009}\
\009\
\009else\
\009\009file.close()\
\009\009error( \"Unsupported mode\" )\
\009\009\
\009end\
end\
\
function output( _arg )\
\009if _G.type( _arg ) == \"string\" then\
\009\009g_currentOutput = open( _arg, \"w\" )\
\009elseif _G.type( _arg ) == \"table\" then\
\009\009g_currentOutput = _arg\
\009elseif _G.type( _arg ) == \"nil\" then\
\009\009return g_currentOutput\
\009else\
\009\009error( \"Expected file name or file handle\" )\
\009end\
end\
\
function read( ... )\
\009return input():read( ... )\
end\
\
function type( _handle )\
\009if _G.type( _handle ) == \"table\" and _handle.bFileHandle == true then\
\009\009if _handle.bClosed then\
\009\009\009return \"closed file\"\
\009\009else\
\009\009\009return \"file\"\
\009\009end\
\009end\
\009return nil\
end\
\
function write( ... )\
\009return output():write( ... )\
end",
      "\
function slowWrite( sText, nRate )\
    nRate = nRate or 20\
    if nRate < 0 then\
        error( \"Rate must be positive\", 2 )\
    end\
    local nSleep = 1 / nRate\
        \
    sText = tostring( sText )\
    local x,y = term.getCursorPos(x,y)\
    local len = string.len( sText )\
    \
    for n=1,len do\
        term.setCursorPos( x, y )\
        sleep( nSleep )\
        local nLines = write( string.sub( sText, 1, n ) )\
        local newX, newY = term.getCursorPos()\
        y = newY - nLines\
    end\
end\
\
function slowPrint( sText, nRate )\
    slowWrite( sText, nRate)\
    print()\
end\
\
function formatTime( nTime, bTwentyFourHour )\
    local sTOD = nil\
    if not bTwentyFourHour then\
        if nTime >= 12 then\
            sTOD = \"PM\"\
        else\
            sTOD = \"AM\"\
        end\
        if nTime >= 13 then\
            nTime = nTime - 12\
        end\
    end\
\
    local nHour = math.floor(nTime)\
    local nMinute = math.floor((nTime - nHour)*60)\
    if sTOD then\
        return string.format( \"%d:%02d %s\", nHour, nMinute, sTOD )\
    else\
        return string.format( \"%d:%02d\", nHour, nMinute )\
    end\
end\
\
local function makePagedScroll( _term, _nFreeLines )\
    local nativeScroll = _term.scroll\
    local nFreeLines = _nFreeLines or 0\
    return function( _n )\
        for n=1,_n do\
            nativeScroll( 1 )\
            \
            if nFreeLines <= 0 then\
                local w,h = _term.getSize()\
                _term.setCursorPos( 1, h )\
                _term.write( \"Press any key to continue\" )\
                os.pullEvent( \"key\" )\
                _term.clearLine()\
                _term.setCursorPos( 1, h )\
            else\
                nFreeLines = nFreeLines - 1\
            end\
        end\
    end\
end\
\
function pagedPrint( _sText, _nFreeLines )\
    -- Setup a redirector\
    local oldTerm = term.current()\
    local newTerm = {}\
    for k,v in pairs( oldTerm ) do\
        newTerm[k] = v\
    end\
    newTerm.scroll = makePagedScroll( oldTerm, _nFreeLines )\
    term.redirect( newTerm )\
\
    -- Print the text\
    local result\
    local ok, err = pcall( function()\
        if _sText ~= nil then\
            result = print( _sText )\
        else\
            result = print()\
        end\
    end )\
\
    -- Removed the redirector\
    term.redirect( oldTerm )\
\
    -- Propogate errors\
    if not ok then\
        error( err, 0 )\
    end\
    return result\
end\
\
local function tabulateCommon( bPaged, ... )\
    local tAll = { ... }\
    \
    local w,h = term.getSize()\
    local nMaxLen = w / 8\
    for n, t in ipairs( tAll ) do\
        if type(t) == \"table\" then\
            for n, sItem in pairs(t) do\
                nMaxLen = math.max( string.len( sItem ) + 1, nMaxLen )\
            end\
        end\
    end\
    local nCols = math.floor( w / nMaxLen )\
    local nLines = 0\
    local function newLine()\
        if bPaged and nLines >= (h-3) then\
            pagedPrint()\
        else\
            print()\
        end\
        nLines = nLines + 1\
    end\
    \
    local function drawCols( _t )\
        local nCol = 1\
        for n, s in ipairs( _t ) do\
            if nCol > nCols then\
                nCol = 1\
                newLine()\
            end\
\
            local cx, cy = term.getCursorPos()\
            cx = 1 + ((nCol - 1) * nMaxLen)\
            term.setCursorPos( cx, cy )\
            term.write( s )\
\
            nCol = nCol + 1      \
        end\
        print()\
    end\
    for n, t in ipairs( tAll ) do\
        if type(t) == \"table\" then\
            if #t > 0 then\
                drawCols( t )\
            end\
        elseif type(t) == \"number\" then\
            term.setTextColor( t )\
        end\
    end    \
end\
\
function tabulate( ... )\
    tabulateCommon( false, ... )\
end\
\
function pagedTabulate( ... )\
    tabulateCommon( true, ... )\
end\
\
local g_tLuaKeywords = {\
    [ \"and\" ] = true,\
    [ \"break\" ] = true,\
    [ \"do\" ] = true,\
    [ \"else\" ] = true,\
    [ \"elseif\" ] = true,\
    [ \"end\" ] = true,\
    [ \"false\" ] = true,\
    [ \"for\" ] = true,\
    [ \"function\" ] = true,\
    [ \"if\" ] = true,\
    [ \"in\" ] = true,\
    [ \"local\" ] = true,\
    [ \"nil\" ] = true,\
    [ \"not\" ] = true,\
    [ \"or\" ] = true,\
    [ \"repeat\" ] = true,\
    [ \"return\" ] = true,\
    [ \"then\" ] = true,\
    [ \"true\" ] = true,\
    [ \"until\" ] = true,\
    [ \"while\" ] = true,\
}\
\
local function serializeImpl( t, tTracking, sIndent )\
    local sType = type(t)\
    if sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            -- Empty tables are simple\
            return \"{}\"\
        else\
            -- Other tables take more work\
            local sResult = \"{\\n\"\
            local sSubIndent = sIndent .. \"  \"\
            local tSeen = {}\
            for k,v in ipairs(t) do\
                tSeen[k] = true\
                sResult = sResult .. sSubIndent .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
            end\
            for k,v in pairs(t) do\
                if not tSeen[k] then\
                    local sEntry\
                    if type(k) == \"string\" and not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        sEntry = k .. \" = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
                    else\
                        sEntry = \"[ \" .. serializeImpl( k, tTracking, sSubIndent ) .. \" ] = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\
                    end\
                    sResult = sResult .. sSubIndent .. sEntry\
                end\
            end\
            sResult = sResult .. sIndent .. \"}\"\
            return sResult\
        end\
        \
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
    \
    elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\
        return tostring(t)\
        \
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
        \
    end\
end\
\
empty_json_array = {}\
\
local function serializeJSONImpl( t, tTracking, bNBTStyle )\
    local sType = type(t)\
    if t == empty_json_array then\
        return \"[]\"\
\
    elseif sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            -- Empty tables are simple\
            return \"{}\"\
        else\
            -- Other tables take more work\
            local sObjectResult = \"{\"\
            local sArrayResult = \"[\"\
            local nObjectSize = 0\
            local nArraySize = 0\
            for k,v in pairs(t) do\
                if type(k) == \"string\" then\
                    local sEntry\
                    if bNBTStyle then\
                        sEntry = tostring(k) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\
                    else\
                        sEntry = string.format( \"%q\", k ) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\
                    end\
                    if nObjectSize == 0 then\
                        sObjectResult = sObjectResult .. sEntry\
                    else\
                        sObjectResult = sObjectResult .. \",\" .. sEntry\
                    end\
                    nObjectSize = nObjectSize + 1\
                end\
            end\
            for n,v in ipairs(t) do\
                local sEntry = serializeJSONImpl( v, tTracking, bNBTStyle )\
                if nArraySize == 0 then\
                    sArrayResult = sArrayResult .. sEntry\
                else\
                    sArrayResult = sArrayResult .. \",\" .. sEntry\
                end\
                nArraySize = nArraySize + 1\
            end\
            sObjectResult = sObjectResult .. \"}\"\
            sArrayResult = sArrayResult .. \"]\"\
            if nObjectSize > 0 or nArraySize == 0 then\
                return sObjectResult\
            else\
                return sArrayResult\
            end\
        end\
\
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
\
    elseif sType == \"number\" or sType == \"boolean\" then\
        return tostring(t)\
\
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
\
    end\
end\
\
function serialize( t )\
    local tTracking = {}\
    return serializeImpl( t, tTracking, \"\" )\
end\
\
function unserialize( s )\
    local func = load( \"return \"..s, \"unserialize\", \"t\", {} )\
    if func then\
        local ok, result = pcall( func )\
        if ok then\
            return result\
        end\
    end\
    return nil\
end\
\
function serializeJSON( t, bNBTStyle )\
    local tTracking = {}\
    return serializeJSONImpl( t, tTracking, bNBTStyle or false )\
end\
\
function urlEncode( str )\
    if str then\
        str = string.gsub(str, \"\\n\", \"\\r\\n\")\
        str = string.gsub(str, \"([^A-Za-z0-9 %-%_%.])\", function(c)\
            local n = string.byte(c)\
            if n < 128 then\
                -- ASCII\
                return string.format(\"%%%02X\", n)\
            else\
                -- Non-ASCII (encode as UTF-8)\
                return\
                    string.format(\"%%%02X\", 192 + bit32.band( bit32.arshift(n,6), 31 ) ) ..\
                    string.format(\"%%%02X\", 128 + bit32.band( n, 63 ) )\
            end\
        end )\
        str = string.gsub(str, \" \", \"+\")\
    end\
    return str    \
end\
\
local tEmpty = {}\
function complete( sSearchText, tSearchTable )\
    local nStart = 1\
    local nDot = string.find( sSearchText, \".\", nStart, true )\
    local tTable = tSearchTable or _ENV\
    while nDot do\
        local sPart = string.sub( sSearchText, nStart, nDot - 1 )\
        local value = tTable[ sPart ]\
        if type( value ) == \"table\" then\
            tTable = value\
            nStart = nDot + 1\
            nDot = string.find( sSearchText, \".\", nStart, true )\
        else\
            return tEmpty\
        end\
    end\
\
    local sPart = string.sub( sSearchText, nStart, nDot )\
    local nPartLength = string.len( sPart )\
\
    local tResults = {}\
    local tSeen = {}\
    while tTable do\
        for k,v in pairs( tTable ) do\
            if not tSeen[k] and type(k) == \"string\" then\
                if string.find( k, sPart, 1, true ) == 1 then\
                    if not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        local sResult = string.sub( k, nPartLength + 1 )\
                        if type(v) == \"function\" then\
                            sResult = sResult .. \"(\"\
                        elseif type(v) == \"table\" and next(v) ~= nil then\
                            sResult = sResult .. \".\"\
                        end\
                        table.insert( tResults, sResult )\
                    end\
                end\
            end\
            tSeen[k] = true\
        end\
        local tMetatable = getmetatable( tTable )\
        if tMetatable and type( tMetatable.__index ) == \"table\" then\
            tTable = tMetatable.__index\
        else\
            tTable = nil\
        end\
    end\
\
    table.sort( tResults )\
    return tResults\
end\
\
-- GB versions\
serialise = serialize\
unserialise = unserialize\
serialiseJSON = serializeJSON",
      "-- Colors\
white = 1\
orange = 2\
magenta = 4\
lightBlue = 8\
yellow = 16\
lime = 32\
pink = 64\
gray = 128\
lightGray = 256\
cyan = 512\
purple = 1024\
blue = 2048\
brown = 4096\
green = 8192\
red = 16384\
black = 32768\
\
function combine( ... )\
    local r = 0\
    for n,c in ipairs( { ... } ) do\
        r = bit32.bor(r,c)\
    end\
    return r\
end\
\
function subtract( colors, ... )\
\009local r = colors\
\009for n,c in ipairs( { ... } ) do\
\009\009r = bit32.band(r, bit32.bnot(c))\
\009end\
\009return r\
end\
\
function test( colors, color )\
    return ((bit32.band(colors, color)) == color)\
end",
      "\
CHANNEL_BROADCAST = 65535\
CHANNEL_REPEAT = 65533\
\
local tReceivedMessages = {}\
local tReceivedMessageTimeouts = {}\
local tHostnames = {}\
\
function open( sModem )\
\009if type( sModem ) ~= \"string\" then\
\009\009error( \"expected string\", 2 )\
\009end\
\009if peripheral.getType( sModem ) ~= \"modem\" then\009\
\009\009error( \"No such modem: \"..sModem, 2 )\
\009end\
\009peripheral.call( sModem, \"open\", os.getComputerID() )\
\009peripheral.call( sModem, \"open\", CHANNEL_BROADCAST )\
end\
\
function close( sModem )\
    if sModem then\
        -- Close a specific modem\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) ~= \"modem\" then\
            error( \"No such modem: \"..sModem, 2 )\
        end\
        peripheral.call( sModem, \"close\", os.getComputerID() )\
        peripheral.call( sModem, \"close\", CHANNEL_BROADCAST )\
    else\
        -- Close all modems\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                close( sModem )\
            end\
        end\
    end\
end\
\
function isOpen( sModem )\
    if sModem then\
        -- Check if a specific modem is open\
        if type( sModem ) ~= \"string\" then\
            error( \"expected string\", 2 )\
        end\
        if peripheral.getType( sModem ) == \"modem\" then\
            return peripheral.call( sModem, \"isOpen\", os.getComputerID() ) and peripheral.call( sModem, \"isOpen\", CHANNEL_BROADCAST )\
        end\
    else\
        -- Check if any modem is open\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                return true\
            end\
        end\
    end\
\009return false\
end\
\
function send( nRecipient, message, sProtocol )\
    -- Generate a (probably) unique message ID\
    -- We could do other things to guarantee uniqueness, but we really don't need to\
    -- Store it to ensure we don't get our own messages back\
    local nMessageID = math.random( 1, 2147483647 )\
    tReceivedMessages[ nMessageID ] = true\
    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\
    -- Create the message\
    local nReplyChannel = os.getComputerID()\
    local tMessage = {\
        nMessageID = nMessageID,\
        nRecipient = nRecipient,\
        message = message,\
        sProtocol = sProtocol,\
    }\
\
    if nRecipient == os.getComputerID() then\
        -- Loopback to ourselves\
        os.queueEvent( \"rednet_message\", nReplyChannel, message, sProtocol )\
\
    else\
        -- Send on all open modems, to the target and to repeaters\
        local sent = false\
        for n,sModem in ipairs( peripheral.getNames() ) do\
            if isOpen( sModem ) then\
                peripheral.call( sModem, \"transmit\", nRecipient, nReplyChannel, tMessage );\
                peripheral.call( sModem, \"transmit\", CHANNEL_REPEAT, nReplyChannel, tMessage );\
                sent = true\
            end\
        end\
    end\
end\
\
function broadcast( message, sProtocol )\
\009send( CHANNEL_BROADCAST, message, sProtocol )\
end\
\
function receive( sProtocolFilter, nTimeout )\
    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility\
    if type(sProtocolFilter) == \"number\" and nTimeout == nil then\
        sProtocolFilter, nTimeout = nil, sProtocolFilter\
    end\
\
    -- Start the timer\
\009local timer = nil\
\009local sFilter = nil\
\009if nTimeout then\
\009\009timer = os.startTimer( nTimeout )\
\009\009sFilter = nil\
\009else\
\009\009sFilter = \"rednet_message\"\
\009end\
\
\009-- Wait for events\
\009while true do\
\009\009local sEvent, p1, p2, p3 = os.pullEvent( sFilter )\
\009\009if sEvent == \"rednet_message\" then\
\009\009    -- Return the first matching rednet_message\
\009\009\009local nSenderID, message, sProtocol = p1, p2, p3\
\009\009\009if sProtocolFilter == nil or sProtocol == sProtocolFilter then\
    \009\009\009return nSenderID, message, sProtocol\
    \009    end\
\009\009elseif sEvent == \"timer\" then\
\009\009    -- Return nil if we timeout\
\009\009    if p1 == timer then\
    \009\009\009return nil\
    \009\009end\
\009\009end\
\009end\
end\
\
function host( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" or type( sHostname ) ~= \"string\" then\
        error( \"expected string, string\", 2 )\
    end\
    if sHostname == \"localhost\" then\
        error( \"Reserved hostname\", 2 )\
    end\
    if tHostnames[ sProtocol ] ~= sHostname then\
        if lookup( sProtocol, sHostname ) ~= nil then\
            error( \"Hostname in use\", 2 )\
        end\
        tHostnames[ sProtocol ] = sHostname\
    end\
end\
\
function unhost( sProtocol )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
    tHostnames[ sProtocol ] = nil\
end\
\
function lookup( sProtocol, sHostname )\
    if type( sProtocol ) ~= \"string\" then\
        error( \"expected string\", 2 )\
    end\
\
    -- Build list of host IDs\
    local tResults = nil\
    if sHostname == nil then\
        tResults = {}\
    end\
\
    -- Check localhost first\
    if tHostnames[ sProtocol ] then\
        if sHostname == nil then\
            table.insert( tResults, os.getComputerID() )\
        elseif sHostname == \"localhost\" or sHostname == tHostnames[ sProtocol ] then\
            return os.getComputerID()\
        end\
    end\
\
    if not isOpen() then\
        if tResults then\
            return table.unpack( tResults )\
        end\
        return nil\
    end\
\
    -- Broadcast a lookup packet\
    broadcast( {\
        sType = \"lookup\",\
        sProtocol = sProtocol,\
        sHostname = sHostname,\
    }, \"dns\" )\
\
    -- Start a timer\
    local timer = os.startTimer( 2 )\
\
    -- Wait for events\
    while true do\
        local event, p1, p2, p3 = os.pullEvent()\
        if event == \"rednet_message\" then\
            -- Got a rednet message, check if it's the response to our request\
            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3\
            if sMessageProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup response\" then\
                if tMessage.sProtocol == sProtocol then\
                    if sHostname == nil then\
                        table.insert( tResults, nSenderID )\
                    elseif tMessage.sHostname == sHostname then\
                        return nSenderID\
                    end\
                end\
            end\
        else\
            -- Got a timer event, check it's the end of our timeout\
            if p1 == timer then\
                break\
            end\
        end\
    end\
    if tResults then\
        return table.unpack( tResults )\
    end\
    return nil\
end\
\
local bRunning = false\
function run()\
\009if bRunning then\
\009\009error( \"rednet is already running\", 2 )\
\009end\
\009bRunning = true\
\009\
\009while bRunning do\
\009\009local sEvent, p1, p2, p3, p4 = os.pullEventRaw()\
\009\009if sEvent == \"modem_message\" then\
\009\009\009-- Got a modem message, process it and add it to the rednet event queue\
    \009\009local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4\
\009\009    if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then\
    \009\009\009if type( tMessage ) == \"table\" and tMessage.nMessageID then\
\009    \009\009\009if not tReceivedMessages[ tMessage.nMessageID ] then\
\009\009    \009\009\009tReceivedMessages[ tMessage.nMessageID ] = true\
                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\
\009\009\009    \009\009os.queueEvent( \"rednet_message\", nReplyChannel, tMessage.message, tMessage.sProtocol )\
\009\009\009\009    end\
\009\009\009    end\
\009\009\009end\
\
\009\009elseif sEvent == \"rednet_message\" then\
\009\009    -- Got a rednet message (queued from above), respond to dns lookup\
\009\009    local nSenderID, tMessage, sProtocol = p1, p2, p3\
\009\009    if sProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup\" then\
\009\009        local sHostname = tHostnames[ tMessage.sProtocol ]\
\009\009        if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then\
\009\009            rednet.send( nSenderID, {\
\009\009                sType = \"lookup response\",\
\009\009                sHostname = sHostname,\
\009\009                sProtocol = tMessage.sProtocol,\
\009\009            }, \"dns\" )\
\009\009        end\
\009\009    end\
\
\009\009elseif sEvent == \"timer\" then\
            -- Got a timer event, use it to clear the event queue\
            local nTimer = p1\
            local nMessage = tReceivedMessageTimeouts[ nTimer ]\
            if nMessage then\
                tReceivedMessageTimeouts[ nTimer ] = nil\
                tReceivedMessages[ nMessage ] = nil\
            end\
\009\009end\
\009end\
end",
      "local native = peripheral\
\
function getNames()\
\009local tResults = {}\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.isPresent( sSide ) then\
\009\009\009table.insert( tResults, sSide )\
\009\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009\009local tRemote = native.call( sSide, \"getNamesRemote\" )\
\009\009\009\009for n,sName in ipairs( tRemote ) do\
\009\009\009\009\009table.insert( tResults, sName )\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\009return tResults\
end\
\
function isPresent( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return true\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return true\
\009\009\009end\
\009\009end\
\009end\
\009return false\
end\
\
function getType( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.getType( _sSide )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"getTypeRemote\", _sSide ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function getMethods( _sSide )\
    if type( _sSide ) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.getMethods( _sSide )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"getMethodsRemote\", _sSide ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function call( _sSide, _sMethod, ... )\
    if type( _sSide ) ~= \"string\" or type( _sMethod ) ~= \"string\" then\
        error( \"Expected string, string\", 2 )\
    end\
\009if native.isPresent( _sSide ) then\
\009\009return native.call( _sSide, _sMethod, ... )\
\009end\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\
\009\009\009if native.call( sSide, \"isPresentRemote\", _sSide )  then\
\009\009\009\009return native.call( sSide, \"callRemote\", _sSide, _sMethod, ... ) \
\009\009\009end\
\009\009end\
\009end\
\009return nil\
end\
\
function wrap( _sSide )\
    if type( _sSide ) ~= \"string\"  then\
        error( \"Expected string\", 2 )\
    end\
\009if peripheral.isPresent( _sSide ) then\
\009\009local tMethods = peripheral.getMethods( _sSide )\
\009\009local tResult = {}\
\009\009for n,sMethod in ipairs( tMethods ) do\
\009\009\009tResult[sMethod] = function( ... )\
\009\009\009\009return peripheral.call( _sSide, sMethod, ... )\
\009\009\009end\
\009\009end\
\009\009return tResult\
\009end\
\009return nil\
end\
\
function find( sType, fnFilter )\
    if type( sType ) ~= \"string\" or (fnFilter ~= nil and type( fnFilter ) ~= \"function\") then\
        error( \"Expected string, [function]\", 2 )\
    end\
\009local tResults = {}\
\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009if peripheral.getType( sName ) == sType then\
\009\009\009local wrapped = peripheral.wrap( sName )\
\009\009\009if fnFilter == nil or fnFilter( sName, wrapped ) then\
\009\009\009\009table.insert( tResults, wrapped )\
\009\009\009end\
\009\009end\
\009end\
\009return table.unpack( tResults )\
end",
      "\
local tSettings = {}\
\
function set( sName, value )\
    if type(sName) ~= \"string\" or\
       (type(value) ~= \"string\" and type(value) ~= \"number\" and type(value) ~= \"boolean\" and type(value) ~= \"table\") then\
        error( \"Expected string, value\", 2 )\
    end\
    if type(value) == \"table\" then\
        -- Ensure value is serializeable\
        value = textutils.unserialize( textutils.serialize(value) )\
    end\
    tSettings[ sName ] = value\
end\
\
local copy\
function copy( value )\
    if type(value) == \"table\" then\
        local result = {}\
        for k,v in pairs(value) do\
            result[k] = copy(v)\
        end\
        return result\
    else\
        return value\
    end\
end\
\
function get( sName, default )\
    if type(sName) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local result = tSettings[ sName ]\
    if result ~= nil then\
        return copy(result)\
    else\
        return default\
    end\
end\
\
function unset( sName )\
    if type(sName) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    tSettings[ sName ] = nil\
end\
\
function clear()\
    tSettings = {}\
end\
\
function getNames()\
    local result = {}\
    for k,v in pairs( tSettings ) do\
        result[ #result + 1 ] = k\
    end\
    return result\
end\
\
function load( sPath )\
    if type(sPath) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local file = fs.open( sPath, \"r\" )\
    if not file then\
        return false\
    end\
\
    local sText = file.readAll()\
    file.close()\
\
    local tFile = textutils.unserialize( sText )\
    if type(tFile) ~= \"table\" then\
        return false\
    end\
\
    for k,v in pairs(tFile) do\
        if type(k) == \"string\" and\
           (type(v) == \"string\" or type(v) == \"number\" or type(v) == \"boolean\" or type(v) == \"table\") then\
            set( k, v )\
        end\
    end\
\
    return true\
end\
\
function save( sPath )\
    if type(sPath) ~= \"string\" then\
        error( \"Expected string\", 2 )\
    end\
    local file = fs.open( sPath, \"w\" )\
    if not file then\
        return false\
    end\
\
    file.write( textutils.serialize( tSettings ) )\
    file.close()\
\
    return true\
end",
      "\
local function create( first, ... )\
\009if first ~= nil then\
\009    if type( first ) ~= \"function\" then\
    \009\009error( \"Expected function, got \"..type( first ), 3 )\
    \009end\
 \009\009return coroutine.create(first), create( ... )\
    end\
    return nil\
end\
\
local function runUntilLimit( _routines, _limit )\
    local count = #_routines\
    local living = count\
    \
    local tFilters = {}\
    local eventData = {}\
    while true do\
    \009for n=1,count do\
    \009\009local r = _routines[n]\
    \009\009if r then\
    \009\009\009if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == \"terminate\" then\
\009    \009\009\009local ok, param = coroutine.resume( r, table.unpack(eventData) )\
\009\009\009\009\009if not ok then\
\009\009\009\009\009\009error( param, 0 )\
\009\009\009\009\009else\
\009\009\009\009\009\009tFilters[r] = param\
\009\009\009\009\009end\
\009\009\009\009\009if coroutine.status( r ) == \"dead\" then\
\009\009\009\009\009\009_routines[n] = nil\
\009\009\009\009\009\009living = living - 1\
\009\009\009\009\009\009if living <= _limit then\
\009\009\009\009\009\009\009return n\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
    \009\009end\
    \009end\
\009\009for n=1,count do\
    \009\009local r = _routines[n]\
\009\009\009if r and coroutine.status( r ) == \"dead\" then\
\009\009\009\009_routines[n] = nil\
\009\009\009\009living = living - 1\
\009\009\009\009if living <= _limit then\
\009\009\009\009\009return n\
\009\009\009\009end\
\009\009\009end\
\009\009end\
    \009eventData = { os.pullEventRaw() }\
    end\
end\
\
function waitForAny( ... )\
    local routines = { create( ... ) }\
    return runUntilLimit( routines, #routines - 1 )\
end\
\
function waitForAll( ... )\
    local routines = { create( ... ) }\
\009runUntilLimit( routines, 0 )\
end",
      "\
local function isDrive( name )\
\009return peripheral.getType( name ) == \"drive\"\
end\
\
function isPresent( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"isDiskPresent\" )\
\009end\
\009return false\
end\
\
function getLabel( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getDiskLabel\" )\
\009end\
\009return nil\
end\
\
function setLabel( name, label )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"setDiskLabel\", label )\
\009end\
end\
\
function hasData( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"hasData\" )\
\009end\
\009return false\
end\
\
function getMountPath( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getMountPath\" )\
\009end\
\009return nil\
end\
\
function hasAudio( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"hasAudio\" )\
\009end\
\009return false\
end\
\
function getAudioTitle( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getAudioTitle\" )\
\009end\
\009return nil\
end\
\
function playAudio( name )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"playAudio\" )\
\009end\
end\
\
function stopAudio( name )\
\009if not name then\
\009\009for n,sName in ipairs( peripheral.getNames() ) do\
\009\009\009stopAudio( sName )\
\009\009end\
\009else\
\009\009if isDrive( name ) then\
\009\009\009peripheral.call( name, \"stopAudio\" )\
\009\009end\
\009end\
end\
\
function eject( name )\
\009if isDrive( name ) then\
\009\009peripheral.call( name, \"ejectDisk\" )\
\009end\
end\
\
function getID( name )\
\009if isDrive( name ) then\
\009\009return peripheral.call( name, \"getDiskID\" )\
\009end\
\009return nil\
end",
      "\
CHANNEL_GPS = 65534\
\
local function trilaterate( A, B, C )\
\009local a2b = B.vPosition - A.vPosition\
\009local a2c = C.vPosition - A.vPosition\
\009\009\
\009if math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then\
\009\009return nil\
\009end\
\009\
\009local d = a2b:length()\
\009local ex = a2b:normalize( )\
\009local i = ex:dot( a2c )\
\009local ey = (a2c - (ex * i)):normalize()\
\009local j = ey:dot( a2c )\
\009local ez = ex:cross( ey )\
\
\009local r1 = A.nDistance\
\009local r2 = B.nDistance\
\009local r3 = C.nDistance\
\009\009\
\009local x = (r1*r1 - r2*r2 + d*d) / (2*d)\
\009local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)\
\009\009\
\009local result = A.vPosition + (ex * x) + (ey * y)\
\
\009local zSquared = r1*r1 - x*x - y*y\
\009if zSquared > 0 then\
\009\009local z = math.sqrt( zSquared )\
\009\009local result1 = result + (ez * z)\
\009\009local result2 = result - (ez * z)\
\009\009\
\009\009local rounded1, rounded2 = result1:round( 0.01 ), result2:round( 0.01 )\
\009\009if rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then\
\009\009\009return rounded1, rounded2\
\009\009else\
\009\009\009return rounded1\
\009\009end\
\009end\
\009return result:round( 0.01 )\
\009\
end\
\
local function narrow( p1, p2, fix )\
\009local dist1 = math.abs( (p1 - fix.vPosition):length() - fix.nDistance )\
\009local dist2 = math.abs( (p2 - fix.vPosition):length() - fix.nDistance )\
\009\
\009if math.abs(dist1 - dist2) < 0.01 then\
\009\009return p1, p2\
\009elseif dist1 < dist2 then\
\009\009return p1:round( 0.01 )\
\009else\
\009\009return p2:round( 0.01 )\
\009end\
end\
\
function locate( _nTimeout, _bDebug )\
    -- Let command computers use their magic fourth-wall-breaking special abilities\
    if commands then\
        return commands.getBlockPosition()\
    end\
\
\009-- Find a modem\
\009local sModemSide = nil\
\009for n,sSide in ipairs( rs.getSides() ) do\
\009\009if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\009\
\009\009\009sModemSide = sSide\
\009\009\009break\
\009\009end\
\009end\
\
\009if sModemSide == nil then\
\009\009if _bDebug then\
\009\009\009print( \"No wireless modem attached\" )\
\009\009end\
\009\009return nil\
\009end\
\009\
\009if _bDebug then\
\009\009print( \"Finding position...\" )\
\009end\
\009\
\009-- Open a channel\
\009local modem = peripheral.wrap( sModemSide )\
\009local bCloseChannel = false\
\009if not modem.isOpen( os.getComputerID() ) then\
\009\009modem.open( os.getComputerID() )\
\009\009bCloseChannel = true\
\009end\
\009\
\009-- Send a ping to listening GPS hosts\
\009modem.transmit( CHANNEL_GPS, os.getComputerID(), \"PING\" )\
\009\009\
\009-- Wait for the responses\
\009local tFixes = {}\
\009local pos1, pos2 = nil, nil\
\009local timeout = os.startTimer( _nTimeout or 2 )\
\009while true do\
\009\009local e, p1, p2, p3, p4, p5 = os.pullEvent()\
\009\009if e == \"modem_message\" then\
\009\009\009-- We received a reply from a modem\
\009\009\009local sSide, sChannel, sReplyChannel, tMessage, nDistance = p1, p2, p3, p4, p5\
\009\009\009if sSide == sModemSide and sChannel == os.getComputerID() and sReplyChannel == CHANNEL_GPS and nDistance then\
\009\009\009\009-- Received the correct message from the correct modem: use it to determine position\
\009\009\009\009if type(tMessage) == \"table\" and #tMessage == 3 then\
\009\009\009\009\009local tFix = { vPosition = vector.new( tMessage[1], tMessage[2], tMessage[3] ), nDistance = nDistance }\
\009\009\009\009\009if _bDebug then\
\009\009\009\009\009\009print( tFix.nDistance..\" metres from \"..tostring( tFix.vPosition ) )\
\009\009\009\009\009end\
\009\009\009\009\009if tFix.nDistance == 0 then\
\009\009\009\009\009    pos1, pos2 = tFix.vPosition, nil\
\009\009\009\009\009else\
                        table.insert( tFixes, tFix )\
                        if #tFixes >= 3 then\
                            if not pos1 then\
                                pos1, pos2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )\
                            else\
                                pos1, pos2 = narrow( pos1, pos2, tFixes[#tFixes] )\
                            end\
                        end\
                    end\
\009\009\009\009\009if pos1 and not pos2 then\
\009\009\009\009\009\009break\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\009\009\009\
\009\009elseif e == \"timer\" then\
\009\009\009-- We received a timeout\
\009\009\009local timer = p1\
\009\009\009if timer == timeout then\
\009\009\009\009break\
\009\009\009end\
\009\009\
\009\009end \
\009end\
\009\
\009-- Close the channel, if we opened one\
\009if bCloseChannel then\
\009\009modem.close( os.getComputerID() )\
\009end\
\009\
\009-- Return the response\
\009if pos1 and pos2 then\
\009\009if _bDebug then\
\009\009\009print( \"Ambiguous position\" )\
\009\009\009print( \"Could be \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z..\" or \"..pos2.x..\",\"..pos2.y..\",\"..pos2.z )\
\009\009end\
\009\009return nil\
\009elseif pos1 then\
\009\009if _bDebug then\
\009\009\009print( \"Position is \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z )\
\009\009end\
\009\009return pos1.x, pos1.y, pos1.z\
\009else\
\009\009if _bDebug then\
\009\009\009print( \"Could not determine position\" )\
\009\009end\
\009\009return nil\
\009end\
end",
      "\
if not commands then\
\009error( \"Cannot load command API on normal computer\", 2 )\
end\
native = commands.native or commands\
\
local function collapseArgs( errorDepth, bJSONIsNBT, arg1, ... )\
    if arg1 ~= nil then\
        if type(arg1) == \"boolean\" or type(arg1) == \"number\" or type(arg1) == \"string\" then\
            return tostring(arg1) .. \" \" .. collapseArgs( errorDepth + 1, bJSONIsNBT, ... )\
        elseif type(arg1) == \"table\" then\
            return textutils.serialiseJSON( arg1, bJSONIsNBT ) .. \" \" .. collapseArgs( errorDepth + 1, bJSONIsNBT, ... )\
        else\
            error( \"Expected string, number, boolean or table\", errorDepth )\
        end\
    end\
    return \"\"\
end\
\
-- Put native functions into the environment\
local env = _ENV\
for k,v in pairs( native ) do\
    env[k] = v\
end\
\
-- Create wrapper functions for all the commands\
local tAsync = {}\
local tNonNBTJSONCommands = {\
    [ \"tellraw\" ] = true,\
    [ \"title\" ] = true\
}\
local tCommands = native.list()\
for n,sCommandName in ipairs(tCommands) do\
    if env[ sCommandName ] == nil then\
        local bJSONIsNBT = (tNonNBTJSONCommands[ sCommandName ] == nil)\
        env[ sCommandName ] = function( ... )\
            local sCommand = sCommandName .. \" \" .. collapseArgs( 3, bJSONIsNBT, ... )\
            return native.exec( sCommand )\
        end\
        tAsync[ sCommandName ] = function( ... )\
            local sCommand = sCommandName .. \" \" .. collapseArgs( 3, bJSONIsNBT, ... )\
            return native.execAsync( sCommand )\
        end\
    end\
end\
env.async = tAsync",
      "\
local tHex = {\
    [ colors.white ] = \"0\",\
    [ colors.orange ] = \"1\",\
    [ colors.magenta ] = \"2\",\
    [ colors.lightBlue ] = \"3\",\
    [ colors.yellow ] = \"4\",\
    [ colors.lime ] = \"5\",\
    [ colors.pink ] = \"6\",\
    [ colors.gray ] = \"7\",\
    [ colors.lightGray ] = \"8\",\
    [ colors.cyan ] = \"9\",\
    [ colors.purple ] = \"a\",\
    [ colors.blue ] = \"b\",\
    [ colors.brown ] = \"c\",\
    [ colors.green ] = \"d\",\
    [ colors.red ] = \"e\",\
    [ colors.black ] = \"f\",\
}\
\
local string_rep = string.rep\
local string_sub = string.sub\
\
function create( parent, nX, nY, nWidth, nHeight, bStartVisible )\
\
    if type( parent ) ~= \"table\" or\
       type( nX ) ~= \"number\" or\
       type( nY ) ~= \"number\" or\
       type( nWidth ) ~= \"number\" or\
       type( nHeight ) ~= \"number\" or\
       (bStartVisible ~= nil and type( bStartVisible ) ~= \"boolean\") then\
        error( \"Expected object, number, number, number, number, [boolean]\", 2 )\
    end\
\
    if parent == term then\
        error( \"term is not a recommended window parent, try term.current() instead\", 2 )\
    end\
\
    local sEmptySpaceLine\
    local tEmptyColorLines = {}\
    local function createEmptyLines( nWidth )\
        sEmptySpaceLine = string_rep( \" \", nWidth )\
        for n=0,15 do\
            local nColor = 2^n\
            local sHex = tHex[nColor]\
            tEmptyColorLines[nColor] = string_rep( sHex, nWidth )\
        end\
    end\
\
    createEmptyLines( nWidth )\
\
    -- Setup\
    local bVisible = (bStartVisible ~= false)\
    local nCursorX = 1\
    local nCursorY = 1\
    local bCursorBlink = false\
    local nTextColor = colors.white\
    local nBackgroundColor = colors.black\
    local tLines = {}\
    do\
        local sEmptyText = sEmptySpaceLine\
        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
        for y=1,nHeight do\
            tLines[y] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
        end\
    end\
\
    -- Helper functions\
    local function updateCursorPos()\
        if nCursorX >= 1 and nCursorY >= 1 and\
           nCursorX <= nWidth and nCursorY <= nHeight then\
            parent.setCursorPos( nX + nCursorX - 1, nY + nCursorY - 1 )\
        else\
            parent.setCursorPos( 0, 0 )\
        end\
    end\
    \
    local function updateCursorBlink()\
        parent.setCursorBlink( bCursorBlink )\
    end\
    \
    local function updateCursorColor()\
        parent.setTextColor( nTextColor )\
    end\
    \
    local function redrawLine( n )\
        local tLine = tLines[ n ]\
        parent.setCursorPos( nX, nY + n - 1 )\
        parent.blit( tLine.text, tLine.textColor, tLine.backgroundColor )\
    end\
\
    local function redraw()\
        for n=1,nHeight do\
            redrawLine( n )\
        end\
    end\
\
    local function internalBlit( sText, sTextColor, sBackgroundColor )\
        local nStart = nCursorX\
        local nEnd = nStart + #sText - 1\
        if nCursorY >= 1 and nCursorY <= nHeight then\
            if nStart <= nWidth and nEnd >= 1 then\
                -- Modify line\
                local tLine = tLines[ nCursorY ]\
                if nStart == 1 and nEnd == nWidth then\
                    tLine.text = sText\
                    tLine.textColor = sTextColor\
                    tLine.backgroundColor = sBackgroundColor\
                else\
                    local sClippedText, sClippedTextColor, sClippedBackgroundColor\
                    if nStart < 1 then\
                        local nClipStart = 1 - nStart + 1\
                        local nClipEnd = nWidth - nStart + 1\
                        sClippedText = string_sub( sText, nClipStart, nClipEnd )\
                        sClippedTextColor = string_sub( sTextColor, nClipStart, nClipEnd )\
                        sClippedBackgroundColor = string_sub( sBackgroundColor, nClipStart, nClipEnd )\
                    elseif nEnd > nWidth then\
                        local nClipEnd = nWidth - nStart + 1\
                        sClippedText = string_sub( sText, 1, nClipEnd )\
                        sClippedTextColor = string_sub( sTextColor, 1, nClipEnd )\
                        sClippedBackgroundColor = string_sub( sBackgroundColor, 1, nClipEnd )\
                    else\
                        sClippedText = sText\
                        sClippedTextColor = sTextColor\
                        sClippedBackgroundColor = sBackgroundColor\
                    end\
\
                    local sOldText = tLine.text\
                    local sOldTextColor = tLine.textColor\
                    local sOldBackgroundColor = tLine.backgroundColor\
                    local sNewText, sNewTextColor, sNewBackgroundColor\
                    if nStart > 1 then\
                        local nOldEnd = nStart - 1\
                        sNewText = string_sub( sOldText, 1, nOldEnd ) .. sClippedText\
                        sNewTextColor = string_sub( sOldTextColor, 1, nOldEnd ) .. sClippedTextColor\
                        sNewBackgroundColor = string_sub( sOldBackgroundColor, 1, nOldEnd ) .. sClippedBackgroundColor\
                    else\
                        sNewText = sClippedText\
                        sNewTextColor = sClippedTextColor\
                        sNewBackgroundColor = sClippedBackgroundColor\
                    end\
                    if nEnd < nWidth then\
                        local nOldStart = nEnd + 1\
                        sNewText = sNewText .. string_sub( sOldText, nOldStart, nWidth )\
                        sNewTextColor = sNewTextColor .. string_sub( sOldTextColor, nOldStart, nWidth )\
                        sNewBackgroundColor = sNewBackgroundColor .. string_sub( sOldBackgroundColor, nOldStart, nWidth )\
                    end\
\
                    tLine.text = sNewText\
                    tLine.textColor = sNewTextColor\
                    tLine.backgroundColor = sNewBackgroundColor\
                end\
\
                -- Redraw line\
                if bVisible then\
                    redrawLine( nCursorY )\
                end\
            end\
        end\
\
        -- Move and redraw cursor\
        nCursorX = nEnd + 1\
        if bVisible then\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    -- Terminal implementation\
    local window = {}\
\
    function window.write( sText )\
        sText = tostring( sText )\
        internalBlit( sText, string_rep( tHex[ nTextColor ], #sText ), string_rep( tHex[ nBackgroundColor ], #sText ) )\
    end\
\
    function window.blit( sText, sTextColor, sBackgroundColor )\
        if type(sText) ~= \"string\" or type(sTextColor) ~= \"string\" or type(sBackgroundColor) ~= \"string\" then\
            error( \"Expected string, string, string\", 2 )\
        end\
        if #sTextColor ~= #sText or #sBackgroundColor ~= #sText then\
            error( \"Arguments must be the same length\", 2 )\
        end\
        internalBlit( sText, sTextColor, sBackgroundColor )\
    end\
\
    function window.clear()\
        local sEmptyText = sEmptySpaceLine\
        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
        for y=1,nHeight do\
            tLines[y] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
        end\
        if bVisible then\
            redraw()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.clearLine()\
        if nCursorY >= 1 and nCursorY <= nHeight then\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            tLines[ nCursorY ] = {\
                text = sEmptyText,\
                textColor = sEmptyTextColor,\
                backgroundColor = sEmptyBackgroundColor,\
            }\
            if bVisible then\
                redrawLine( nCursorY )\
                updateCursorColor()\
                updateCursorPos()\
            end\
        end\
    end\
\
    function window.getCursorPos()\
        return nCursorX, nCursorY\
    end\
\
    function window.setCursorPos( x, y )\
        nCursorX = math.floor( x )\
        nCursorY = math.floor( y )\
        if bVisible then\
            updateCursorPos()\
        end\
    end\
\
    function window.setCursorBlink( blink )\
        bCursorBlink = blink\
        if bVisible then\
            updateCursorBlink()\
        end\
    end\
\
    local function isColor()\
        return parent.isColor()\
    end\
\
    function window.isColor()\
        return isColor()\
    end\
\
    function window.isColour()\
        return isColor()\
    end\
\
    local function setTextColor( color )\
        if not parent.isColor() then\
            if color ~= colors.white and color ~= colors.black and color ~= colors.gray and color ~= colors.lightGray then\
                error( \"Color not supported\", 3 )\
            end\
        end\
        nTextColor = color\
        if bVisible then\
            updateCursorColor()\
        end\
    end\
\
    function window.setTextColor( color )\
        setTextColor( color )\
    end\
\
    function window.setTextColour( color )\
        setTextColor( color )\
    end\
\
    local function setBackgroundColor( color )\
        if not parent.isColor() then\
            if color ~= colors.white and color ~= colors.black and color ~= colors.gray and color ~= colors.lightGray then\
                error( \"Color not supported\", 3 )\
            end\
        end\
        nBackgroundColor = color\
    end\
\
    function window.setBackgroundColor( color )\
        setBackgroundColor( color )\
    end\
\
    function window.setBackgroundColour( color )\
        setBackgroundColor( color )\
    end\
\
    function window.getSize()\
        return nWidth, nHeight\
    end\
\
    function window.scroll( n )\
        if n ~= 0 then\
            local tNewLines = {}\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            for newY=1,nHeight do\
                local y = newY + n\
                if y >= 1 and y <= nHeight then\
                    tNewLines[newY] = tLines[y]\
                else\
                    tNewLines[newY] = {\
                        text = sEmptyText,\
                        textColor = sEmptyTextColor,\
                        backgroundColor = sEmptyBackgroundColor,\
                    }\
                end\
            end\
            tLines = tNewLines\
            if bVisible then\
                redraw()\
                updateCursorColor()\
                updateCursorPos()\
            end\
        end\
    end\
\
    function window.getTextColor()\
        return nTextColor\
    end\
\
    function window.getTextColour()\
        return nTextColor\
    end\
\
    function window.getBackgroundColor()\
        return nBackgroundColor\
    end\
\
    function window.getBackgroundColour()\
        return nBackgroundColor\
    end\
\
    -- Other functions\
    function window.setVisible( bVis )\
        if bVisible ~= bVis then\
            bVisible = bVis\
            if bVisible then\
                window.redraw()\
            end\
        end\
    end\
\
    function window.redraw()\
        if bVisible then\
            redraw()\
            updateCursorBlink()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.restoreCursor()\
        if bVisible then\
            updateCursorBlink()\
            updateCursorColor()\
            updateCursorPos()\
        end\
    end\
\
    function window.getPosition()\
        return nX, nY\
    end\
\
    function window.reposition( nNewX, nNewY, nNewWidth, nNewHeight )\
        nX = nNewX\
        nY = nNewY\
        if nNewWidth and nNewHeight then\
            local tNewLines = {}\
            createEmptyLines( nNewWidth )\
            local sEmptyText = sEmptySpaceLine\
            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\
            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\
            for y=1,nNewHeight do\
                if y > nHeight then\
                    tNewLines[y] = {\
                        text = sEmptyText,\
                        textColor = sEmptyTextColor,\
                        backgroundColor = sEmptyBackgroundColor\
                    }\
                else\
                    local tOldLine = tLines[y]\
                    if nNewWidth == nWidth then\
                        tNewLines[y] = tOldLine\
                    elseif nNewWidth < nWidth then\
                        tNewLines[y] = {\
                            text = string_sub( tOldLine.text, 1, nNewWidth ),\
                            textColor = string_sub( tOldLine.textColor, 1, nNewWidth ),\
                            backgroundColor = string_sub( tOldLine.backgroundColor, 1, nNewWidth ),\
                        }\
                    else\
                        tNewLines[y] = {\
                            text = tOldLine.text .. string_sub( sEmptyText, nWidth + 1, nNewWidth ),\
                            textColor = tOldLine.textColor .. string_sub( sEmptyTextColor, nWidth + 1, nNewWidth ),\
                            backgroundColor = tOldLine.backgroundColor .. string_sub( sEmptyBackgroundColor, nWidth + 1, nNewWidth ),\
                        }\
                    end\
                end\
            end\
            nWidth = nNewWidth\
            nHeight = nNewHeight\
            tLines = tNewLines\
        end\
        if bVisible then\
            window.redraw()\
        end\
    end\
\
    if bVisible then\
        window.redraw()\
    end\
    return window\
end",
      "\
local function drawPixelInternal( xPos, yPos )\
    term.setCursorPos( xPos, yPos )\
    term.write(\" \")\
end\
\
local tColourLookup = {}\
for n=1,16 do\
    tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\
end\
\
function loadImage( sPath )\
    if type( sPath ) ~= \"string\" then\
        error( \"Expected path\", 2 )\
    end\
\
    local tImage = {}\
    if fs.exists( sPath ) then\
        local file = io.open(sPath, \"r\" )\
        local sLine = file:read()\
        while sLine do\
            local tLine = {}\
            for x=1,sLine:len() do\
                tLine[x] = tColourLookup[ string.byte(sLine,x,x) ] or 0\
            end\
            table.insert( tImage, tLine )\
            sLine = file:read()\
        end\
        file:close()\
        return tImage\
    end\
    return nil\
end\
\
function drawPixel( xPos, yPos, nColour )\
    if type( xPos ) ~= \"number\" or type( yPos ) ~= \"number\" or (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected x, y, colour\", 2 )\
    end\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    drawPixelInternal( xPos, yPos )\
end\
\
function drawLine( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
    \
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
    \
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    -- TODO: clip to screen rectangle?\
        \
    local xDiff = maxX - minX\
    local yDiff = maxY - minY\
            \
    if xDiff > math.abs(yDiff) then\
        local y = minY\
        local dy = yDiff / xDiff\
        for x=minX,maxX do\
            drawPixelInternal( x, math.floor( y + 0.5 ) )\
            y = y + dy\
        end\
    else\
        local x = minX\
        local dx = xDiff / yDiff\
        if maxY >= minY then\
            for y=minY,maxY do\
                drawPixelInternal( math.floor( x + 0.5 ), y )\
                x = x + dx\
            end\
        else\
            for y=minY,maxY,-1 do\
                drawPixelInternal( math.floor( x + 0.5 ), y )\
                x = x - dx\
            end\
        end\
    end\
end\
\
function drawBox( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
\
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
\
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    for x=minX,maxX do\
        drawPixelInternal( x, minY )\
        drawPixelInternal( x, maxY )\
    end\
\
    if (maxY - minY) >= 2 then\
        for y=(minY+1),(maxY-1) do\
            drawPixelInternal( minX, y )\
            drawPixelInternal( maxX, y )\
        end\
    end\
end\
\
function drawFilledBox( startX, startY, endX, endY, nColour )\
    if type( startX ) ~= \"number\" or type( startX ) ~= \"number\" or\
       type( endX ) ~= \"number\" or type( endY ) ~= \"number\" or\
       (nColour ~= nil and type( nColour ) ~= \"number\") then\
        error( \"Expected startX, startY, endX, endY, colour\", 2 )\
    end\
\
    startX = math.floor(startX)\
    startY = math.floor(startY)\
    endX = math.floor(endX)\
    endY = math.floor(endY)\
\
    if nColour then\
        term.setBackgroundColor( nColour )\
    end\
    if startX == endX and startY == endY then\
        drawPixelInternal( startX, startY )\
        return\
    end\
\
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    for x=minX,maxX do\
        for y=minY,maxY do\
            drawPixelInternal( x, y )\
        end\
    end\
end\
\
function drawImage( tImage, xPos, yPos )\
    if type( tImage ) ~= \"table\" or type( xPos ) ~= \"number\" or type( yPos ) ~= \"number\" then\
        error( \"Expected image, x, y\", 2 )\
    end\
    for y=1,#tImage do\
        local tLine = tImage[y]\
        for x=1,#tLine do\
            if tLine[x] > 0 then\
                term.setBackgroundColor( tLine[x] )\
                drawPixelInternal( x + xPos - 1, y + yPos - 1 )\
            end\
        end\
    end\
end",
      "\
if not turtle then\
\009error( \"Cannot load turtle API on computer\", 2 )\
end\
native = turtle.native or turtle\
\
local function addCraftMethod( object )\
    if peripheral.getType( \"left\" ) == \"workbench\" then\
        object.craft = function( ... )\
            return peripheral.call( \"left\", \"craft\", ... )\
        end\
    elseif peripheral.getType( \"right\" ) == \"workbench\" then\
        object.craft = function( ... )\
            return peripheral.call( \"right\", \"craft\", ... )\
        end\
    else\
        object.craft = nil\
    end\
end\
\
-- Put commands into environment table\
local env = _ENV\
for k,v in pairs( native ) do\
    if k == \"equipLeft\" or k == \"equipRight\" then\
        env[k] = function( ... )\
            local result, err = v( ... )\
            addCraftMethod( turtle )\
            return result, err\
        end\
    else\
    \009env[k] = v\
    end\
end\
addCraftMethod( env )",
      "-- Colours (for lovers of british spelling)\
local colours = _ENV\
for k,v in pairs(colors) do\
\009colours[k] = v\
end\
\
colours.grey = colors.gray\
colours.gray = nil\
\
colours.lightGrey = colors.lightGray\
colours.lightGray = nil",
      "for k, v in ipairs(fs.list(\"/rom/apis/\")) do\
\009if not fs.isDir(\"/rom/apis/\"..v) then\
\009\009print(\"loading: /rom/apis/\"..v)\
\009\009os.loadAPI(\"/rom/apis/\"..v)\
\009end\
end\
_G.colors.lightGrey = _G.colors.lightGray\
_G.colors.grey = _G.colors.gray\
_G.colours = _G.colors",
    },
  },
  bootSector = {
    [ "bios.lua" ] = "\
local label = \"cVM\"\
os.loadAPI = function(path)\
\009local f, err = loadfile(path)\
\009if not f then\
\009\009return false, err\
\009end\
\009local env = {}\
\009setmetatable(env, {__index=_G})\
\009setfenv(f, env)\
\009local k, err = pcall(f)\
\009if not k then \
\009\009return false, err\
\009end\
\009_G[fs.getName(path)] = {}\
\009for k, v in pairs(env) do\
\009\009_G[fs.getName(path)][k] = v\
\009end\
\009return true\
end\
os.version = function()\
\009return \"cVMWare CraftOS 1.7\"\
end\
os.getComputerID = function()\
\009return 0\
end\
os.getComputerLabel = function()\
\009return label\
end\
os.setComputerLabel = function(lbl)\
\009if lbl then\
\009\009label = lbl\
\009else\
\009\009label = \"cVM\"\
\009end\
end\
_G.write = function(string)\
\009term.write(string)\
end\
_G.sleep = function(time)\
\009return os.sleep(time)\
end\
_G.printError = function(string)\
\009local c = term.getTextColor()\
\009term.setTextColor(16384)\
\009print(string)\
\009term.setTextColor(c)\
end\
function os.run(env, path, ...)\
\009local tArgs = {...}\
\009local func, err = loadfile(path)\
\009if not func then return false, err end\
\009setmetatable(env, {__index = _G})\
\009setfenv(func, env)\
\009return func(unpack(tArgs))\
end\
os.unloadAPI = function(name)\
\009_G[name] = nil\
end\
for k, v in pairs(_G) do\
\009term.write(k..\":\")\
end\
\
print(\"\")\
print(\"\")\
for k, v in ipairs(fs.list(\"/\")) do\
\009print(v)\
end\
print(\"Finished BIOS!\")\
print(\"NOTE: This is NOT CraftOS, many APIs you know from\")\
print(\"stock CC are not existent!!!\")\
print(\"Type 'reboot' to reboot this VM\")\
print(\"Type 'shutdown' to shut this VM down.\")\
print(\"Type 'newFile' to create a file in /\")\
print(\"Type 'ls' to list the files in /\")\
print(\"Type 'del' to delete a file in /\")\
while true do\
\009local e = read()\
\009if e == \"reboot\" then\
\009\009_vm.reboot()\
\009elseif e == \"shutdown\" then\
\009\009_vm.shutdown()\
\009elseif fs.exists(e) and fs.isDir(e) == false then\
\009\009local a, err = loadfile(e)\
\009\009if not a then\
\009\009\009print(err)\
\009\009else\
\009\009\009local _, err = pcall(a)\
\009\009\009if not _ then\
\009\009\009\009print(err)\
\009\009\009else\
\009\009\009\009print(\"Successfully executed!\")\
\009\009\009end\
\009\009end\
\009elseif e == \"newFile\" then\
\009\009term.write(\"Name: \")\
\009\009e = read()\
\009\009if #e < 1 then\
\009\009\009e = \"newFile\" \
\009\009end\
\009\009local file = fs.open(e, \"w\")\
\009\009term.write(\"Text: \")\
\009\009e = read()\
\009\009file.writeLine(e)\
\009\009file.close()\
\009\009print(\"Finished!\")\
\009elseif e == \"ls\" then\
\009\009local list = fs.list(\"/\")\
\009\009for k, v in ipairs(list) do\
\009\009\009print(v)\
\009\009end\
\009elseif e == \"del\" then\
\009\009term.write(\"Path:\")\
\009\009local e = read()\
\009\009local ok, err = fs.delete(e..\"/\")\
\009\009if ok or err == nil then\
\009\009\009print(\"Finished!\")\
\009\009else\
\009\009\009print(\"Error:\"..tostring(err))\
\009\009end\
\009end\
end",
  },
}